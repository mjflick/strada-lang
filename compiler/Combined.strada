/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# AST.strada - Abstract Syntax Tree for self-hosting Strada compiler
# Defines node types and constructors for the parse tree

# Node type constants
func NODE_PROGRAM() int { return 1; }
func NODE_FUNC() int { return 2; }
func NODE_PARAM() int { return 3; }
func NODE_BLOCK() int { return 4; }
func NODE_VAR_DECL() int { return 5; }
func NODE_IF_STMT() int { return 6; }
func NODE_WHILE_STMT() int { return 7; }
func NODE_FOR_STMT() int { return 8; }
func NODE_RETURN_STMT() int { return 9; }
func NODE_EXPR_STMT() int { return 10; }
func NODE_BINARY_OP() int { return 11; }
func NODE_UNARY_OP() int { return 12; }
func NODE_CALL() int { return 13; }
func NODE_VARIABLE() int { return 14; }
func NODE_INT_LITERAL() int { return 15; }
func NODE_NUM_LITERAL() int { return 16; }
func NODE_STR_LITERAL() int { return 17; }
func NODE_ASSIGN() int { return 18; }
func NODE_SUBSCRIPT() int { return 19; }
func NODE_HASH_ACCESS() int { return 20; }
func NODE_REF() int { return 21; }
func NODE_DEREF_HASH() int { return 22; }
func NODE_DEREF_ARRAY() int { return 23; }
func NODE_DEREF_SCALAR() int { return 24; }
func NODE_ANON_HASH() int { return 25; }
func NODE_ANON_ARRAY() int { return 26; }
func NODE_EXTERN_FUNC() int { return 27; }
func NODE_STRUCT() int { return 28; }
func NODE_USE() int { return 29; }
func NODE_FIELD_ACCESS() int { return 30; }
func NODE_FUNC_REF() int { return 31; }
func NODE_METHOD_CALL() int { return 32; }
func NODE_DUNDER_PACKAGE() int { return 33; }
func NODE_DUNDER_FILE() int { return 36; }
func NODE_DUNDER_LINE() int { return 37; }
func NODE_REGEX_MATCH() int { return 34; }
func NODE_REGEX_SUBST() int { return 35; }
func NODE_LAST() int { return 100; }
func NODE_NEXT() int { return 101; }
func NODE_UNDEF() int { return 102; }
func NODE_MAP() int { return 103; }
func NODE_SORT() int { return 104; }
func NODE_GREP() int { return 105; }
func NODE_TRY_CATCH() int { return 106; }
func NODE_THROW() int { return 107; }
func NODE_LABEL() int { return 108; }
func NODE_GOTO() int { return 109; }
func NODE_FOREACH_STMT() int { return 110; }
func NODE_ANON_FUNC() int { return 111; }
func NODE_CLOSURE_CALL() int { return 112; }
func NODE_TERNARY() int { return 113; }
func NODE_SWITCH() int { return 114; }
func NODE_RANGE() int { return 115; }
func NODE_SUPER_CALL() int { return 116; }
func NODE_INCREMENT() int { return 117; }

# Type constants
func TYPE_INT() int { return 1; }
func TYPE_NUM() int { return 2; }
func TYPE_STR() int { return 3; }
func TYPE_ARRAY() int { return 4; }
func TYPE_HASH() int { return 5; }
func TYPE_SCALAR() int { return 6; }
func TYPE_VOID() int { return 7; }
func TYPE_STRUCT() int { return 8; }
func TYPE_FUNCPTR() int { return 9; }

# Explicit sized types for extern functions (C interop)
func TYPE_INT32() int { return 10; }    # int32_t / int
func TYPE_INT64() int { return 11; }    # int64_t / long long
func TYPE_FLOAT32() int { return 12; }  # float (32-bit)
func TYPE_FLOAT64() int { return 13; }  # double (64-bit)

# ============================================================
# Node Constructors
# ============================================================

# Create a new AST node of given type
func ast_new_node(int $type) scalar {
    my hash %node = ();
    $node{"type"} = $type;
    $node{"line"} = 0;
    return \%node;
}

# Set line number on a node
func ast_set_line(scalar $node, int $line) void {
    $node->{"line"} = $line;
}

# Get line number from a node (returns 0 if not set)
func ast_get_line(scalar $node) int {
    return $node->{"line"};
}

# Create program node
func ast_new_program() scalar {
    my scalar $node = ast_new_node(NODE_PROGRAM());
    my array @funcs = ();
    my array @structs = ();
    my array @uses = ();
    my array @imports = ();
    my array @inherits = ();
    my array @lib_paths = ();
    my hash %loaded_modules = ();
    $node->{"functions"} = \@funcs;
    $node->{"structs"} = \@structs;
    $node->{"uses"} = \@uses;
    $node->{"imports"} = \@imports;
    $node->{"inherits"} = \@inherits;
    $node->{"lib_paths"} = \@lib_paths;
    $node->{"lib_path_count"} = 0;
    $node->{"loaded_modules"} = \%loaded_modules;
    $node->{"function_count"} = 0;
    $node->{"struct_count"} = 0;
    $node->{"use_count"} = 0;
    $node->{"import_count"} = 0;
    $node->{"inherit_count"} = 0;
    $node->{"package"} = "";
    my array @globals = ();
    $node->{"globals"} = \@globals;
    $node->{"global_count"} = 0;
    # import_lib support - array of {lib_name, so_path, functions: [{name, param_count, return_type, params}]}
    my array @import_libs = ();
    $node->{"import_libs"} = \@import_libs;
    $node->{"import_lib_count"} = 0;
    return $node;
}

# Add function to program
func ast_add_function(scalar $program, scalar $fn) void {
    my scalar $funcs = $program->{"functions"};
    push($funcs, $fn);
    $program->{"function_count"} = $program->{"function_count"} + 1;
}

# Add global variable to program
func ast_add_global(scalar $program, scalar $var_decl) void {
    my scalar $globals = $program->{"globals"};
    push($globals, $var_decl);
    $program->{"global_count"} = $program->{"global_count"} + 1;
}

# Add struct to program
func ast_add_struct(scalar $program, scalar $st) void {
    my scalar $structs = $program->{"structs"};
    push($structs, $st);
    $program->{"struct_count"} = $program->{"struct_count"} + 1;
}

# Add use to program
func ast_add_use(scalar $program, str $module) void {
    my scalar $uses = $program->{"uses"};
    push($uses, $module);
    $program->{"use_count"} = $program->{"use_count"} + 1;
}

# Add inherit to program (parent package name)
func ast_add_inherit(scalar $program, str $parent) void {
    my scalar $inherits = $program->{"inherits"};
    push($inherits, $parent);
    $program->{"inherit_count"} = $program->{"inherit_count"} + 1;
}

# Add imported function name to program
func ast_add_import(scalar $program, str $func_name) void {
    my scalar $imports = $program->{"imports"};
    push($imports, $func_name);
    $program->{"import_count"} = $program->{"import_count"} + 1;
}

# Add lib path to program
func ast_add_lib_path(scalar $program, str $path) void {
    my scalar $paths = $program->{"lib_paths"};
    push($paths, $path);
    $program->{"lib_path_count"} = $program->{"lib_path_count"} + 1;
}

# Check if module is already loaded
func ast_is_module_loaded(scalar $program, str $module) int {
    my scalar $loaded = $program->{"loaded_modules"};
    my int $val = $loaded->{$module};
    if ($val == 1) {
        return 1;
    }
    return 0;
}

# Mark module as loaded
func ast_mark_module_loaded(scalar $program, str $module) void {
    my scalar $loaded = $program->{"loaded_modules"};
    $loaded->{$module} = 1;
}

# Add an imported library with its function info
# $lib_info is a hash with: lib_name, so_path, functions (array of function info)
func ast_add_import_lib(scalar $program, scalar $lib_info) void {
    my scalar $libs = $program->{"import_libs"};
    push($libs, $lib_info);
    $program->{"import_lib_count"} = $program->{"import_lib_count"} + 1;
}

# Create extern function node
func ast_new_extern_func(str $name) scalar {
    my scalar $node = ast_new_node(NODE_EXTERN_FUNC());
    my array @params = ();
    $node->{"name"} = $name;
    $node->{"return_type"} = TYPE_VOID();
    $node->{"params"} = \@params;
    $node->{"param_count"} = 0;
    $node->{"is_extern"} = 1;
    return $node;
}

# Create struct node
func ast_new_struct(str $name) scalar {
    my scalar $node = ast_new_node(NODE_STRUCT());
    my array @fields = ();
    $node->{"name"} = $name;
    $node->{"fields"} = \@fields;
    $node->{"field_count"} = 0;
    return $node;
}

# Add field to struct
func ast_add_field(scalar $st, str $name, int $field_type, str $sigil) void {
    my hash %field = ();
    $field{"name"} = $name;
    $field{"field_type"} = $field_type;
    $field{"sigil"} = $sigil;
    my scalar $fields = $st->{"fields"};
    push($fields, \%field);
    $st->{"field_count"} = $st->{"field_count"} + 1;
}

# Create function node
func ast_new_function(str $name, int $return_type) scalar {
    my scalar $node = ast_new_node(NODE_FUNC());
    my array @params = ();
    $node->{"name"} = $name;
    $node->{"return_type"} = $return_type;
    $node->{"params"} = \@params;
    $node->{"param_count"} = 0;
    $node->{"body"} = 0;  # Will be set later
    $node->{"is_extern"} = 0;
    return $node;
}

# Add parameter to function
func ast_add_param(scalar $fn, scalar $param) void {
    my scalar $params = $fn->{"params"};
    push($params, $param);
    $fn->{"param_count"} = $fn->{"param_count"} + 1;
}

# Create parameter node
func ast_new_param(str $name, int $param_type, str $sigil) scalar {
    my scalar $node = ast_new_node(NODE_PARAM());
    $node->{"name"} = $name;
    $node->{"param_type"} = $param_type;
    $node->{"sigil"} = $sigil;
    $node->{"is_optional"} = 0;
    $node->{"default_value"} = 0;
    return $node;
}

# Create block node
func ast_new_block() scalar {
    my scalar $node = ast_new_node(NODE_BLOCK());
    my array @stmts = ();
    $node->{"statements"} = \@stmts;
    $node->{"statement_count"} = 0;
    return $node;
}

# Add statement to block
func ast_add_statement(scalar $block, scalar $stmt) void {
    my scalar $stmts = $block->{"statements"};
    push($stmts, $stmt);
    $block->{"statement_count"} = $block->{"statement_count"} + 1;
}

# Create variable declaration
func ast_new_var_decl(str $name, int $var_type, str $sigil) scalar {
    my scalar $node = ast_new_node(NODE_VAR_DECL());
    $node->{"name"} = $name;
    $node->{"var_type"} = $var_type;
    $node->{"sigil"} = $sigil;
    $node->{"init"} = 0;
    return $node;
}

# Create if statement
func ast_new_if_stmt(scalar $condition, scalar $then_block) scalar {
    my scalar $node = ast_new_node(NODE_IF_STMT());
    my array @elsif_conds = ();
    my array @elsif_blocks = ();
    $node->{"condition"} = $condition;
    $node->{"then_block"} = $then_block;
    $node->{"elsif_conditions"} = \@elsif_conds;
    $node->{"elsif_blocks"} = \@elsif_blocks;
    $node->{"elsif_count"} = 0;
    $node->{"else_block"} = 0;
    return $node;
}

# Add elsif clause to if statement
func ast_add_elsif(scalar $if_stmt, scalar $condition, scalar $block) void {
    my scalar $conds = $if_stmt->{"elsif_conditions"};
    my scalar $blocks = $if_stmt->{"elsif_blocks"};
    push($conds, $condition);
    push($blocks, $block);
    $if_stmt->{"elsif_count"} = $if_stmt->{"elsif_count"} + 1;
}

# Create while statement
func ast_new_while_stmt(scalar $condition, scalar $body, str $label) scalar {
    my scalar $node = ast_new_node(NODE_WHILE_STMT());
    $node->{"condition"} = $condition;
    $node->{"body"} = $body;
    $node->{"label"} = $label;
    return $node;
}

# Create for statement
func ast_new_for_stmt(scalar $init, scalar $cond, scalar $update, scalar $body, str $label) scalar {
    my scalar $node = ast_new_node(NODE_FOR_STMT());
    $node->{"init"} = $init;
    $node->{"condition"} = $cond;
    $node->{"update"} = $update;
    $node->{"body"} = $body;
    $node->{"label"} = $label;
    return $node;
}

# Create foreach statement (foreach my type $var (@array) or foreach $var (@array))
func ast_new_foreach_stmt(scalar $var_decl, str $var_name, scalar $array_expr, scalar $body, str $label) scalar {
    my scalar $node = ast_new_node(NODE_FOREACH_STMT());
    $node->{"var_decl"} = $var_decl;      # Variable declaration node (or undef if using existing var)
    $node->{"var_name"} = $var_name;      # Variable name (for existing var case)
    $node->{"array"} = $array_expr;       # Array expression to iterate
    $node->{"body"} = $body;              # Loop body
    $node->{"label"} = $label;            # Optional label for last/next
    return $node;
}

# Create return statement
func ast_new_return_stmt(scalar $value) scalar {
    my scalar $node = ast_new_node(NODE_RETURN_STMT());
    $node->{"value"} = $value;
    return $node;
}

# Create last statement (break from loop)
func ast_new_last(str $label) scalar {
    my scalar $node = ast_new_node(NODE_LAST());
    $node->{"label"} = $label;
    return $node;
}

# Create next statement (continue loop)
func ast_new_next(str $label) scalar {
    my scalar $node = ast_new_node(NODE_NEXT());
    $node->{"label"} = $label;
    return $node;
}

# Create expression statement
func ast_new_expr_stmt(scalar $expr) scalar {
    my scalar $node = ast_new_node(NODE_EXPR_STMT());
    $node->{"expr"} = $expr;
    return $node;
}

# Create binary operation
func ast_new_binary_op(str $op, scalar $left, scalar $right) scalar {
    my scalar $node = ast_new_node(NODE_BINARY_OP());
    $node->{"op"} = $op;
    $node->{"left"} = $left;
    $node->{"right"} = $right;
    return $node;
}

# Create unary operation
func ast_new_unary_op(str $op, scalar $operand) scalar {
    my scalar $node = ast_new_node(NODE_UNARY_OP());
    $node->{"op"} = $op;
    $node->{"operand"} = $operand;
    return $node;
}

# Create increment/decrement operation (++ or --)
# $op is "++" or "--", $is_prefix is 1 for prefix, 0 for postfix
func ast_new_increment(str $op, scalar $operand, int $is_prefix) scalar {
    my scalar $node = ast_new_node(NODE_INCREMENT());
    $node->{"op"} = $op;
    $node->{"operand"} = $operand;
    $node->{"is_prefix"} = $is_prefix;
    return $node;
}

# Create function call
func ast_new_call(str $name) scalar {
    my scalar $node = ast_new_node(NODE_CALL());
    my array @args = ();
    $node->{"name"} = $name;
    $node->{"args"} = \@args;
    $node->{"arg_count"} = 0;
    return $node;
}

# Add argument to call
func ast_add_arg(scalar $call, scalar $arg) void {
    my scalar $args = $call->{"args"};
    push($args, $arg);
    $call->{"arg_count"} = $call->{"arg_count"} + 1;
}

# Create variable reference
func ast_new_variable(str $name, str $sigil) scalar {
    my scalar $node = ast_new_node(NODE_VARIABLE());
    $node->{"name"} = $name;
    $node->{"sigil"} = $sigil;
    return $node;
}

# Create integer literal
func ast_new_int_literal(int $value) scalar {
    my scalar $node = ast_new_node(NODE_INT_LITERAL());
    $node->{"value"} = $value;
    return $node;
}

# Create number literal
func ast_new_num_literal(num $value) scalar {
    my scalar $node = ast_new_node(NODE_NUM_LITERAL());
    $node->{"value"} = $value;
    return $node;
}

# Create string literal
func ast_new_str_literal(str $value) scalar {
    my scalar $node = ast_new_node(NODE_STR_LITERAL());
    $node->{"value"} = $value;
    return $node;
}

# Create undef literal
func ast_new_undef() scalar {
    my scalar $node = ast_new_node(NODE_UNDEF());
    return $node;
}

# Create map expression: map { block } @array
func ast_new_map(scalar $block, scalar $array_expr) scalar {
    my scalar $node = ast_new_node(NODE_MAP());
    $node->{"block"} = $block;
    $node->{"array"} = $array_expr;
    return $node;
}

# Create sort expression: sort { $a <=> $b } @array
func ast_new_sort(scalar $block, scalar $array_expr) scalar {
    my scalar $node = ast_new_node(NODE_SORT());
    $node->{"block"} = $block;
    $node->{"array"} = $array_expr;
    return $node;
}

# Create grep expression: grep { block } @array
func ast_new_grep(scalar $block, scalar $array_expr) scalar {
    my scalar $node = ast_new_node(NODE_GREP());
    $node->{"block"} = $block;
    $node->{"array"} = $array_expr;
    return $node;
}

# Create assignment
func ast_new_assign(str $op, scalar $target, scalar $value) scalar {
    my scalar $node = ast_new_node(NODE_ASSIGN());
    $node->{"op"} = $op;
    $node->{"target"} = $target;
    $node->{"value"} = $value;
    return $node;
}

# Create array subscript
func ast_new_subscript(scalar $arr, scalar $index) scalar {
    my scalar $node = ast_new_node(NODE_SUBSCRIPT());
    $node->{"array"} = $arr;
    $node->{"index"} = $index;
    return $node;
}

# Create hash access
func ast_new_hash_access(scalar $hash_var, scalar $key) scalar {
    my scalar $node = ast_new_node(NODE_HASH_ACCESS());
    $node->{"hash"} = $hash_var;
    $node->{"key"} = $key;
    return $node;
}

# Create reference
func ast_new_ref(scalar $target, str $ref_type) scalar {
    my scalar $node = ast_new_node(NODE_REF());
    $node->{"target"} = $target;
    $node->{"ref_type"} = $ref_type;
    return $node;
}

# Create hash dereference ($ref->{key})
func ast_new_deref_hash(scalar $ref_expr, scalar $key) scalar {
    my scalar $node = ast_new_node(NODE_DEREF_HASH());
    $node->{"ref"} = $ref_expr;
    $node->{"key"} = $key;
    return $node;
}

# Create array dereference ($ref->[index])
func ast_new_deref_array(scalar $ref_expr, scalar $index) scalar {
    my scalar $node = ast_new_node(NODE_DEREF_ARRAY());
    $node->{"ref"} = $ref_expr;
    $node->{"index"} = $index;
    return $node;
}

# Create scalar dereference ($$ref) or array/hash dereference (@{}, %{})
func ast_new_deref_scalar(scalar $ref_expr, str $sigil) scalar {
    my scalar $node = ast_new_node(NODE_DEREF_SCALAR());
    $node->{"ref"} = $ref_expr;
    $node->{"sigil"} = $sigil;
    return $node;
}

# Create anonymous hash ({ key => value, ... })
func ast_new_anon_hash() scalar {
    my scalar $node = ast_new_node(NODE_ANON_HASH());
    my array @keys = ();
    my array @values = ();
    $node->{"keys"} = \@keys;
    $node->{"values"} = \@values;
    $node->{"pair_count"} = 0;
    return $node;
}

# Add pair to anonymous hash
func ast_add_hash_pair(scalar $hash_node, str $key, scalar $value) void {
    my scalar $keys = $hash_node->{"keys"};
    my scalar $values = $hash_node->{"values"};
    push($keys, $key);
    push($values, $value);
    $hash_node->{"pair_count"} = $hash_node->{"pair_count"} + 1;
}

# Create anonymous array ([ elem, ... ])
func ast_new_anon_array() scalar {
    my scalar $node = ast_new_node(NODE_ANON_ARRAY());
    my array @elems = ();
    $node->{"elements"} = \@elems;
    $node->{"element_count"} = 0;
    return $node;
}

# Add element to anonymous array
func ast_add_array_elem(scalar $arr_node, scalar $elem) void {
    my scalar $elems = $arr_node->{"elements"};
    push($elems, $elem);
    $arr_node->{"element_count"} = $arr_node->{"element_count"} + 1;
}

# Create field access node (obj->field)
func ast_new_field_access(scalar $obj, str $field) scalar {
    my scalar $node = ast_new_node(NODE_FIELD_ACCESS());
    $node->{"object"} = $obj;
    $node->{"field"} = $field;
    return $node;
}

# Create function reference node (&func_name)
func ast_new_func_ref(str $name) scalar {
    my scalar $node = ast_new_node(NODE_FUNC_REF());
    $node->{"name"} = $name;
    return $node;
}

# Create method call node ($obj->method(args))
func ast_new_method_call(scalar $object, str $method) scalar {
    my scalar $node = ast_new_node(NODE_METHOD_CALL());
    my array @args = ();
    $node->{"object"} = $object;
    $node->{"method"} = $method;
    $node->{"args"} = \@args;
    $node->{"arg_count"} = 0;
    return $node;
}

# Create SUPER::method() call node
func ast_new_super_call(str $method) scalar {
    my scalar $node = ast_new_node(NODE_SUPER_CALL());
    my array @args = ();
    $node->{"method"} = $method;
    $node->{"args"} = \@args;
    $node->{"arg_count"} = 0;
    return $node;
}

# Create __PACKAGE__ node
func ast_new_dunder_package() scalar {
    return ast_new_node(NODE_DUNDER_PACKAGE());
}

# Create __FILE__ node
func ast_new_dunder_file() scalar {
    return ast_new_node(NODE_DUNDER_FILE());
}

# Create __LINE__ node (stores the line number)
func ast_new_dunder_line(int $line) scalar {
    my scalar $node = ast_new_node(NODE_DUNDER_LINE());
    $node->{"line_value"} = $line;
    return $node;
}

# Create regex match node ($str =~ /pattern/ or $str !~ /pattern/)
func ast_new_regex_match(str $op, scalar $target, str $pattern, str $flags) scalar {
    my scalar $node = ast_new_node(NODE_REGEX_MATCH());
    $node->{"op"} = $op;           # "=~" or "!~"
    $node->{"target"} = $target;   # Expression being matched
    $node->{"pattern"} = $pattern;
    $node->{"flags"} = $flags;
    return $node;
}

# Create regex substitution node ($str =~ s/pattern/replacement/flags)
func ast_new_regex_subst(scalar $target, str $pattern, str $replacement, str $flags) scalar {
    my scalar $node = ast_new_node(NODE_REGEX_SUBST());
    $node->{"target"} = $target;   # Variable being modified
    $node->{"pattern"} = $pattern;
    $node->{"replacement"} = $replacement;
    $node->{"flags"} = $flags;
    return $node;
}

# Create try/catch node
func ast_new_try_catch(scalar $try_block, str $catch_var, scalar $catch_block) scalar {
    my scalar $node = ast_new_node(NODE_TRY_CATCH());
    $node->{"try_block"} = $try_block;
    $node->{"catch_var"} = $catch_var;     # Variable name for exception (e.g., "$e")
    $node->{"catch_block"} = $catch_block;
    return $node;
}

# Create throw node
func ast_new_throw(scalar $expr) scalar {
    my scalar $node = ast_new_node(NODE_THROW());
    $node->{"expr"} = $expr;
    return $node;
}

# Create a label node
func ast_new_label(str $name) scalar {
    my scalar $node = ast_new_node(NODE_LABEL());
    $node->{"name"} = $name;
    return $node;
}

# Create a goto node
func ast_new_goto(str $target) scalar {
    my scalar $node = ast_new_node(NODE_GOTO());
    $node->{"target"} = $target;
    return $node;
}

# Create anonymous function node
func ast_new_anon_func(int $return_type) scalar {
    my scalar $node = ast_new_node(NODE_ANON_FUNC());
    my array @params = ();
    my array @captures = ();
    $node->{"return_type"} = $return_type;
    $node->{"params"} = \@params;
    $node->{"param_count"} = 0;
    $node->{"body"} = 0;
    $node->{"captures"} = \@captures;
    $node->{"capture_count"} = 0;
    return $node;
}

# Create closure call node ($closure->(args))
func ast_new_closure_call(scalar $closure, scalar $args, int $arg_count) scalar {
    my scalar $node = ast_new_node(NODE_CLOSURE_CALL());
    $node->{"closure"} = $closure;
    $node->{"args"} = $args;
    $node->{"arg_count"} = $arg_count;
    return $node;
}

# Create ternary expression node ($cond ? $true_val : $false_val)
func ast_new_ternary(scalar $condition, scalar $true_expr, scalar $false_expr) scalar {
    my scalar $node = ast_new_node(NODE_TERNARY());
    $node->{"condition"} = $condition;
    $node->{"true_expr"} = $true_expr;
    $node->{"false_expr"} = $false_expr;
    return $node;
}

# Create switch statement node
func ast_new_switch(scalar $expr) scalar {
    my scalar $node = ast_new_node(NODE_SWITCH());
    my array @cases = ();
    my array @blocks = ();
    $node->{"expr"} = $expr;
    $node->{"cases"} = \@cases;
    $node->{"blocks"} = \@blocks;
    $node->{"case_count"} = 0;
    $node->{"default_block"} = 0;
    $node->{"has_default"} = 0;
    return $node;
}

# Add case to switch statement
func ast_add_case(scalar $switch_node, scalar $case_expr, scalar $block) void {
    my scalar $cases = $switch_node->{"cases"};
    my scalar $blocks = $switch_node->{"blocks"};
    push($cases, $case_expr);
    push($blocks, $block);
    $switch_node->{"case_count"} = $switch_node->{"case_count"} + 1;
}

# Create range expression node (start..end)
func ast_new_range(scalar $start, scalar $end) scalar {
    my scalar $node = ast_new_node(NODE_RANGE());
    $node->{"start"} = $start;
    $node->{"end"} = $end;
    return $node;
}

# ============================================================
# Utility functions
# ============================================================

# Get node type name for debugging
func ast_type_name(int $type) str {
    if ($type == NODE_PROGRAM()) { return "PROGRAM"; }
    if ($type == NODE_FUNC()) { return "FUNC"; }
    if ($type == NODE_PARAM()) { return "PARAM"; }
    if ($type == NODE_BLOCK()) { return "BLOCK"; }
    if ($type == NODE_VAR_DECL()) { return "VAR_DECL"; }
    if ($type == NODE_IF_STMT()) { return "IF_STMT"; }
    if ($type == NODE_WHILE_STMT()) { return "WHILE_STMT"; }
    if ($type == NODE_FOR_STMT()) { return "FOR_STMT"; }
    if ($type == NODE_FOREACH_STMT()) { return "FOREACH_STMT"; }
    if ($type == NODE_RETURN_STMT()) { return "RETURN_STMT"; }
    if ($type == NODE_EXPR_STMT()) { return "EXPR_STMT"; }
    if ($type == NODE_BINARY_OP()) { return "BINARY_OP"; }
    if ($type == NODE_UNARY_OP()) { return "UNARY_OP"; }
    if ($type == NODE_CALL()) { return "CALL"; }
    if ($type == NODE_VARIABLE()) { return "VARIABLE"; }
    if ($type == NODE_INT_LITERAL()) { return "INT_LITERAL"; }
    if ($type == NODE_NUM_LITERAL()) { return "NUM_LITERAL"; }
    if ($type == NODE_STR_LITERAL()) { return "STR_LITERAL"; }
    if ($type == NODE_ASSIGN()) { return "ASSIGN"; }
    if ($type == NODE_SUBSCRIPT()) { return "SUBSCRIPT"; }
    if ($type == NODE_HASH_ACCESS()) { return "HASH_ACCESS"; }
    if ($type == NODE_REF()) { return "REF"; }
    if ($type == NODE_DEREF_HASH()) { return "DEREF_HASH"; }
    if ($type == NODE_DEREF_ARRAY()) { return "DEREF_ARRAY"; }
    if ($type == NODE_DEREF_SCALAR()) { return "DEREF_SCALAR"; }
    if ($type == NODE_ANON_HASH()) { return "ANON_HASH"; }
    if ($type == NODE_ANON_ARRAY()) { return "ANON_ARRAY"; }
    if ($type == NODE_TRY_CATCH()) { return "TRY_CATCH"; }
    if ($type == NODE_THROW()) { return "THROW"; }
    if ($type == NODE_TERNARY()) { return "TERNARY"; }
    if ($type == NODE_SWITCH()) { return "SWITCH"; }
    return "UNKNOWN";
}

# Get type name for debugging
func ast_data_type_name(int $type) str {
    if ($type == TYPE_INT()) { return "int"; }
    if ($type == TYPE_NUM()) { return "num"; }
    if ($type == TYPE_STR()) { return "str"; }
    if ($type == TYPE_ARRAY()) { return "array"; }
    if ($type == TYPE_HASH()) { return "hash"; }
    if ($type == TYPE_SCALAR()) { return "scalar"; }
    if ($type == TYPE_VOID()) { return "void"; }
    if ($type == TYPE_INT32()) { return "int32"; }
    if ($type == TYPE_INT64()) { return "int64"; }
    if ($type == TYPE_FLOAT32()) { return "float32"; }
    if ($type == TYPE_FLOAT64()) { return "float64"; }
    return "unknown";
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# Strada/Lexer.strada - Strada Lexer written in Strada
# This file will be compiled by the bootstrap compiler to create a self-hosting compiler

func lex_new(str $source) scalar {
    my hash %lexer = ();
    $lexer{"source"} = $source;
    $lexer{"pos"} = 0;
    $lexer{"line"} = 1;
    $lexer{"column"} = 1;
    # Use bytes() not length() since char_at() works on byte positions
    $lexer{"length"} = bytes($source);
    $lexer{"expect_regex"} = 0;
    return \%lexer;
}

# Fast char code access - no string allocation
func lex_current_code(scalar $lexer) int {
    my int $pos = $lexer->{"pos"};
    my int $len = $lexer->{"length"};
    if ($pos >= $len) {
        return 0;
    }
    return char_at($lexer->{"source"}, $pos);
}

# Returns current char as string (for compatibility)
func lex_current_char(scalar $lexer) str {
    my int $code = lex_current_code($lexer);
    if ($code == 0) {
        return "";
    }
    return chr($code);
}

func lex_advance(scalar $lexer) void {
    my int $code = lex_current_code($lexer);

    if ($code == 10) {  # '\n'
        $lexer->{"line"} = $lexer->{"line"} + 1;
        $lexer->{"column"} = 1;
    } else {
        $lexer->{"column"} = $lexer->{"column"} + 1;
    }

    $lexer->{"pos"} = $lexer->{"pos"} + 1;
}

func lex_skip_whitespace(scalar $lexer) void {
    while (1) {
        my int $code = lex_current_code($lexer);

        if ($code == 0) {
            return;
        }

        # Space=32, Tab=9, LF=10, CR=13
        if ($code == 32 || $code == 9 || $code == 10 || $code == 13) {
            lex_advance($lexer);
        } else {
            return;
        }
    }
}

func lex_skip_comment(scalar $lexer) void {
    my int $code = lex_current_code($lexer);

    if ($code != 35) {  # '#'
        return;
    }

    # Skip until end of line
    while (1) {
        lex_advance($lexer);
        $code = lex_current_code($lexer);

        if ($code == 0 || $code == 10) {  # EOF or '\n'
            return;
        }
    }
}

func lex_skip_block_comment(scalar $lexer) void {
    # Skip the opening /*
    lex_advance($lexer);
    lex_advance($lexer);

    # Skip until we find */
    while (1) {
        my int $code = lex_current_code($lexer);

        if ($code == 0) {
            die("Unterminated block comment");
        }

        # Check for */  ('*'=42, '/'=47)
        if ($code == 42) {
            my int $next_code = char_at($lexer->{"source"}, $lexer->{"pos"} + 1);
            if ($next_code == 47) {
                lex_advance($lexer);
                lex_advance($lexer);
                return;
            }
        }

        lex_advance($lexer);
    }
}

# Helper to check if char code is alphanumeric or underscore
func lex_is_ident_char(int $code) int {
    # a-z: 97-122, A-Z: 65-90, 0-9: 48-57, _: 95
    if ($code >= 97 && $code <= 122) { return 1; }
    if ($code >= 65 && $code <= 90) { return 1; }
    if ($code >= 48 && $code <= 57) { return 1; }
    if ($code == 95) { return 1; }
    return 0;
}

func lex_read_identifier(scalar $lexer) str {
    my scalar $sb = sb_new();

    while (1) {
        my int $code = lex_current_code($lexer);

        if ($code == 0) {
            return sb_to_string($sb);
        }

        if (lex_is_ident_char($code) == 1) {
            sb_append($sb, chr($code));
            lex_advance($lexer);
        } else {
            return sb_to_string($sb);
        }
    }
}

func lex_is_hex_digit_code(int $code) int {
    # 0-9: 48-57, a-f: 97-102, A-F: 65-70
    if ($code >= 48 && $code <= 57) { return 1; }
    if ($code >= 97 && $code <= 102) { return 1; }
    if ($code >= 65 && $code <= 70) { return 1; }
    return 0;
}

func lex_read_number(scalar $lexer) scalar {
    my scalar $sb = sb_new();
    my int $is_float = 0;
    my int $is_hex = 0;
    my int $token_line = $lexer->{"line"};

    # Check for hex prefix 0x or 0X
    my int $first_code = lex_current_code($lexer);
    if ($first_code == 48) {  # '0'
        sb_append($sb, chr($first_code));
        lex_advance($lexer);
        my int $second_code = lex_current_code($lexer);
        if ($second_code == 120 || $second_code == 88) {  # 'x' or 'X'
            $is_hex = 1;
            sb_append($sb, chr($second_code));
            lex_advance($lexer);
        }
    }

    while (1) {
        my int $code = lex_current_code($lexer);

        if ($code == 0) {
            my hash %token = ();
            if ($is_float) {
                $token{"type"} = "NUM_LITERAL";
            } else {
                $token{"type"} = "INT_LITERAL";
            }
            $token{"value"} = sb_to_string($sb);
            return \%token;
        }

        if ($is_hex) {
            if (lex_is_hex_digit_code($code)) {
                sb_append($sb, chr($code));
                lex_advance($lexer);
            } else {
                my hash %token = ();
                $token{"type"} = "INT_LITERAL";
                $token{"value"} = sb_to_string($sb);
                return \%token;
            }
        } else {
            # 0-9: 48-57
            if ($code >= 48 && $code <= 57) {
                sb_append($sb, chr($code));
                lex_advance($lexer);
            } elsif ($code == 46 && $is_float == 0) {  # '.'
                # Check for range operator before consuming dot
                my int $next_code = char_at($lexer->{"source"}, $lexer->{"pos"} + 1);
                if ($next_code == 46) {  # '..'
                    my hash %token = ();
                    $token{"type"} = "INT_LITERAL";
                    $token{"value"} = sb_to_string($sb);
                    $token{"line"} = $token_line;
                    return \%token;
                }
                $is_float = 1;
                sb_append($sb, chr($code));
                lex_advance($lexer);
            } else {
                my hash %token = ();
                if ($is_float) {
                    $token{"type"} = "NUM_LITERAL";
                } else {
                    $token{"type"} = "INT_LITERAL";
                }
                $token{"value"} = sb_to_string($sb);
                return \%token;
            }
        }
    }
}

# Read a single-quoted string (no interpolation) - optimized with char codes
func lex_read_sq_string(scalar $lexer) str {
    lex_advance($lexer); # Skip opening quote
    my scalar $sb = sb_new();
    my str $source = $lexer->{"source"};

    while (1) {
        my int $code = lex_current_code($lexer);
        my int $pos = $lexer->{"pos"};

        if ($code == 0) {
            die("Unterminated string");
        }

        # 39 = single quote
        if ($code == 39) {
            lex_advance($lexer); # Skip closing quote
            return sb_to_string($sb);
        }

        # 92 = backslash
        if ($code == 92) {
            lex_advance($lexer);
            my int $next_code = lex_current_code($lexer);
            my int $next_pos = $lexer->{"pos"};
            # 39 = ', 92 = \
            if ($next_code == 39 || $next_code == 92) {
                sb_append($sb, substr_bytes($source, $next_pos, 1));
            } else {
                # In single quotes, backslash is literal except for \' and \\
                sb_append($sb, "\\");
                sb_append($sb, substr_bytes($source, $next_pos, 1));
            }
            lex_advance($lexer);
        } else {
            # Use substr_bytes for byte-level extraction
            sb_append($sb, substr_bytes($source, $pos, 1));
            lex_advance($lexer);
        }
    }
}

# Read a double-quoted string (with interpolation support) - optimized with char codes
func lex_read_dq_string(scalar $lexer, int $token_line) scalar {
    lex_advance($lexer); # Skip opening quote

    my scalar $sb = sb_new();  # StringBuilder for current part
    my str $source = $lexer->{"source"};
    my array @parts = ();
    my array @vars = ();
    my int $has_interp = 0;
    my int $var_count = 0;

    while (1) {
        my int $code = lex_current_code($lexer);
        my int $pos = $lexer->{"pos"};

        if ($code == 0) {
            die("Unterminated string");
        }

        # 34 = double quote
        if ($code == 34) {
            lex_advance($lexer); # Skip closing quote

            if ($has_interp) {
                # Return interpolated string token
                push(\@parts, sb_to_string($sb));
                my hash %token = ();
                $token{"type"} = "INTERP_STRING";
                $token{"parts"} = \@parts;
                $token{"vars"} = \@vars;
                $token{"var_count"} = $var_count;
                $token{"line"} = $token_line;
                return \%token;
            } else {
                # Return regular string token
                my hash %token = ();
                $token{"type"} = "STR_LITERAL";
                $token{"value"} = sb_to_string($sb);
                $token{"line"} = $token_line;
                return \%token;
            }
        }

        # 92 = backslash
        if ($code == 92) {
            lex_advance($lexer);
            my int $next_code = lex_current_code($lexer);
            my int $next_pos = $lexer->{"pos"};

            # n=110, t=116, r=114, 0=48, a=97, b=98, f=102, v=118, e=101, \=92, "=34, $=36
            if ($next_code == 110) {
                sb_append($sb, "\n");
            } elsif ($next_code == 116) {
                sb_append($sb, "\t");
            } elsif ($next_code == 114) {
                sb_append($sb, "\r");
            } elsif ($next_code == 48) {
                sb_append($sb, chr(0));
            } elsif ($next_code == 97) {
                sb_append($sb, chr(7));
            } elsif ($next_code == 98) {
                sb_append($sb, chr(8));
            } elsif ($next_code == 102) {
                sb_append($sb, chr(12));
            } elsif ($next_code == 118) {
                sb_append($sb, chr(11));
            } elsif ($next_code == 101) {
                sb_append($sb, chr(27));
            } elsif ($next_code == 92) {
                sb_append($sb, "\\");
            } elsif ($next_code == 34) {
                sb_append($sb, "\"");
            } elsif ($next_code == 36) {
                # Escaped dollar sign - literal $
                sb_append($sb, "$");
            } else {
                # Use substr_bytes for byte-level extraction
                sb_append($sb, substr_bytes($source, $next_pos, 1));
            }
            lex_advance($lexer);
        } elsif ($code == 36) {
            # 36 = $ - Check for interpolation ${varname}
            lex_advance($lexer);
            my int $peek_code = lex_current_code($lexer);

            # 123 = {
            if ($peek_code == 123) {
                lex_advance($lexer); # Skip {
                my scalar $ivar_sb = sb_new();

                while (1) {
                    my int $vc = lex_current_code($lexer);
                    if ($vc == 0) {
                        die("Unterminated interpolation in string");
                    }
                    # 125 = }
                    if ($vc == 125) {
                        lex_advance($lexer); # Skip }

                        my str $ivar = sb_to_string($ivar_sb);
                        if (length($ivar) == 0) {
                            die("Empty variable name in interpolation");
                        }

                        # Save current part and variable
                        push(\@parts, sb_to_string($sb));
                        push(\@vars, $ivar);
                        $var_count = $var_count + 1;
                        $sb = sb_new();  # Reset StringBuilder
                        $has_interp = 1;
                        break;
                    }
                    # Variable names are ASCII, so chr() is safe here
                    sb_append($ivar_sb, chr($vc));
                    lex_advance($lexer);
                }
            } else {
                # Just a literal $ not followed by {
                sb_append($sb, "$");
            }
        } else {
            # Use substr_bytes for byte-level extraction
            sb_append($sb, substr_bytes($source, $pos, 1));
            lex_advance($lexer);
        }
    }
}

# Legacy function for compatibility
func lex_read_string(scalar $lexer) str {
    my str $quote = lex_current_char($lexer);
    lex_advance($lexer); # Skip opening quote

    my str $result = "";

    while (1) {
        my str $ch = lex_current_char($lexer);

        if ($ch eq "") {
            die("Unterminated string");
        }

        if ($ch eq $quote) {
            lex_advance($lexer); # Skip closing quote
            return $result;
        }

        if ($ch eq "\\") {
            lex_advance($lexer);
            my str $nextch = lex_current_char($lexer);

            if ($nextch eq "n") {
                $result = $result . "\n";
            } elsif ($nextch eq "t") {
                $result = $result . "\t";
            } elsif ($nextch eq "r") {
                $result = $result . "\r";
            } elsif ($nextch eq "0") {
                # Null character
                $result = $result . chr(0);
            } elsif ($nextch eq "a") {
                # Bell/alert
                $result = $result . chr(7);
            } elsif ($nextch eq "b") {
                # Backspace
                $result = $result . chr(8);
            } elsif ($nextch eq "f") {
                # Form feed
                $result = $result . chr(12);
            } elsif ($nextch eq "v") {
                # Vertical tab
                $result = $result . chr(11);
            } elsif ($nextch eq "e") {
                # Escape character
                $result = $result . chr(27);
            } elsif ($nextch eq "\\") {
                $result = $result . "\\";
            } elsif ($nextch eq $quote) {
                $result = $result . $quote;
            } else {
                # Unknown escape - just include the character as-is
                $result = $result . $nextch;
            }

            lex_advance($lexer);
        } else {
            $result = $result . $ch;
            lex_advance($lexer);
        }
    }
}

func lex_at_end(scalar $lexer) int {
    if ($lexer->{"pos"} >= $lexer->{"length"}) {
        return 1;
    }
    return 0;
}

func lex_current(scalar $lexer) str {
    return lex_current_char($lexer);
}

func lex_peek_char(scalar $lexer, int $offset) str {
    my int $pos = $lexer->{"pos"} + $offset;
    if ($pos >= $lexer->{"length"}) {
        return "";
    }
    return substr($lexer->{"source"}, $pos, 1);
}

func lex_read_regex_literal(scalar $lexer, int $token_line) scalar {
    lex_advance($lexer);  # Skip opening /
    my scalar $sb = sb_new();

    while (!lex_at_end($lexer)) {
        my int $code = lex_current_code($lexer);
        # 47 = /
        if ($code == 47) {
            lex_advance($lexer);
            # Read optional flags
            my scalar $flags_sb = sb_new();
            while (!lex_at_end($lexer)) {
                my int $f = lex_current_code($lexer);
                # g=103, i=105, m=109, s=115, x=120
                if ($f == 103 || $f == 105 || $f == 109 || $f == 115 || $f == 120) {
                    sb_append($flags_sb, chr($f));
                    lex_advance($lexer);
                } else {
                    last;
                }
            }
            my hash %token = ();
            $token{"type"} = "REGEX_LITERAL";
            $token{"pattern"} = sb_to_string($sb);
            $token{"flags"} = sb_to_string($flags_sb);
            $token{"line"} = $token_line;
            return \%token;
        }
        # 92 = backslash
        if ($code == 92) {
            lex_advance($lexer);
            if (!lex_at_end($lexer)) {
                my int $escaped = lex_current_code($lexer);
                # /=47, n=110, t=116, r=114, \=92
                if ($escaped == 47) {
                    # Escaped slash - just add the slash
                    sb_append($sb, "/");
                } elsif ($escaped == 110) {
                    sb_append($sb, "\n");
                } elsif ($escaped == 116) {
                    sb_append($sb, "\t");
                } elsif ($escaped == 114) {
                    sb_append($sb, "\r");
                } elsif ($escaped == 92) {
                    sb_append($sb, "\\");
                } else {
                    # Keep the backslash and next char for regex escapes (e.g., \d, \w, \s)
                    sb_append($sb, "\\");
                    sb_append($sb, chr($escaped));
                }
                lex_advance($lexer);
            }
        } else {
            sb_append($sb, chr($code));
            lex_advance($lexer);
        }
    }
    die("Unterminated regex literal at line " . $token_line);
}

func lex_read_subst_literal(scalar $lexer, int $token_line) scalar {
    lex_advance($lexer);  # Skip 's'
    lex_advance($lexer);  # Skip opening /

    # Read pattern
    my scalar $pattern_sb = sb_new();
    while (!lex_at_end($lexer)) {
        my int $code = lex_current_code($lexer);
        # 47 = /
        if ($code == 47) {
            lex_advance($lexer);
            last;
        }
        # 92 = backslash
        if ($code == 92) {
            lex_advance($lexer);
            if (!lex_at_end($lexer)) {
                my int $escaped = lex_current_code($lexer);
                # /=47, n=110, t=116, r=114, \=92
                if ($escaped == 47) {
                    sb_append($pattern_sb, "/");
                } elsif ($escaped == 110) {
                    sb_append($pattern_sb, "\n");
                } elsif ($escaped == 116) {
                    sb_append($pattern_sb, "\t");
                } elsif ($escaped == 114) {
                    sb_append($pattern_sb, "\r");
                } elsif ($escaped == 92) {
                    sb_append($pattern_sb, "\\");
                } else {
                    # Keep other escapes as-is for regex engine (e.g., \d, \w, \s)
                    sb_append($pattern_sb, "\\");
                    sb_append($pattern_sb, chr($escaped));
                }
                lex_advance($lexer);
            }
        } else {
            sb_append($pattern_sb, chr($code));
            lex_advance($lexer);
        }
    }

    # Read replacement
    my scalar $repl_sb = sb_new();
    while (!lex_at_end($lexer)) {
        my int $code = lex_current_code($lexer);
        # 47 = /
        if ($code == 47) {
            lex_advance($lexer);
            last;
        }
        # 92 = backslash
        if ($code == 92) {
            lex_advance($lexer);
            if (!lex_at_end($lexer)) {
                my int $escaped = lex_current_code($lexer);
                # /=47, n=110, t=116, r=114, \=92
                if ($escaped == 47) {
                    sb_append($repl_sb, "/");
                } elsif ($escaped == 110) {
                    sb_append($repl_sb, "\n");
                } elsif ($escaped == 116) {
                    sb_append($repl_sb, "\t");
                } elsif ($escaped == 114) {
                    sb_append($repl_sb, "\r");
                } elsif ($escaped == 92) {
                    sb_append($repl_sb, "\\");
                } else {
                    sb_append($repl_sb, "\\");
                    sb_append($repl_sb, chr($escaped));
                }
                lex_advance($lexer);
            }
        } else {
            sb_append($repl_sb, chr($code));
            lex_advance($lexer);
        }
    }

    # Read flags
    my scalar $flags_sb = sb_new();
    while (!lex_at_end($lexer)) {
        my int $f = lex_current_code($lexer);
        # g=103, i=105, m=109, s=115, x=120
        if ($f == 103 || $f == 105 || $f == 109 || $f == 115 || $f == 120) {
            sb_append($flags_sb, chr($f));
            lex_advance($lexer);
        } else {
            last;
        }
    }

    my hash %token = ();
    $token{"type"} = "SUBST_LITERAL";
    $token{"pattern"} = sb_to_string($pattern_sb);
    $token{"replacement"} = sb_to_string($repl_sb);
    $token{"flags"} = sb_to_string($flags_sb);
    $token{"line"} = $token_line;
    return \%token;
}

# Get matching close delimiter for open delimiter
func lex_get_close_delim(str $open) str {
    if ($open eq "(") { return ")"; }
    if ($open eq "[") { return "]"; }
    if ($open eq "{") { return "}"; }
    if ($open eq "<") { return ">"; }
    # For other delimiters, close is same as open
    return $open;
}

# Read qw() - quote words, returns array of words
func lex_read_qw(scalar $lexer, int $token_line) scalar {
    # Current position should be at the delimiter after 'qw'
    my str $open = lex_current_char($lexer);
    my str $close = lex_get_close_delim($open);
    lex_advance($lexer);  # Skip open delimiter

    my array @words = ();
    my str $word = "";
    my int $count = 0;

    while (!lex_at_end($lexer)) {
        my str $ch = lex_current_char($lexer);

        if ($ch eq $close) {
            # End of qw - save last word if any
            if (length($word) > 0) {
                push(@words, $word);
                $count = $count + 1;
            }
            lex_advance($lexer);  # Skip close delimiter

            my hash %token = ();
            $token{"type"} = "QW_LITERAL";
            $token{"words"} = \@words;
            $token{"word_count"} = $count;
            $token{"line"} = $token_line;
            return \%token;
        }

        if ($ch eq " " || $ch eq "\t" || $ch eq "\n" || $ch eq "\r") {
            # Whitespace - save current word if any
            if (length($word) > 0) {
                push(@words, $word);
                $count = $count + 1;
                $word = "";
            }
            lex_advance($lexer);
        } else {
            # Regular character - add to current word
            $word = $word . $ch;
            lex_advance($lexer);
        }
    }

    die("Unterminated qw() at line " . $token_line);
}

# Read q() or qq() - single/double quoted string with custom delimiters
# is_qq: 1 for qq() (supports escape sequences like \n, \t), 0 for q() (literal)
func lex_read_q_string(scalar $lexer, int $token_line, int $is_qq) scalar {
    my str $open = lex_current_char($lexer);
    my str $close = lex_get_close_delim($open);
    lex_advance($lexer);  # Skip open delimiter

    my str $result = "";
    my int $depth = 1;  # For nested delimiters like q(a(b)c)
    my int $handled = 0;

    while (!lex_at_end($lexer)) {
        my str $ch = lex_current_char($lexer);
        $handled = 0;

        # Check for closing delimiter
        if ($ch eq $close) {
            $depth = $depth - 1;
            if ($depth == 0) {
                lex_advance($lexer);
                my hash %token = ();
                $token{"type"} = "STR_LITERAL";
                $token{"value"} = $result;
                $token{"line"} = $token_line;
                return \%token;
            }
            $result = $result . $ch;
            lex_advance($lexer);
            $handled = 1;
        }

        # Check for nested opening delimiter (paired delimiters only)
        if ($handled == 0 && $open ne $close && $ch eq $open) {
            $depth = $depth + 1;
            $result = $result . $ch;
            lex_advance($lexer);
            $handled = 1;
        }

        # Check for escape sequence
        if ($handled == 0 && $ch eq "\\") {
            lex_advance($lexer);
            my str $esc = lex_current_char($lexer);

            if ($is_qq) {
                # qq() supports full escape sequences like double-quoted strings
                if ($esc eq "n") {
                    $result = $result . "\n";
                } elsif ($esc eq "t") {
                    $result = $result . "\t";
                } elsif ($esc eq "r") {
                    $result = $result . "\r";
                } elsif ($esc eq "0") {
                    $result = $result . chr(0);
                } elsif ($esc eq "a") {
                    $result = $result . chr(7);
                } elsif ($esc eq "b") {
                    $result = $result . chr(8);
                } elsif ($esc eq "f") {
                    $result = $result . chr(12);
                } elsif ($esc eq "v") {
                    $result = $result . chr(11);
                } elsif ($esc eq "e") {
                    $result = $result . chr(27);
                } elsif ($esc eq "\\" || $esc eq $close) {
                    $result = $result . $esc;
                } else {
                    # Unknown escape - include as-is
                    $result = $result . $esc;
                }
            } else {
                # q() only escapes \\ and the delimiter
                if ($esc eq $close || $esc eq "\\") {
                    $result = $result . $esc;
                } else {
                    $result = $result . "\\" . $esc;
                }
            }
            lex_advance($lexer);
            $handled = 1;
        }

        # Regular character
        if ($handled == 0) {
            $result = $result . $ch;
            lex_advance($lexer);
        }
    }

    die("Unterminated q/qq string at line " . $token_line);
}

func lex_keyword_or_ident(str $text) str {
    if ($text eq "func") { return "FUNC"; }
    if ($text eq "my") { return "MY"; }
    if ($text eq "if") { return "IF"; }
    if ($text eq "elsif") { return "ELSIF"; }
    if ($text eq "else") { return "ELSE"; }
    if ($text eq "while") { return "WHILE"; }
    if ($text eq "for") { return "FOR"; }
    if ($text eq "foreach") { return "FOREACH"; }
    if ($text eq "return") { return "RETURN"; }
    if ($text eq "last") { return "LAST"; }
    if ($text eq "next") { return "NEXT"; }
    if ($text eq "extern") { return "EXTERN"; }
    if ($text eq "struct") { return "STRUCT"; }
    if ($text eq "package") { return "PACKAGE"; }
    if ($text eq "version") { return "VERSION"; }
    if ($text eq "use") { return "USE"; }
    if ($text eq "import_lib") { return "IMPORT_LIB"; }
    if ($text eq "inherit") { return "INHERIT"; }
    if ($text eq "try") { return "TRY"; }
    if ($text eq "catch") { return "CATCH"; }
    if ($text eq "throw") { return "THROW"; }
    if ($text eq "goto") { return "GOTO"; }
    if ($text eq "switch") { return "SWITCH"; }
    if ($text eq "case") { return "CASE"; }
    if ($text eq "default") { return "DEFAULT"; }
    if ($text eq "__PACKAGE__") { return "DUNDER_PACKAGE"; }
    if ($text eq "__FILE__") { return "DUNDER_FILE"; }
    if ($text eq "__LINE__") { return "DUNDER_LINE"; }

    # String comparison operators
    if ($text eq "eq") { return "STR_EQ"; }
    if ($text eq "ne") { return "STR_NE"; }
    if ($text eq "lt") { return "STR_LT"; }
    if ($text eq "gt") { return "STR_GT"; }
    if ($text eq "le") { return "STR_LE"; }
    if ($text eq "ge") { return "STR_GE"; }
    
    # Types
    if ($text eq "int") { return "TYPE_INT"; }
    if ($text eq "num") { return "TYPE_NUM"; }
    if ($text eq "str") { return "TYPE_STR"; }
    if ($text eq "array") { return "TYPE_ARRAY"; }
    if ($text eq "hash") { return "TYPE_HASH"; }
    if ($text eq "scalar") { return "TYPE_SCALAR"; }
    if ($text eq "void") { return "TYPE_VOID"; }
    # Explicit sized types for extern functions (C interop)
    if ($text eq "int32") { return "TYPE_INT32"; }
    if ($text eq "int64") { return "TYPE_INT64"; }
    if ($text eq "float32") { return "TYPE_FLOAT32"; }
    if ($text eq "float64") { return "TYPE_FLOAT64"; }
    
    # Built-ins that need special token types
    # undef is a keyword, not a function call
    if ($text eq "undef") { return "UNDEF"; }
    if ($text eq "map") { return "MAP"; }
    if ($text eq "sort") { return "SORT"; }
    if ($text eq "grep") { return "GREP"; }
    # if ($text eq "defined") { return "DEFINED"; }
    # if ($text eq "ref") { return "REF"; }
    # if ($text eq "dump") { return "DUMP"; }
    # if ($text eq "dumper") { return "DUMPER"; }
    # if ($text eq "say") { return "SAY"; }
    # if ($text eq "print") { return "PRINT"; }
    # if ($text eq "die") { return "DIE"; }
    # if ($text eq "push") { return "PUSH"; }
    # if ($text eq "pop") { return "POP"; }
    # if ($text eq "shift") { return "SHIFT"; }
    # if ($text eq "unshift") { return "UNSHIFT"; }
    # if ($text eq "scalar") { return "SCALAR"; }
    # if ($text eq "length") { return "LENGTH"; }
    # if ($text eq "substr") { return "SUBSTR"; }
    
    return "IDENT";
}

func lex_next_token(scalar $lexer) scalar {
    lex_skip_whitespace($lexer);

    my int $code = lex_current_code($lexer);

    # Capture line number at token start (after whitespace)
    my int $token_line = $lexer->{"line"};

    # Check for EOF (code == 0)
    if ($code == 0) {
        my hash %token = ();
        $token{"type"} = "EOF";
        $token{"value"} = "";
        $token{"line"} = $token_line;
        return \%token;
    }

    # Skip line comments (#=35)
    if ($code == 35) {
        lex_skip_comment($lexer);
        return lex_next_token($lexer);
    }

    # Skip block comments (/* ... */)  /=47, *=42
    if ($code == 47) {
        my int $next_code = char_at($lexer->{"source"}, $lexer->{"pos"} + 1);
        if ($next_code == 42) {
            lex_skip_block_comment($lexer);
            return lex_next_token($lexer);
        }
    }

    # Check for regex/substitution after =~ or !~ BEFORE identifier check
    if ($lexer->{"expect_regex"} == 1) {
        # /=47
        if ($code == 47) {
            $lexer->{"expect_regex"} = 0;
            return lex_read_regex_literal($lexer, $token_line);
        }
        # s=115
        if ($code == 115) {
            my int $peek_code = char_at($lexer->{"source"}, $lexer->{"pos"} + 1);
            # /=47
            if ($peek_code == 47) {
                $lexer->{"expect_regex"} = 0;
                return lex_read_subst_literal($lexer, $token_line);
            }
        }
        # Not a regex/subst - reset flag and continue with normal parsing
        $lexer->{"expect_regex"} = 0;
    }

    # Identifiers and keywords: a-z=97-122, A-Z=65-90, _=95
    if (($code >= 97 && $code <= 122) || ($code >= 65 && $code <= 90) || $code == 95) {
        my str $text = lex_read_identifier($lexer);

        # Check for quote-like operators: qw(), q(), qq()
        if ($text eq "qw") {
            lex_skip_whitespace($lexer);
            my int $delim = lex_current_code($lexer);
            # (=40, [=91, {=123, <=60, /=47, !=33, |=124
            if ($delim == 40 || $delim == 91 || $delim == 123 || $delim == 60 || $delim == 47 || $delim == 33 || $delim == 124) {
                return lex_read_qw($lexer, $token_line);
            }
        }

        if ($text eq "q") {
            lex_skip_whitespace($lexer);
            my int $delim = lex_current_code($lexer);
            if ($delim == 40 || $delim == 91 || $delim == 123 || $delim == 60 || $delim == 47 || $delim == 33 || $delim == 124) {
                return lex_read_q_string($lexer, $token_line, 0);
            }
        }

        if ($text eq "qq") {
            lex_skip_whitespace($lexer);
            my int $delim = lex_current_code($lexer);
            if ($delim == 40 || $delim == 91 || $delim == 123 || $delim == 60 || $delim == 47 || $delim == 33 || $delim == 124) {
                return lex_read_q_string($lexer, $token_line, 1);
            }
        }

        my str $type = lex_keyword_or_ident($text);

        my hash %token = ();
        $token{"type"} = $type;
        $token{"value"} = $text;
        $token{"line"} = $token_line;
        return \%token;
    }

    # Numbers: 0-9=48-57
    if ($code >= 48 && $code <= 57) {
        my scalar $tok = lex_read_number($lexer);
        $tok->{"line"} = $token_line;
        return $tok;
    }

    # Strings: "=34, '=39
    if ($code == 34) {
        # Double-quoted string with interpolation support
        return lex_read_dq_string($lexer, $token_line);
    }

    if ($code == 39) {
        # Single-quoted string (literal, no interpolation)
        my str $str_val = lex_read_sq_string($lexer);
        my hash %token = ();
        $token{"type"} = "STR_LITERAL";
        $token{"value"} = $str_val;
        $token{"line"} = $token_line;
        return \%token;
    }

    # Two-character operators - use char codes for fast comparison
    # Get second character code for two-char operator detection
    my str $source = $lexer->{"source"};
    my int $pos = $lexer->{"pos"};
    my int $code2 = char_at($source, $pos + 1);

    # ASCII codes: ==61, !=33, <=60, >=62, &&38, ||124, <<60, >>62
    # ::58, ->45>62, =>61>62, +=43=61, -=45=61, ++=43=43, --=45=45
    # .==46=61, =~=61~126, !~=33~126, ...=46, ..=46

    # ==  (=61, =61)
    if ($code == 61 && $code2 == 61) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "EQ";
        $token{"value"} = "==";
        $token{"line"} = $token_line;
        return \%token;
    }

    # !=  (!33, =61)
    if ($code == 33 && $code2 == 61) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "NE";
        $token{"value"} = "!=";
        $token{"line"} = $token_line;
        return \%token;
    }

    # Check for <=> (spaceship) before <= (<60, =61, >62)
    if ($code == 60 && $code2 == 61) {
        my int $code3 = char_at($source, $pos + 2);
        if ($code3 == 62) {
            lex_advance($lexer);
            lex_advance($lexer);
            lex_advance($lexer);
            my hash %token = ();
            $token{"type"} = "SPACESHIP";
            $token{"value"} = "<=>";
            $token{"line"} = $token_line;
            return \%token;
        }
        # Just <=
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "LE";
        $token{"value"} = "<=";
        $token{"line"} = $token_line;
        return \%token;
    }

    # >=  (>62, =61)
    if ($code == 62 && $code2 == 61) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "GE";
        $token{"value"} = ">=";
        $token{"line"} = $token_line;
        return \%token;
    }

    # &&  (&38, &38)
    if ($code == 38 && $code2 == 38) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "AND";
        $token{"value"} = "&&";
        $token{"line"} = $token_line;
        return \%token;
    }

    # ||  (|124, |124)
    if ($code == 124 && $code2 == 124) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "OR";
        $token{"value"} = "||";
        $token{"line"} = $token_line;
        return \%token;
    }

    # <<  (<60, <60)
    if ($code == 60 && $code2 == 60) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "LSHIFT";
        $token{"value"} = "<<";
        $token{"line"} = $token_line;
        return \%token;
    }

    # >>  (>62, >62)
    if ($code == 62 && $code2 == 62) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "RSHIFT";
        $token{"value"} = ">>";
        $token{"line"} = $token_line;
        return \%token;
    }

    # ::  (:58, :58)
    if ($code == 58 && $code2 == 58) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "DOUBLE_COLON";
        $token{"value"} = "::";
        $token{"line"} = $token_line;
        return \%token;
    }

    # ->  (-45, >62)
    if ($code == 45 && $code2 == 62) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "ARROW";
        $token{"value"} = "->";
        $token{"line"} = $token_line;
        return \%token;
    }

    # =>  (=61, >62)
    if ($code == 61 && $code2 == 62) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "FAT_ARROW";
        $token{"value"} = "=>";
        $token{"line"} = $token_line;
        return \%token;
    }

    # +=  (+43, =61)
    if ($code == 43 && $code2 == 61) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "PLUS_ASSIGN";
        $token{"value"} = "+=";
        $token{"line"} = $token_line;
        return \%token;
    }

    # -=  (-45, =61)
    if ($code == 45 && $code2 == 61) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "MINUS_ASSIGN";
        $token{"value"} = "-=";
        $token{"line"} = $token_line;
        return \%token;
    }

    # ++  (+43, +43)
    if ($code == 43 && $code2 == 43) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "PLUSPLUS";
        $token{"value"} = "++";
        $token{"line"} = $token_line;
        return \%token;
    }

    # --  (-45, -45)
    if ($code == 45 && $code2 == 45) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "MINUSMINUS";
        $token{"value"} = "--";
        $token{"line"} = $token_line;
        return \%token;
    }

    # **  (*42, *42) - exponentiation
    if ($code == 42 && $code2 == 42) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "POWER";
        $token{"value"} = "**";
        $token{"line"} = $token_line;
        return \%token;
    }

    # .=  (.46, =61)
    if ($code == 46 && $code2 == 61) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "DOT_ASSIGN";
        $token{"value"} = ".=";
        $token{"line"} = $token_line;
        return \%token;
    }

    # =~  (=61, ~126)
    if ($code == 61 && $code2 == 126) {
        lex_advance($lexer);
        lex_advance($lexer);
        $lexer->{"expect_regex"} = 1;
        my hash %token = ();
        $token{"type"} = "MATCH_OP";
        $token{"value"} = "=~";
        $token{"line"} = $token_line;
        return \%token;
    }

    # !~  (!33, ~126)
    if ($code == 33 && $code2 == 126) {
        lex_advance($lexer);
        lex_advance($lexer);
        $lexer->{"expect_regex"} = 1;
        my hash %token = ();
        $token{"type"} = "NOT_MATCH_OP";
        $token{"value"} = "!~";
        $token{"line"} = $token_line;
        return \%token;
    }

    # ... (ellipsis) and .. (range) - .=46
    if ($code == 46 && $code2 == 46) {
        my int $code3 = char_at($source, $pos + 2);
        if ($code3 == 46) {
            lex_advance($lexer);
            lex_advance($lexer);
            lex_advance($lexer);
            my hash %token = ();
            $token{"type"} = "ELLIPSIS";
            $token{"value"} = "...";
            $token{"line"} = $token_line;
            return \%token;
        }
        # Just ..
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "RANGE";
        $token{"value"} = "..";
        $token{"line"} = $token_line;
        return \%token;
    }

    # Single-character tokens - use integer comparisons
    lex_advance($lexer);

    my hash %token = ();
    $token{"value"} = chr($code);
    $token{"line"} = $token_line;

    # (=40, )=41, {=123, }=125, [=91, ]=93, ;=59, ,=44, :=58
    # $=36, @=64, %=37, +=43, -=45, *=42, /=47, .=46, ==61
    # <=60, >=62, !=33, \=92, &=38, |=124, ^=94, ~=126, ?=63
    if ($code == 40) { $token{"type"} = "LPAREN"; return \%token; }
    if ($code == 41) { $token{"type"} = "RPAREN"; return \%token; }
    if ($code == 123) { $token{"type"} = "LBRACE"; return \%token; }
    if ($code == 125) { $token{"type"} = "RBRACE"; return \%token; }
    if ($code == 91) { $token{"type"} = "LBRACKET"; return \%token; }
    if ($code == 93) { $token{"type"} = "RBRACKET"; return \%token; }
    if ($code == 59) { $token{"type"} = "SEMI"; return \%token; }
    if ($code == 44) { $token{"type"} = "COMMA"; return \%token; }
    if ($code == 58) { $token{"type"} = "COLON"; return \%token; }
    if ($code == 36) { $token{"type"} = "DOLLAR"; return \%token; }
    if ($code == 64) { $token{"type"} = "AT"; return \%token; }
    if ($code == 37) { $token{"type"} = "PERCENT"; return \%token; }
    if ($code == 43) { $token{"type"} = "PLUS"; return \%token; }
    if ($code == 45) { $token{"type"} = "MINUS"; return \%token; }
    if ($code == 42) { $token{"type"} = "MULT"; return \%token; }
    if ($code == 47) { $token{"type"} = "DIV"; return \%token; }
    if ($code == 46) { $token{"type"} = "DOT"; return \%token; }
    if ($code == 61) { $token{"type"} = "ASSIGN"; return \%token; }
    if ($code == 60) { $token{"type"} = "LT"; return \%token; }
    if ($code == 62) { $token{"type"} = "GT"; return \%token; }
    if ($code == 33) { $token{"type"} = "NOT"; return \%token; }
    if ($code == 92) { $token{"type"} = "BACKSLASH"; return \%token; }
    if ($code == 38) { $token{"type"} = "AMPERSAND"; return \%token; }
    if ($code == 124) { $token{"type"} = "PIPE"; return \%token; }
    if ($code == 94) { $token{"type"} = "CARET"; return \%token; }
    if ($code == 126) { $token{"type"} = "TILDE"; return \%token; }
    if ($code == 63) { $token{"type"} = "QUESTION"; return \%token; }

    die("Unexpected character: " . chr($code) . " at line " . $token_line);
}

func lex_tokenize(str $source) array {
    my hash $lexer = lex_new($source);
    my array @tokens = ();
    my str $prev_type = "";

    while (1) {
        my scalar $token = lex_next_token($lexer);

        # Disambiguate PERCENT (hash sigil) vs MOD (modulo operator)
        # If previous token could end a value expression, % is modulo
        if ($token->{"type"} eq "PERCENT") {
            if (lex_is_value_ending_token($prev_type) == 1) {
                $token->{"type"} = "MOD";
            }
        }

        push(@tokens, $token);
        $prev_type = $token->{"type"};

        if ($token->{"type"} eq "EOF") {
            return \@tokens;
        }
    }
}

# Check if a token type can end a value expression
# These tokens, when followed by %, indicate modulo not hash sigil
func lex_is_value_ending_token(str $type) int {
    # Closing brackets/parens
    if ($type eq "RPAREN") { return 1; }
    if ($type eq "RBRACKET") { return 1; }
    if ($type eq "RBRACE") { return 1; }

    # Literals (actual token types used by lexer)
    if ($type eq "INT_LITERAL") { return 1; }
    if ($type eq "NUM_LITERAL") { return 1; }
    if ($type eq "STR_LITERAL") { return 1; }
    if ($type eq "INTERP_STRING") { return 1; }

    # Identifiers (variable names, function calls)
    if ($type eq "IDENT") { return 1; }

    # Post-increment/decrement
    if ($type eq "PLUSPLUS") { return 1; }
    if ($type eq "MINUSMINUS") { return 1; }

    return 0;
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# Parser.strada - Recursive Descent Parser for self-hosting Strada compiler
# Converts token stream to AST

# ============================================================
# Parser State
# ============================================================

func parser_new(scalar $tokens) scalar {
    my hash %parser = ();
    $parser{"tokens"} = $tokens;
    $parser{"pos"} = 0;
    $parser{"token_count"} = size($tokens);
    $parser{"filename"} = "";
    return \%parser;
}

func parser_set_filename(scalar $parser, str $filename) void {
    $parser->{"filename"} = $filename;
}

# Format and die with error message including file:line
func parser_error(scalar $parser, str $msg) void {
    my str $filename = $parser->{"filename"};
    my int $line = parser_current_line($parser);
    if (length($filename) > 0) {
        die($filename . ":" . $line . ": " . $msg);
    } else {
        die("line " . $line . ": " . $msg);
    }
}

func parser_current(scalar $parser) scalar {
    my scalar $tokens = $parser->{"tokens"};
    my int $pos = $parser->{"pos"};
    return $tokens->[$pos];
}

func parser_peek(scalar $parser) scalar {
    my scalar $tokens = $parser->{"tokens"};
    my int $pos = $parser->{"pos"} + 1;
    if ($pos >= $parser->{"token_count"}) {
        return parser_current($parser);
    }
    return $tokens->[$pos];
}

func parser_advance(scalar $parser) void {
    if ($parser->{"pos"} < $parser->{"token_count"} - 1) {
        $parser->{"pos"} = $parser->{"pos"} + 1;
    }
}

func parser_expect(scalar $parser, str $expected_type) void {
    my scalar $tok = parser_current($parser);
    if ($tok->{"type"} ne $expected_type) {
        parser_error($parser, "expected " . $expected_type . ", got " . $tok->{"type"});
    }
    parser_advance($parser);
}

func parser_match(scalar $parser, str $type) int {
    my scalar $tok = parser_current($parser);
    if ($tok->{"type"} eq $type) {
        parser_advance($parser);
        return 1;
    }
    return 0;
}

func parser_check(scalar $parser, str $type) int {
    my scalar $tok = parser_current($parser);
    return $tok->{"type"} eq $type;
}

# Get current token's line number
func parser_current_line(scalar $parser) int {
    my scalar $tok = parser_current($parser);
    return $tok->{"line"};
}

# Parse a variable name - allows type keywords as variable names
func parse_var_name(scalar $parser) str {
    my scalar $tok = parser_current($parser);
    my str $type_str = $tok->{"type"};
    
    # Regular identifier
    if ($type_str eq "IDENT") {
        parser_advance($parser);
        return $tok->{"value"};
    }
    
    # Type keywords can be used as variable names ($int, $num, etc.)
    if ($type_str eq "TYPE_INT") {
        parser_advance($parser);
        return "int";
    }
    if ($type_str eq "TYPE_NUM") {
        parser_advance($parser);
        return "num";
    }
    if ($type_str eq "TYPE_STR") {
        parser_advance($parser);
        return "str";
    }
    if ($type_str eq "TYPE_ARRAY") {
        parser_advance($parser);
        return "array";
    }
    if ($type_str eq "TYPE_HASH") {
        parser_advance($parser);
        return "hash";
    }
    if ($type_str eq "TYPE_SCALAR") {
        parser_advance($parser);
        return "scalar";
    }
    if ($type_str eq "TYPE_VOID") {
        parser_advance($parser);
        return "void";
    }
    # Explicit sized types for extern functions (C interop)
    if ($type_str eq "TYPE_INT32") {
        parser_advance($parser);
        return "int32";
    }
    if ($type_str eq "TYPE_INT64") {
        parser_advance($parser);
        return "int64";
    }
    if ($type_str eq "TYPE_FLOAT32") {
        parser_advance($parser);
        return "float32";
    }
    if ($type_str eq "TYPE_FLOAT64") {
        parser_advance($parser);
        return "float64";
    }

    # Other keywords that can be used as variable names
    if ($type_str eq "VERSION") {
        parser_advance($parser);
        return "version";
    }

    # Loop control keywords
    if ($type_str eq "LAST") {
        parser_advance($parser);
        return "last";
    }
    if ($type_str eq "NEXT") {
        parser_advance($parser);
        return "next";
    }

    # String comparison operators (eq, ne, lt, gt, le, ge)
    if ($type_str eq "STR_EQ") {
        parser_advance($parser);
        return "eq";
    }
    if ($type_str eq "STR_NE") {
        parser_advance($parser);
        return "ne";
    }
    if ($type_str eq "STR_LT") {
        parser_advance($parser);
        return "lt";
    }
    if ($type_str eq "STR_GT") {
        parser_advance($parser);
        return "gt";
    }
    if ($type_str eq "STR_LE") {
        parser_advance($parser);
        return "le";
    }
    if ($type_str eq "STR_GE") {
        parser_advance($parser);
        return "ge";
    }

    # Control flow keywords
    if ($type_str eq "IF") {
        parser_advance($parser);
        return "if";
    }
    if ($type_str eq "ELSE") {
        parser_advance($parser);
        return "else";
    }
    if ($type_str eq "ELSIF") {
        parser_advance($parser);
        return "elsif";
    }
    if ($type_str eq "WHILE") {
        parser_advance($parser);
        return "while";
    }
    if ($type_str eq "FOR") {
        parser_advance($parser);
        return "for";
    }
    if ($type_str eq "FOREACH") {
        parser_advance($parser);
        return "foreach";
    }
    if ($type_str eq "RETURN") {
        parser_advance($parser);
        return "return";
    }
    if ($type_str eq "TRY") {
        parser_advance($parser);
        return "try";
    }
    if ($type_str eq "CATCH") {
        parser_advance($parser);
        return "catch";
    }
    if ($type_str eq "THROW") {
        parser_advance($parser);
        return "throw";
    }
    if ($type_str eq "GOTO") {
        parser_advance($parser);
        return "goto";
    }
    if ($type_str eq "SWITCH") {
        parser_advance($parser);
        return "switch";
    }
    if ($type_str eq "CASE") {
        parser_advance($parser);
        return "case";
    }
    if ($type_str eq "DEFAULT") {
        parser_advance($parser);
        return "default";
    }

    # Declaration keywords
    if ($type_str eq "MY") {
        parser_advance($parser);
        return "my";
    }
    if ($type_str eq "FUNC") {
        parser_advance($parser);
        return "func";
    }
    if ($type_str eq "EXTERN") {
        parser_advance($parser);
        return "extern";
    }
    if ($type_str eq "STRUCT") {
        parser_advance($parser);
        return "struct";
    }
    if ($type_str eq "PACKAGE") {
        parser_advance($parser);
        return "package";
    }
    if ($type_str eq "USE") {
        parser_advance($parser);
        return "use";
    }
    if ($type_str eq "IMPORT_LIB") {
        parser_advance($parser);
        return "import_lib";
    }
    if ($type_str eq "INHERIT") {
        parser_advance($parser);
        return "inherit";
    }

    # Built-in functions that are keywords
    if ($type_str eq "UNDEF") {
        parser_advance($parser);
        return "undef";
    }
    if ($type_str eq "MAP") {
        parser_advance($parser);
        return "map";
    }
    if ($type_str eq "SORT") {
        parser_advance($parser);
        return "sort";
    }
    if ($type_str eq "GREP") {
        parser_advance($parser);
        return "grep";
    }

    parser_error($parser, "expected variable name, got " . $type_str);
}

# ============================================================
# Type Parsing
# ============================================================

func parse_type(scalar $parser) int {
    my scalar $tok = parser_current($parser);
    my str $type_str = $tok->{"type"};
    
    # Clear last type name
    $parser->{"last_type_name"} = "";
    
    if ($type_str eq "TYPE_INT") {
        parser_advance($parser);
        return TYPE_INT();
    }
    if ($type_str eq "TYPE_NUM") {
        parser_advance($parser);
        return TYPE_NUM();
    }
    if ($type_str eq "TYPE_STR") {
        parser_advance($parser);
        return TYPE_STR();
    }
    if ($type_str eq "TYPE_ARRAY") {
        parser_advance($parser);
        return TYPE_ARRAY();
    }
    if ($type_str eq "TYPE_HASH") {
        parser_advance($parser);
        return TYPE_HASH();
    }
    if ($type_str eq "TYPE_SCALAR") {
        parser_advance($parser);
        return TYPE_SCALAR();
    }
    if ($type_str eq "TYPE_VOID") {
        parser_advance($parser);
        return TYPE_VOID();
    }
    # Explicit sized types for extern functions (C interop)
    if ($type_str eq "TYPE_INT32") {
        parser_advance($parser);
        return TYPE_INT32();
    }
    if ($type_str eq "TYPE_INT64") {
        parser_advance($parser);
        return TYPE_INT64();
    }
    if ($type_str eq "TYPE_FLOAT32") {
        parser_advance($parser);
        return TYPE_FLOAT32();
    }
    if ($type_str eq "TYPE_FLOAT64") {
        parser_advance($parser);
        return TYPE_FLOAT64();
    }

    # Struct name (IDENT) - return TYPE_STRUCT and store name
    if ($type_str eq "IDENT") {
        $parser->{"last_type_name"} = $tok->{"value"};
        parser_advance($parser);
        return TYPE_STRUCT();
    }
    
    # Function pointer type: func(...) ReturnType
    if ($type_str eq "FUNC") {
        parser_advance($parser);
        parser_expect($parser, "LPAREN");
        # Skip parameter types
        while (!parser_check($parser, "RPAREN")) {
            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
            } else {
                parse_type($parser);  # Parse and discard param type
            }
        }
        parser_expect($parser, "RPAREN");
        parse_type($parser);  # Parse and discard return type
        return TYPE_FUNCPTR();
    }
    
    parser_error($parser, "expected type, got " . $type_str);
}

# ============================================================
# Expression Parsing (Precedence Climbing)
# ============================================================

# Parse anonymous function: func (params) return_type { body }
# Called after 'func' and seeing LPAREN
func parse_anon_func(scalar $parser, int $line) scalar {
    parser_expect($parser, "LPAREN");

    my scalar $anon = ast_new_anon_func(TYPE_SCALAR());

    # Parse parameters
    if (!parser_check($parser, "RPAREN")) {
        # Parse first parameter
        my int $ptype = parse_type($parser);
        my str $sigil = "$";
        my str $pname = "";

        # Check for sigil
        if (parser_check($parser, "DOLLAR")) {
            parser_advance($parser);
            $sigil = "$";
        } elsif (parser_check($parser, "AT")) {
            parser_advance($parser);
            $sigil = "@";
        } elsif (parser_check($parser, "PERCENT")) {
            parser_advance($parser);
            $sigil = "%";
        }

        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $pname = $name_tok->{"value"};

        my scalar $param = ast_new_param($pname, $ptype, $sigil);
        ast_add_param($anon, $param);

        # Parse remaining parameters
        while (parser_check($parser, "COMMA")) {
            parser_advance($parser);

            $ptype = parse_type($parser);
            $sigil = "$";

            if (parser_check($parser, "DOLLAR")) {
                parser_advance($parser);
                $sigil = "$";
            } elsif (parser_check($parser, "AT")) {
                parser_advance($parser);
                $sigil = "@";
            } elsif (parser_check($parser, "PERCENT")) {
                parser_advance($parser);
                $sigil = "%";
            }

            $name_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            $pname = $name_tok->{"value"};

            $param = ast_new_param($pname, $ptype, $sigil);
            ast_add_param($anon, $param);
        }
    }

    parser_expect($parser, "RPAREN");

    # Optional return type
    if (parser_check($parser, "TYPE_INT")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_INT();
    } elsif (parser_check($parser, "TYPE_NUM")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_NUM();
    } elsif (parser_check($parser, "TYPE_STR")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_STR();
    } elsif (parser_check($parser, "TYPE_SCALAR")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_SCALAR();
    } elsif (parser_check($parser, "TYPE_VOID")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_VOID();
    } elsif (parser_check($parser, "TYPE_INT32")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_INT32();
    } elsif (parser_check($parser, "TYPE_INT64")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_INT64();
    } elsif (parser_check($parser, "TYPE_FLOAT32")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_FLOAT32();
    } elsif (parser_check($parser, "TYPE_FLOAT64")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_FLOAT64();
    }

    # Parse body
    $anon->{"body"} = parse_block($parser);

    ast_set_line($anon, $line);
    return $anon;
}

# Primary expressions: literals, variables, parenthesized, etc.
func parse_primary(scalar $parser) scalar {
    my scalar $tok = parser_current($parser);
    my str $type = $tok->{"type"};
    
    # Integer literal
    if ($type eq "INT_LITERAL") {
        parser_advance($parser);
        return ast_new_int_literal($tok->{"value"});
    }
    
    # Number literal
    if ($type eq "NUM_LITERAL") {
        parser_advance($parser);
        return ast_new_num_literal($tok->{"value"});
    }
    
    # String literal
    if ($type eq "STR_LITERAL") {
        parser_advance($parser);
        return ast_new_str_literal($tok->{"value"});
    }

    # Interpolated string - build concatenation chain
    if ($type eq "INTERP_STRING") {
        parser_advance($parser);
        my scalar $parts = $tok->{"parts"};
        my scalar $vars = $tok->{"vars"};
        my int $num_vars = $tok->{"var_count"};

        # Start with the first part
        my scalar $result = ast_new_str_literal($parts->[0]);

        # Alternate: variable, then next part
        my int $i = 0;
        while ($i < $num_vars) {
            # Concatenate variable
            my str $vname = $vars->[$i];
            my scalar $var_node = ast_new_variable($vname, "$");
            $result = ast_new_binary_op(".", $result, $var_node);

            # Concatenate next string part
            my scalar $part_node = ast_new_str_literal($parts->[$i + 1]);
            $result = ast_new_binary_op(".", $result, $part_node);

            $i = $i + 1;
        }

        return $result;
    }

    # qw() - quote words, returns anonymous array of strings
    if ($type eq "QW_LITERAL") {
        parser_advance($parser);
        my scalar $words = $tok->{"words"};
        my int $len = $tok->{"word_count"};
        my scalar $arr_node = ast_new_anon_array();
        my int $i = 0;
        while ($i < $len) {
            ast_add_array_elem($arr_node, ast_new_str_literal($words->[$i]));
            $i = $i + 1;
        }
        return $arr_node;
    }

    # undef literal
    if ($type eq "UNDEF") {
        parser_advance($parser);
        return ast_new_undef();
    }

    # __PACKAGE__ - returns current package name
    if ($type eq "DUNDER_PACKAGE") {
        parser_advance($parser);
        return ast_new_dunder_package();
    }

    # __FILE__ - returns current file name
    if ($type eq "DUNDER_FILE") {
        parser_advance($parser);
        return ast_new_dunder_file();
    }

    # __LINE__ - returns current line number
    if ($type eq "DUNDER_LINE") {
        my int $line = parser_current_line($parser);
        parser_advance($parser);
        return ast_new_dunder_line($line);
    }

    # Variable or function call
    if ($type eq "DOLLAR") {
        my int $var_line = parser_current_line($parser);
        parser_advance($parser);

        # Check for $$var or $${expr} scalar dereference syntax
        if (parser_check($parser, "DOLLAR")) {
            parser_advance($parser);

            # Check for $${expr} syntax
            if (parser_check($parser, "LBRACE")) {
                parser_advance($parser);
                my scalar $ref_expr = parse_expression($parser);
                parser_expect($parser, "RBRACE");
                my scalar $deref = ast_new_deref_scalar($ref_expr, "$");
                ast_set_line($deref, $var_line);
                return $deref;
            }

            # Simple $$var syntax
            my str $ref_name = parse_var_name($parser);
            my scalar $ref_var = ast_new_variable($ref_name, "$");
            ast_set_line($ref_var, $var_line);
            my scalar $deref = ast_new_deref_scalar($ref_var, "$");
            ast_set_line($deref, $var_line);
            return $deref;
        }

        my str $var_name = parse_var_name($parser);

        # Check for arrow dereference
        if (parser_check($parser, "ARROW")) {
            my scalar $var = ast_new_variable($var_name, "$");
            ast_set_line($var, $var_line);
            return parse_postfix($parser, $var);
        }

        # Check for hash access $var{key} - Perl style: accesses %var
        if (parser_check($parser, "LBRACE")) {
            parser_advance($parser);
            my scalar $key = parse_expression($parser);
            parser_expect($parser, "RBRACE");
            my scalar $var = ast_new_variable($var_name, "%");
            ast_set_line($var, $var_line);
            my scalar $access = ast_new_hash_access($var, $key);
            ast_set_line($access, $var_line);
            return $access;
        }

        # Check for array access $var[idx] - Perl style: accesses @var
        if (parser_check($parser, "LBRACKET")) {
            parser_advance($parser);
            my scalar $idx = parse_expression($parser);
            parser_expect($parser, "RBRACKET");
            my scalar $var = ast_new_variable($var_name, "@");
            ast_set_line($var, $var_line);
            my scalar $sub = ast_new_subscript($var, $idx);
            ast_set_line($sub, $var_line);
            return $sub;
        }

        my scalar $var = ast_new_variable($var_name, "$");
        ast_set_line($var, $var_line);
        return $var;
    }

    # Array variable or @{expr} dereference
    if ($type eq "AT") {
        my int $var_line = parser_current_line($parser);
        parser_advance($parser);

        # Check for @{expr} dereference syntax
        if (parser_check($parser, "LBRACE")) {
            parser_advance($parser);
            my scalar $ref_expr = parse_expression($parser);
            parser_expect($parser, "RBRACE");
            my scalar $deref = ast_new_deref_scalar($ref_expr, "@");
            ast_set_line($deref, $var_line);
            return $deref;
        }

        my str $arr_name = parse_var_name($parser);
        my scalar $var = ast_new_variable($arr_name, "@");
        ast_set_line($var, $var_line);
        return $var;
    }

    # Hash variable or %{expr} dereference
    if ($type eq "PERCENT") {
        my int $var_line = parser_current_line($parser);
        parser_advance($parser);

        # Check for %{expr} dereference syntax
        if (parser_check($parser, "LBRACE")) {
            parser_advance($parser);
            my scalar $ref_expr = parse_expression($parser);
            parser_expect($parser, "RBRACE");
            my scalar $deref = ast_new_deref_scalar($ref_expr, "%");
            ast_set_line($deref, $var_line);
            return $deref;
        }

        my str $hash_name = parse_var_name($parser);
        my scalar $var = ast_new_variable($hash_name, "%");
        ast_set_line($var, $var_line);
        return $var;
    }
    
    # Reference operator
    if ($type eq "BACKSLASH") {
        parser_advance($parser);
        my scalar $target = parse_primary($parser);

        # Determine reference type from target
        my str $ref_type = "$";
        if ($target->{"type"} == NODE_VARIABLE()) {
            $ref_type = $target->{"sigil"};
        } elsif ($target->{"type"} == NODE_FUNC_REF()) {
            $ref_type = "&";
        }

        return ast_new_ref($target, $ref_type);
    }
    
    # Anonymous hash { }
    if ($type eq "LBRACE") {
        parser_advance($parser);
        my scalar $anon = ast_new_anon_hash();
        
        # Empty hash check
        if (parser_check($parser, "RBRACE")) {
            parser_advance($parser);
            return $anon;
        }
        
        # Parse key => value pairs
        while (1) {
            # Key (string or bareword)
            my scalar $key_tok = parser_current($parser);
            my str $key = "";
            
            if ($key_tok->{"type"} eq "STR_LITERAL" || $key_tok->{"type"} eq "IDENT") {
                $key = $key_tok->{"value"};
                parser_advance($parser);
            } else {
                parser_error($parser, "expected hash key");
            }
            
            parser_expect($parser, "FAT_ARROW");
            
            my scalar $value = parse_expression($parser);
            ast_add_hash_pair($anon, $key, $value);
            
            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
                if (parser_check($parser, "RBRACE")) {
                    parser_advance($parser);
                    return $anon;
                }
            } else {
                parser_expect($parser, "RBRACE");
                return $anon;
            }
        }
    }
    
    # Anonymous array [ ]
    if ($type eq "LBRACKET") {
        parser_advance($parser);
        my scalar $anon = ast_new_anon_array();
        
        # Empty array check
        if (parser_check($parser, "RBRACKET")) {
            parser_advance($parser);
            return $anon;
        }
        
        # Parse elements
        while (1) {
            my scalar $elem = parse_expression($parser);
            ast_add_array_elem($anon, $elem);
            
            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
                if (parser_check($parser, "RBRACKET")) {
                    parser_advance($parser);
                    return $anon;
                }
            } else {
                parser_expect($parser, "RBRACKET");
                return $anon;
            }
        }
    }
    
    # Parenthesized expression, array literal (1, 2, 3), or empty ()
    if ($type eq "LPAREN") {
        parser_advance($parser);
        
        # Empty () - returns empty hash/array depending on context
        if (parser_check($parser, "RPAREN")) {
            parser_advance($parser);
            return ast_new_anon_hash();
        }
        
        my scalar $first = parse_expression($parser);
        
        # Check if this is an array literal (has comma)
        if (parser_check($parser, "COMMA")) {
            my scalar $arr = ast_new_anon_array();
            ast_add_array_elem($arr, $first);
            
            while (parser_check($parser, "COMMA")) {
                parser_advance($parser);
                if (parser_check($parser, "RPAREN")) {
                    # Trailing comma allowed
                    last;
                }
                my scalar $elem = parse_expression($parser);
                ast_add_array_elem($arr, $elem);
            }
            parser_expect($parser, "RPAREN");
            return $arr;
        }
        
        # Single expression in parens
        parser_expect($parser, "RPAREN");
        return $first;
    }
    
    # Function call (bareword)
    if ($type eq "IDENT") {
        my str $name = $tok->{"value"};
        my int $call_line = $tok->{"line"};
        parser_advance($parser);

        # Check for function call
        if (parser_check($parser, "LPAREN")) {
            parser_advance($parser);
            my scalar $call = ast_new_call($name);
            ast_set_line($call, $call_line);

            # Parse arguments
            if (!parser_check($parser, "RPAREN")) {
                my scalar $arg = parse_expression($parser);
                ast_add_arg($call, $arg);

                while (parser_check($parser, "COMMA")) {
                    parser_advance($parser);
                    my scalar $next_arg = parse_expression($parser);
                    ast_add_arg($call, $next_arg);
                }
            }

            parser_expect($parser, "RPAREN");
            return $call;
        }

        # Check for SUPER::method() call
        if ($name eq "SUPER" && parser_check($parser, "DOUBLE_COLON")) {
            parser_advance($parser);
            my scalar $method_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            my str $method_name = $method_tok->{"value"};

            # SUPER::method must be followed by ()
            if (!parser_check($parser, "LPAREN")) {
                parser_error($parser, "expected ( after SUPER::" . $method_name);
            }
            parser_advance($parser);
            my scalar $super_call = ast_new_super_call($method_name);
            ast_set_line($super_call, $call_line);

            # Parse arguments
            if (!parser_check($parser, "RPAREN")) {
                my scalar $arg = parse_expression($parser);
                ast_add_arg($super_call, $arg);

                while (parser_check($parser, "COMMA")) {
                    parser_advance($parser);
                    my scalar $next_arg = parse_expression($parser);
                    ast_add_arg($super_call, $next_arg);
                }
            }

            parser_expect($parser, "RPAREN");
            return $super_call;
        }

        # Check for qualified name (Package::func)
        if (parser_check($parser, "DOUBLE_COLON")) {
            while (parser_check($parser, "DOUBLE_COLON")) {
                parser_advance($parser);
                my scalar $next_tok = parser_current($parser);
                parser_expect($parser, "IDENT");
                $name = $name . "::" . $next_tok->{"value"};
            }

            # Check for function call
            if (parser_check($parser, "LPAREN")) {
                parser_advance($parser);
                my scalar $call = ast_new_call($name);
                ast_set_line($call, $call_line);

                if (!parser_check($parser, "RPAREN")) {
                    my scalar $arg = parse_expression($parser);
                    ast_add_arg($call, $arg);

                    while (parser_check($parser, "COMMA")) {
                        parser_advance($parser);
                        my scalar $next_arg = parse_expression($parser);
                        ast_add_arg($call, $next_arg);
                    }
                }

                parser_expect($parser, "RPAREN");
                return $call;
            }

            # Just a qualified name
            return ast_new_str_literal($name);
        }

        # Just an identifier (bareword string in some contexts)
        return ast_new_str_literal($name);
    }

    # inherit() function call when used inside a function body
    if ($type eq "INHERIT") {
        my int $call_line = parser_current_line($parser);
        parser_advance($parser);
        if (parser_check($parser, "LPAREN")) {
            parser_advance($parser);
            my scalar $call = ast_new_call("inherit");
            ast_set_line($call, $call_line);
            if (!parser_check($parser, "RPAREN")) {
                my scalar $arg = parse_expression($parser);
                ast_add_arg($call, $arg);
                while (parser_check($parser, "COMMA")) {
                    parser_advance($parser);
                    my scalar $next_arg = parse_expression($parser);
                    ast_add_arg($call, $next_arg);
                }
            }
            parser_expect($parser, "RPAREN");
            return $call;
        }
        parser_error($parser, "expected ( after inherit");
    }

    # scalar() function - TYPE_SCALAR followed by (
    if ($type eq "TYPE_SCALAR") {
        my int $call_line = parser_current_line($parser);
        parser_advance($parser);
        if (parser_check($parser, "LPAREN")) {
            parser_advance($parser);
            my scalar $call = ast_new_call("scalar");
            ast_set_line($call, $call_line);
            if (!parser_check($parser, "RPAREN")) {
                my scalar $arg = parse_expression($parser);
                ast_add_arg($call, $arg);
            }
            parser_expect($parser, "RPAREN");
            return $call;
        }
        parser_error($parser, "unexpected TYPE_SCALAR in expression");
    }
    
    # Unary minus
    if ($type eq "MINUS") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_unary_op("-", $operand);
    }
    
    # Logical not
    if ($type eq "NOT") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_unary_op("!", $operand);
    }
    
    # Function reference (&func_name)
    if ($type eq "AMPERSAND") {
        parser_advance($parser);
        my scalar $func_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        return ast_new_func_ref($func_tok->{"value"});
    }

    # map { block } @array - transforms each element using $_
    if ($type eq "MAP") {
        my int $map_line = parser_current_line($parser);
        parser_advance($parser);
        parser_expect($parser, "LBRACE");
        my scalar $block = ast_new_block();

        # Parse block body - can be multiple statements or a single expression
        while (!parser_check($parser, "RBRACE") && !parser_check($parser, "EOF")) {
            my scalar $stmt = parse_statement($parser);
            ast_add_statement($block, $stmt);
        }
        parser_expect($parser, "RBRACE");

        # Parse the array expression
        my scalar $array_expr = parse_unary($parser);
        my scalar $map_node = ast_new_map($block, $array_expr);
        ast_set_line($map_node, $map_line);
        return $map_node;
    }

    # sort { $a <=> $b } @array - sorts array using comparator block
    if ($type eq "SORT") {
        my int $sort_line = parser_current_line($parser);
        parser_advance($parser);

        # Check if there's a block or just an array (default sort)
        if (parser_check($parser, "LBRACE")) {
            parser_advance($parser);
            my scalar $block = ast_new_block();

            # Parse block body
            while (!parser_check($parser, "RBRACE") && !parser_check($parser, "EOF")) {
                my scalar $stmt = parse_statement($parser);
                ast_add_statement($block, $stmt);
            }
            parser_expect($parser, "RBRACE");

            # Parse the array expression
            my scalar $array_expr = parse_unary($parser);
            my scalar $sort_node = ast_new_sort($block, $array_expr);
            ast_set_line($sort_node, $sort_line);
            return $sort_node;
        } else {
            # Default sort (no block) - use empty block
            my scalar $array_expr = parse_unary($parser);
            my scalar $sort_node = ast_new_sort(0, $array_expr);
            ast_set_line($sort_node, $sort_line);
            return $sort_node;
        }
    }

    # grep { block } @array - filters array elements using $_
    if ($type eq "GREP") {
        my int $grep_line = parser_current_line($parser);
        parser_advance($parser);
        parser_expect($parser, "LBRACE");
        my scalar $block = ast_new_block();

        # Parse block body
        while (!parser_check($parser, "RBRACE") && !parser_check($parser, "EOF")) {
            my scalar $stmt = parse_statement($parser);
            ast_add_statement($block, $stmt);
        }
        parser_expect($parser, "RBRACE");

        # Parse the array expression
        my scalar $array_expr = parse_unary($parser);
        my scalar $grep_node = ast_new_grep($block, $array_expr);
        ast_set_line($grep_node, $grep_line);
        return $grep_node;
    }

    # Anonymous function: func (params) { body }
    if ($type eq "FUNC") {
        my int $anon_line = parser_current_line($parser);
        parser_advance($parser);  # Skip 'func'

        # Check for LPAREN - if present, this is an anonymous function
        if (parser_check($parser, "LPAREN")) {
            return parse_anon_func($parser, $anon_line);
        }
        # Otherwise it's a parse error (named func should be at statement level)
        parser_error($parser, "unexpected 'func' in expression context");
    }

    parser_error($parser, "unexpected token in expression: " . $type);
}

# Parse postfix operations (-> derefs, function calls, subscripts)
func parse_postfix(scalar $parser, scalar $left) scalar {
    while (1) {
        if (parser_check($parser, "ARROW")) {
            parser_advance($parser);

            # Closure call ->(args)
            if (parser_check($parser, "LPAREN")) {
                parser_advance($parser);
                my array @args = ();
                my int $arg_count = 0;

                # Parse arguments
                if (!parser_check($parser, "RPAREN")) {
                    push(@args, parse_expression($parser));
                    $arg_count = $arg_count + 1;

                    while (parser_check($parser, "COMMA")) {
                        parser_advance($parser);
                        push(@args, parse_expression($parser));
                        $arg_count = $arg_count + 1;
                    }
                }
                parser_expect($parser, "RPAREN");
                $left = ast_new_closure_call($left, \@args, $arg_count);
            }
            # Hash dereference ->{key}
            elsif (parser_check($parser, "LBRACE")) {
                parser_advance($parser);
                my scalar $key = parse_expression($parser);
                parser_expect($parser, "RBRACE");
                $left = ast_new_deref_hash($left, $key);
            }
            # Array dereference ->[idx]
            elsif (parser_check($parser, "LBRACKET")) {
                parser_advance($parser);
                my scalar $idx = parse_expression($parser);
                parser_expect($parser, "RBRACKET");
                $left = ast_new_deref_array($left, $idx);
            }
            # Struct field access ->field or method call ->method()
            elsif (parser_check($parser, "IDENT")) {
                my scalar $field_tok = parser_current($parser);
                parser_advance($parser);
                my scalar $field = ast_new_field_access($left, $field_tok->{"value"});

                # Check for method call
                if (parser_check($parser, "LPAREN")) {
                    parser_advance($parser);
                    # For method calls, store both:
                    # - field: the FIELD_ACCESS node (needed for struct funcptr detection)
                    # - base_object: the original object (needed for OOP method calls)
                    my scalar $call = ast_new_method_call($field, $field_tok->{"value"});
                    $call->{"base_object"} = $left;

                    # Parse arguments
                    if (!parser_check($parser, "RPAREN")) {
                        my scalar $arg = parse_expression($parser);
                        ast_add_arg($call, $arg);

                        while (parser_check($parser, "COMMA")) {
                            parser_advance($parser);
                            my scalar $next_arg = parse_expression($parser);
                            ast_add_arg($call, $next_arg);
                        }
                    }
                    parser_expect($parser, "RPAREN");
                    $left = $call;
                } else {
                    $left = $field;
                }
            }
            else {
                parser_error($parser, "expected {, [, or field name after ->");
            }
        }
        elsif (parser_check($parser, "LBRACE")) {
            # Check for invalid %hash{key} syntax - should use $hash{key}
            if ($left->{"type"} == NODE_VARIABLE()) {
                my str $sigil = $left->{"sigil"};
                if ($sigil eq "%") {
                    parser_error($parser, "use $hash{key} for hash element access (hash sigil not allowed here)");
                }
                if ($sigil eq "@") {
                    parser_error($parser, "cannot use hash subscript {key} on array variable");
                }
            }
            parser_advance($parser);
            my scalar $key = parse_expression($parser);
            parser_expect($parser, "RBRACE");
            $left = ast_new_hash_access($left, $key);
        }
        elsif (parser_check($parser, "LBRACKET")) {
            # Check for invalid %hash[idx] syntax (but allow @arr[idx] for compatibility)
            if ($left->{"type"} == NODE_VARIABLE()) {
                my str $sigil = $left->{"sigil"};
                if ($sigil eq "%") {
                    parser_error($parser, "cannot use array subscript [idx] on hash variable");
                }
            }
            parser_advance($parser);
            my scalar $idx = parse_expression($parser);
            parser_expect($parser, "RBRACKET");
            $left = ast_new_subscript($left, $idx);
        }
        elsif (parser_check($parser, "PLUSPLUS")) {
            parser_advance($parser);
            $left = ast_new_increment("++", $left, 0);
        }
        elsif (parser_check($parser, "MINUSMINUS")) {
            parser_advance($parser);
            $left = ast_new_increment("--", $left, 0);
        }
        else {
            return $left;
        }
    }
}

# Unary expressions
func parse_unary(scalar $parser) scalar {
    my scalar $tok = parser_current($parser);
    
    if ($tok->{"type"} eq "MINUS") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_unary_op("-", $operand);
    }
    
    if ($tok->{"type"} eq "NOT") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_unary_op("!", $operand);
    }

    if ($tok->{"type"} eq "TILDE") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_unary_op("~", $operand);
    }

    # Prefix increment/decrement
    if ($tok->{"type"} eq "PLUSPLUS") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_increment("++", $operand, 1);
    }

    if ($tok->{"type"} eq "MINUSMINUS") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_increment("--", $operand, 1);
    }

    my scalar $primary = parse_primary($parser);
    return parse_postfix($parser, $primary);
}

# Power: ** (right-associative, higher precedence than multiplicative)
func parse_power(scalar $parser) scalar {
    my scalar $left = parse_unary($parser);

    my scalar $tok = parser_current($parser);
    if ($tok->{"type"} eq "POWER") {
        my str $op = $tok->{"value"};
        parser_advance($parser);
        # Right-associative: recurse on right side
        my scalar $right = parse_power($parser);
        return ast_new_binary_op($op, $left, $right);
    }

    return $left;
}

# Multiplicative: * / %
func parse_multiplicative(scalar $parser) scalar {
    my scalar $left = parse_power($parser);

    while (1) {
        my scalar $tok = parser_current($parser);
        my str $type = $tok->{"type"};

        if ($type eq "MULT" || $type eq "DIV" || $type eq "MOD") {
            my str $op = $tok->{"value"};
            parser_advance($parser);
            my scalar $right = parse_power($parser);
            $left = ast_new_binary_op($op, $left, $right);
        } else {
            return $left;
        }
    }
}

# Additive: + - .
func parse_additive(scalar $parser) scalar {
    my scalar $left = parse_multiplicative($parser);
    
    while (1) {
        my scalar $tok = parser_current($parser);
        my str $type = $tok->{"type"};
        
        if ($type eq "PLUS" || $type eq "MINUS" || $type eq "DOT") {
            my str $op = $tok->{"value"};
            parser_advance($parser);
            my scalar $right = parse_multiplicative($parser);
            $left = ast_new_binary_op($op, $left, $right);
        } else {
            return $left;
        }
    }
}

# Shift: << >>
func parse_shift(scalar $parser) scalar {
    my scalar $left = parse_additive($parser);

    while (1) {
        my scalar $tok = parser_current($parser);
        my str $type = $tok->{"type"};

        if ($type eq "LSHIFT" || $type eq "RSHIFT") {
            my str $op = $tok->{"value"};
            parser_advance($parser);
            my scalar $right = parse_additive($parser);
            $left = ast_new_binary_op($op, $left, $right);
        } else {
            return $left;
        }
    }
}

# Range: ..
func parse_range(scalar $parser) scalar {
    my scalar $left = parse_shift($parser);

    if (parser_check($parser, "RANGE")) {
        parser_advance($parser);
        my scalar $right = parse_shift($parser);
        return ast_new_range($left, $right);
    }

    return $left;
}

# Relational: < > <= >= lt gt le ge
func parse_relational(scalar $parser) scalar {
    my scalar $left = parse_range($parser);

    while (1) {
        my scalar $tok = parser_current($parser);
        my str $type = $tok->{"type"};

        if ($type eq "LT" || $type eq "GT" || $type eq "LE" || $type eq "GE") {
            my str $op = $tok->{"value"};
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op($op, $left, $right);
        } elsif ($type eq "STR_LT") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("lt", $left, $right);
        } elsif ($type eq "STR_GT") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("gt", $left, $right);
        } elsif ($type eq "STR_LE") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("le", $left, $right);
        } elsif ($type eq "STR_GE") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("ge", $left, $right);
        } elsif ($type eq "SPACESHIP") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("<=>", $left, $right);
        } else {
            return $left;
        }
    }
}

# Regex match: =~ !~
func parse_regex_match(scalar $parser) scalar {
    my scalar $left = parse_relational($parser);

    my scalar $tok = parser_current($parser);
    my str $type = $tok->{"type"};

    if ($type eq "MATCH_OP" || $type eq "NOT_MATCH_OP") {
        my str $op = $tok->{"value"};
        parser_advance($parser);

        my scalar $right_tok = parser_current($parser);
        my str $right_type = $right_tok->{"type"};

        if ($right_type eq "REGEX_LITERAL") {
            parser_advance($parser);
            return ast_new_regex_match($op, $left, $right_tok->{"pattern"}, $right_tok->{"flags"});
        } elsif ($right_type eq "SUBST_LITERAL") {
            parser_advance($parser);
            if ($op eq "!~") {
                parser_error($parser, "cannot use !~ with substitution s///");
            }
            return ast_new_regex_subst($left, $right_tok->{"pattern"}, $right_tok->{"replacement"}, $right_tok->{"flags"});
        } else {
            # String expression as pattern: $foo =~ $pattern
            my scalar $right = parse_relational($parser);
            return ast_new_binary_op($op, $left, $right);
        }
    }

    return $left;
}

# Equality: == != eq ne
func parse_equality(scalar $parser) scalar {
    my scalar $left = parse_regex_match($parser);
    
    while (1) {
        my scalar $tok = parser_current($parser);
        my str $type = $tok->{"type"};
        
        if ($type eq "EQ" || $type eq "NE") {
            my str $op = $tok->{"value"};
            parser_advance($parser);
            my scalar $right = parse_relational($parser);
            $left = ast_new_binary_op($op, $left, $right);
        } elsif ($type eq "STR_EQ") {
            parser_advance($parser);
            my scalar $right = parse_relational($parser);
            $left = ast_new_binary_op("eq", $left, $right);
        } elsif ($type eq "STR_NE") {
            parser_advance($parser);
            my scalar $right = parse_relational($parser);
            $left = ast_new_binary_op("ne", $left, $right);
        } else {
            return $left;
        }
    }
}

# Bitwise AND: &
func parse_bitwise_and(scalar $parser) scalar {
    my scalar $left = parse_equality($parser);

    while (parser_check($parser, "AMPERSAND")) {
        parser_advance($parser);
        my scalar $right = parse_equality($parser);
        $left = ast_new_binary_op("&", $left, $right);
    }

    return $left;
}

# Bitwise XOR: ^
func parse_bitwise_xor(scalar $parser) scalar {
    my scalar $left = parse_bitwise_and($parser);

    while (parser_check($parser, "CARET")) {
        parser_advance($parser);
        my scalar $right = parse_bitwise_and($parser);
        $left = ast_new_binary_op("^", $left, $right);
    }

    return $left;
}

# Bitwise OR: |
func parse_bitwise_or(scalar $parser) scalar {
    my scalar $left = parse_bitwise_xor($parser);

    while (parser_check($parser, "PIPE")) {
        parser_advance($parser);
        my scalar $right = parse_bitwise_xor($parser);
        $left = ast_new_binary_op("|", $left, $right);
    }

    return $left;
}

# Logical AND: &&
func parse_logical_and(scalar $parser) scalar {
    my scalar $left = parse_bitwise_or($parser);

    while (parser_check($parser, "AND")) {
        parser_advance($parser);
        my scalar $right = parse_bitwise_or($parser);
        $left = ast_new_binary_op("&&", $left, $right);
    }

    return $left;
}

# Logical OR: ||
func parse_logical_or(scalar $parser) scalar {
    my scalar $left = parse_logical_and($parser);

    while (parser_check($parser, "OR")) {
        parser_advance($parser);
        my scalar $right = parse_logical_and($parser);
        $left = ast_new_binary_op("||", $left, $right);
    }

    return $left;
}

# Ternary expression: cond ? true_expr : false_expr
func parse_ternary(scalar $parser) scalar {
    my scalar $cond = parse_logical_or($parser);

    if (parser_check($parser, "QUESTION")) {
        parser_advance($parser);
        my scalar $true_expr = parse_expression($parser);
        parser_expect($parser, "COLON");
        my scalar $false_expr = parse_ternary($parser);
        return ast_new_ternary($cond, $true_expr, $false_expr);
    }

    return $cond;
}

# Assignment expression
func parse_assignment(scalar $parser) scalar {
    my scalar $left = parse_ternary($parser);
    
    my scalar $tok = parser_current($parser);
    my str $type = $tok->{"type"};
    
    if ($type eq "ASSIGN" || $type eq "PLUS_ASSIGN" || 
        $type eq "MINUS_ASSIGN" || $type eq "DOT_ASSIGN") {
        my str $op = $tok->{"value"};
        parser_advance($parser);
        my scalar $right = parse_assignment($parser);
        return ast_new_assign($op, $left, $right);
    }
    
    return $left;
}

# Top-level expression
func parse_expression(scalar $parser) scalar {
    return parse_assignment($parser);
}

# ============================================================
# Statement Parsing
# ============================================================

# Parse case value - handles literals and simple variables without hash access interpretation
func parse_case_value(scalar $parser) scalar {
    my scalar $tok = parser_current($parser);
    my str $type = $tok->{"type"};

    # Integer literal
    if ($type eq "INT_LITERAL") {
        parser_advance($parser);
        return ast_new_int_literal($tok->{"value"});
    }

    # Number literal
    if ($type eq "NUM_LITERAL") {
        parser_advance($parser);
        return ast_new_num_literal($tok->{"value"});
    }

    # String literal
    if ($type eq "STR_LITERAL") {
        parser_advance($parser);
        return ast_new_str_literal($tok->{"value"});
    }

    # Variable (without hash access interpretation)
    if ($type eq "DOLLAR") {
        my int $var_line = parser_current_line($parser);
        parser_advance($parser);
        my str $var_name = parse_var_name($parser);
        my scalar $var = ast_new_variable($var_name, "$");
        ast_set_line($var, $var_line);
        return $var;
    }

    # Bareword/identifier
    if ($type eq "IDENT") {
        my str $name = $tok->{"value"};
        parser_advance($parser);
        return ast_new_str_literal($name);
    }

    parser_error($parser, "expected case value");
}

func parse_block(scalar $parser) scalar {
    parser_expect($parser, "LBRACE");
    my scalar $block = ast_new_block();
    
    while (!parser_check($parser, "RBRACE") && !parser_check($parser, "EOF")) {
        my scalar $stmt = parse_statement($parser);
        ast_add_statement($block, $stmt);
    }
    
    parser_expect($parser, "RBRACE");
    return $block;
}

func parse_var_decl(scalar $parser) scalar {
    my int $decl_line = parser_current_line($parser);
    parser_expect($parser, "MY");

    my int $var_type = parse_type($parser);
    my str $type_name = $parser->{"last_type_name"};

    # Get sigil and name
    my scalar $sigil_tok = parser_current($parser);
    my str $sigil = "$";

    if ($sigil_tok->{"type"} eq "DOLLAR") {
        $sigil = "$";
        parser_advance($parser);
    } elsif ($sigil_tok->{"type"} eq "AT") {
        $sigil = "@";
        parser_advance($parser);
    } elsif ($sigil_tok->{"type"} eq "PERCENT") {
        $sigil = "%";
        parser_advance($parser);
    }

    my str $name = parse_var_name($parser);

    my scalar $decl = ast_new_var_decl($name, $var_type, $sigil);
    ast_set_line($decl, $decl_line);

    # Store struct type name if applicable
    if ($var_type == TYPE_STRUCT()) {
        $decl->{"type_name"} = $type_name;
    }

    # Optional initial capacity for arrays: my array @name[size];
    if ($sigil eq "@") {
        if (parser_check($parser, "LBRACKET")) {
            parser_advance($parser);
            $decl->{"initial_capacity"} = parse_expression($parser);
            parser_expect($parser, "RBRACKET");
        }
    }

    # Optional initial capacity for hashes: my hash %name[size];
    if ($sigil eq "%") {
        if (parser_check($parser, "LBRACKET")) {
            parser_advance($parser);
            $decl->{"initial_capacity"} = parse_expression($parser);
            parser_expect($parser, "RBRACKET");
        }
    }

    # Optional initialization
    if (parser_check($parser, "ASSIGN")) {
        parser_advance($parser);
        $decl->{"init"} = parse_expression($parser);
    }

    parser_expect($parser, "SEMI");
    return $decl;
}

func parse_if_stmt(scalar $parser) scalar {
    parser_expect($parser, "IF");
    parser_expect($parser, "LPAREN");
    my scalar $condition = parse_expression($parser);
    parser_expect($parser, "RPAREN");
    
    my scalar $then_block = parse_block($parser);
    my scalar $if_stmt = ast_new_if_stmt($condition, $then_block);
    
    # Handle elsif clauses
    while (parser_check($parser, "ELSIF")) {
        parser_advance($parser);
        parser_expect($parser, "LPAREN");
        my scalar $elsif_cond = parse_expression($parser);
        parser_expect($parser, "RPAREN");
        my scalar $elsif_block = parse_block($parser);
        ast_add_elsif($if_stmt, $elsif_cond, $elsif_block);
    }
    
    # Handle else clause
    if (parser_check($parser, "ELSE")) {
        parser_advance($parser);
        $if_stmt->{"else_block"} = parse_block($parser);
    }
    
    return $if_stmt;
}

func parse_while_stmt(scalar $parser, str $label) scalar {
    parser_expect($parser, "WHILE");
    parser_expect($parser, "LPAREN");
    my scalar $condition = parse_expression($parser);
    parser_expect($parser, "RPAREN");

    my scalar $body = parse_block($parser);
    return ast_new_while_stmt($condition, $body, $label);
}

# Parse array-style for loop: for my type $var (@array) or for $var (@array)
# This is syntactic sugar for foreach
func parse_for_array_style(scalar $parser, str $label) scalar {
    my scalar $var_decl = 0;
    my str $var_name = "";

    # Check if we have a variable declaration or existing variable
    if (parser_check($parser, "MY")) {
        # for my type $var (@array)
        parser_advance($parser);
        my int $var_type = parse_type($parser);

        my scalar $sigil_tok = parser_current($parser);
        my str $sigil = "$";
        if ($sigil_tok->{"type"} eq "DOLLAR") {
            $sigil = "$";
            parser_advance($parser);
        }

        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $var_name = $name_tok->{"value"};

        $var_decl = ast_new_var_decl($var_name, $var_type, $sigil);
    } else {
        # for $var (@array) - must be existing variable with $ sigil
        parser_expect($parser, "DOLLAR");
        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $var_name = $name_tok->{"value"};
    }

    parser_expect($parser, "LPAREN");
    my scalar $array_expr = parse_expression($parser);
    parser_expect($parser, "RPAREN");

    my scalar $body = parse_block($parser);
    return ast_new_foreach_stmt($var_decl, $var_name, $array_expr, $body, $label);
}

func parse_for_stmt(scalar $parser, str $label) scalar {
    parser_expect($parser, "FOR");

    # Check if this is array-style for (like foreach) or C-style for
    # for my type $var (@array) - array style
    # for $var (@array) - array style
    # for (init; cond; update) - C style
    if (parser_check($parser, "MY") || parser_check($parser, "DOLLAR")) {
        # Array-style for loop - delegate to foreach parsing logic
        return parse_for_array_style($parser, $label);
    }

    parser_expect($parser, "LPAREN");

    # Init (may be var decl or expression)
    my scalar $init = 0;
    if (parser_check($parser, "MY")) {
        # Variable declaration (without semicolon)
        parser_advance($parser);
        my int $var_type = parse_type($parser);

        my scalar $sigil_tok = parser_current($parser);
        my str $sigil = "$";
        if ($sigil_tok->{"type"} eq "DOLLAR") {
            $sigil = "$";
            parser_advance($parser);
        }

        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");

        $init = ast_new_var_decl($name_tok->{"value"}, $var_type, $sigil);

        if (parser_check($parser, "ASSIGN")) {
            parser_advance($parser);
            $init->{"init"} = parse_expression($parser);
        }
    } elsif (!parser_check($parser, "SEMI")) {
        $init = parse_expression($parser);
    }
    parser_expect($parser, "SEMI");

    # Condition
    my scalar $cond = 0;
    if (!parser_check($parser, "SEMI")) {
        $cond = parse_expression($parser);
    }
    parser_expect($parser, "SEMI");

    # Update
    my scalar $update = 0;
    if (!parser_check($parser, "RPAREN")) {
        $update = parse_expression($parser);
    }
    parser_expect($parser, "RPAREN");

    my scalar $body = parse_block($parser);
    return ast_new_for_stmt($init, $cond, $update, $body, $label);
}

func parse_foreach_stmt(scalar $parser, str $label) scalar {
    parser_expect($parser, "FOREACH");

    my scalar $var_decl = 0;
    my str $var_name = "";

    # Check if we have a variable declaration or existing variable
    if (parser_check($parser, "MY")) {
        # foreach my type $var (@array)
        parser_advance($parser);
        my int $var_type = parse_type($parser);

        my scalar $sigil_tok = parser_current($parser);
        my str $sigil = "$";
        if ($sigil_tok->{"type"} eq "DOLLAR") {
            $sigil = "$";
            parser_advance($parser);
        }

        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $var_name = $name_tok->{"value"};

        $var_decl = ast_new_var_decl($var_name, $var_type, $sigil);
    } else {
        # foreach $var (@array) - must be existing variable with $ sigil
        parser_expect($parser, "DOLLAR");
        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $var_name = $name_tok->{"value"};
    }

    parser_expect($parser, "LPAREN");
    my scalar $array_expr = parse_expression($parser);
    parser_expect($parser, "RPAREN");

    my scalar $body = parse_block($parser);
    return ast_new_foreach_stmt($var_decl, $var_name, $array_expr, $body, $label);
}

func parse_return_stmt(scalar $parser) scalar {
    parser_expect($parser, "RETURN");
    
    my scalar $value = 0;
    if (!parser_check($parser, "SEMI")) {
        $value = parse_expression($parser);
    }
    
    parser_expect($parser, "SEMI");
    return ast_new_return_stmt($value);
}

func parse_statement(scalar $parser) scalar {
    my scalar $tok = parser_current($parser);
    my str $type = $tok->{"type"};

    if ($type eq "MY") {
        return parse_var_decl($parser);
    }

    if ($type eq "IF") {
        return parse_if_stmt($parser);
    }

    # Check for labeled statement: LABEL: while/for
    if ($type eq "IDENT") {
        my scalar $peek_tok = parser_peek($parser);
        if ($peek_tok->{"type"} eq "COLON") {
            my str $label = $tok->{"value"};
            parser_advance($parser);
            parser_advance($parser);

            my scalar $loop_tok = parser_current($parser);
            my str $loop_type = $loop_tok->{"type"};

            if ($loop_type eq "WHILE") {
                return parse_while_stmt($parser, $label);
            } elsif ($loop_type eq "FOR") {
                return parse_for_stmt($parser, $label);
            } elsif ($loop_type eq "FOREACH") {
                return parse_foreach_stmt($parser, $label);
            } else {
                # Standalone label for goto
                return ast_new_label($label);
            }
        }
    }

    if ($type eq "WHILE") {
        return parse_while_stmt($parser, "");
    }

    if ($type eq "FOR") {
        return parse_for_stmt($parser, "");
    }

    if ($type eq "FOREACH") {
        return parse_foreach_stmt($parser, "");
    }

    if ($type eq "RETURN") {
        return parse_return_stmt($parser);
    }

    if ($type eq "LAST") {
        parser_advance($parser);
        my str $label = "";
        my scalar $label_tok = parser_current($parser);
        if ($label_tok->{"type"} eq "IDENT") {
            $label = $label_tok->{"value"};
            parser_advance($parser);
        }
        parser_expect($parser, "SEMI");
        return ast_new_last($label);
    }

    if ($type eq "NEXT") {
        parser_advance($parser);
        my str $label = "";
        my scalar $label_tok = parser_current($parser);
        if ($label_tok->{"type"} eq "IDENT") {
            $label = $label_tok->{"value"};
            parser_advance($parser);
        }
        parser_expect($parser, "SEMI");
        return ast_new_next($label);
    }

    # try { ... } catch ($e) { ... }
    if ($type eq "TRY") {
        parser_advance($parser);
        my scalar $try_block = parse_block($parser);

        parser_expect($parser, "CATCH");
        parser_expect($parser, "LPAREN");
        parser_expect($parser, "DOLLAR");
        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        my str $catch_var = $name_tok->{"value"};
        parser_expect($parser, "RPAREN");

        my scalar $catch_block = parse_block($parser);

        return ast_new_try_catch($try_block, $catch_var, $catch_block);
    }

    # throw $expr;
    if ($type eq "THROW") {
        parser_advance($parser);
        my scalar $expr = parse_expression($parser);
        parser_expect($parser, "SEMI");
        return ast_new_throw($expr);
    }

    # goto LABEL;
    if ($type eq "GOTO") {
        parser_advance($parser);
        my scalar $tok = parser_current($parser);
        my str $target = $tok->{"value"};
        parser_advance($parser);
        parser_expect($parser, "SEMI");
        return ast_new_goto($target);
    }

    # switch ($expr) { case val { ... } default { ... } }
    if ($type eq "SWITCH") {
        parser_advance($parser);
        parser_expect($parser, "LPAREN");
        my scalar $switch_expr = parse_expression($parser);
        parser_expect($parser, "RPAREN");
        parser_expect($parser, "LBRACE");

        my scalar $switch_node = ast_new_switch($switch_expr);

        while (!parser_check($parser, "RBRACE") && !parser_check($parser, "EOF")) {
            my scalar $case_tok = parser_current($parser);
            my str $case_type = $case_tok->{"type"};

            if ($case_type eq "CASE") {
                parser_advance($parser);
                my scalar $case_expr = parse_case_value($parser);
                my scalar $case_block = parse_block($parser);
                ast_add_case($switch_node, $case_expr, $case_block);
            } elsif ($case_type eq "DEFAULT") {
                parser_advance($parser);
                my scalar $default_block = parse_block($parser);
                $switch_node->{"default_block"} = $default_block;
                $switch_node->{"has_default"} = 1;
            } else {
                parser_error($parser, "expected 'case' or 'default' in switch statement");
            }
        }

        parser_expect($parser, "RBRACE");
        return $switch_node;
    }

    # Expression statement
    my scalar $expr = parse_expression($parser);
    parser_expect($parser, "SEMI");
    return ast_new_expr_stmt($expr);
}

# ============================================================
# Function and Program Parsing
# ============================================================

func is_c_keyword(str $name) int {
    if ($name eq "for") { return 1; }
    if ($name eq "while") { return 1; }
    if ($name eq "if") { return 1; }
    if ($name eq "else") { return 1; }
    if ($name eq "switch") { return 1; }
    if ($name eq "case") { return 1; }
    if ($name eq "default") { return 1; }
    if ($name eq "break") { return 1; }
    if ($name eq "continue") { return 1; }
    if ($name eq "return") { return 1; }
    if ($name eq "goto") { return 1; }
    if ($name eq "next") { return 1; }
    if ($name eq "last") { return 1; }
    if ($name eq "foreach") { return 1; }
    if ($name eq "try") { return 1; }
    if ($name eq "catch") { return 1; }
    if ($name eq "throw") { return 1; }
    if ($name eq "elsif") { return 1; }
    if ($name eq "my") { return 1; }
    if ($name eq "use") { return 1; }
    if ($name eq "package") { return 1; }
    if ($name eq "version") { return 1; }
    if ($name eq "do") { return 1; }
    if ($name eq "int") { return 1; }
    if ($name eq "char") { return 1; }
    if ($name eq "float") { return 1; }
    if ($name eq "double") { return 1; }
    if ($name eq "void") { return 1; }
    if ($name eq "long") { return 1; }
    if ($name eq "short") { return 1; }
    if ($name eq "unsigned") { return 1; }
    if ($name eq "signed") { return 1; }
    if ($name eq "const") { return 1; }
    if ($name eq "static") { return 1; }
    if ($name eq "extern") { return 1; }
    if ($name eq "register") { return 1; }
    if ($name eq "volatile") { return 1; }
    if ($name eq "auto") { return 1; }
    if ($name eq "struct") { return 1; }
    if ($name eq "union") { return 1; }
    if ($name eq "enum") { return 1; }
    if ($name eq "typedef") { return 1; }
    if ($name eq "sizeof") { return 1; }
    if ($name eq "inline") { return 1; }
    if ($name eq "restrict") { return 1; }
    return 0;
}

func parse_function(scalar $parser) scalar {
    my int $func_line = parser_current_line($parser);
    parser_expect($parser, "FUNC");

    my scalar $name_tok = parser_current($parser);
    my str $func_name = "";
    # Accept keyword tokens that users might try to use as function names
    if (parser_check($parser, "NEXT")) {
        $func_name = "next";
        parser_advance($parser);
    } elsif (parser_check($parser, "LAST")) {
        $func_name = "last";
        parser_advance($parser);
    } elsif (parser_check($parser, "GOTO")) {
        $func_name = "goto";
        parser_advance($parser);
    } elsif (parser_check($parser, "FOREACH")) {
        $func_name = "foreach";
        parser_advance($parser);
    } elsif (parser_check($parser, "TRY")) {
        $func_name = "try";
        parser_advance($parser);
    } elsif (parser_check($parser, "CATCH")) {
        $func_name = "catch";
        parser_advance($parser);
    } elsif (parser_check($parser, "THROW")) {
        $func_name = "throw";
        parser_advance($parser);
    } elsif (parser_check($parser, "ELSIF")) {
        $func_name = "elsif";
        parser_advance($parser);
    } elsif (parser_check($parser, "MY")) {
        $func_name = "my";
        parser_advance($parser);
    } elsif (parser_check($parser, "USE")) {
        $func_name = "use";
        parser_advance($parser);
    } elsif (parser_check($parser, "PACKAGE")) {
        $func_name = "package";
        parser_advance($parser);
    } elsif (parser_check($parser, "VERSION")) {
        $func_name = "version";
        parser_advance($parser);
    } else {
        parser_expect($parser, "IDENT");
        $func_name = $name_tok->{"value"};
    }

    # Check for C keywords - they can't be used as function names
    if (is_c_keyword($func_name) == 1) {
        parser_error($parser, "'" . $func_name . "' is a keyword and cannot be used as a function name");
    }

    parser_expect($parser, "LPAREN");

    # Create function node with dummy return type for now
    my scalar $fn = ast_new_function($func_name, TYPE_VOID());
    ast_set_line($fn, $func_line);
    
    # Parse parameters
    if (!parser_check($parser, "RPAREN")) {
        while (1) {
            # Check for variadic parameter (...)
            my int $is_variadic = 0;
            if (parser_check($parser, "ELLIPSIS")) {
                parser_advance($parser);
                $is_variadic = 1;
                $fn->{"is_variadic"} = 1;
            }
            
            my int $param_type = parse_type($parser);
            my str $param_type_name = $parser->{"last_type_name"};
            
            # Get sigil
            my scalar $sigil_tok = parser_current($parser);
            my str $sigil = "$";
            if ($sigil_tok->{"type"} eq "DOLLAR") {
                $sigil = "$";
                parser_advance($parser);
            } elsif ($sigil_tok->{"type"} eq "AT") {
                $sigil = "@";
                parser_advance($parser);
            } elsif ($sigil_tok->{"type"} eq "PERCENT") {
                $sigil = "%";
                parser_advance($parser);
            }
            
            my scalar $pname_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            
            my scalar $param = ast_new_param($pname_tok->{"value"}, $param_type, $sigil);
            $param->{"is_variadic"} = $is_variadic;
            
            # Store struct type name if applicable
            if ($param_type == TYPE_STRUCT()) {
                $param->{"type_name"} = $param_type_name;
            }
            
            # Check for default value
            if (parser_check($parser, "ASSIGN")) {
                parser_advance($parser);
                my scalar $default_val = parse_expression($parser);
                $param->{"default"} = $default_val;
                $param->{"has_default"} = 1;
            } else {
                $param->{"has_default"} = 0;
            }
            
            ast_add_param($fn, $param);
            
            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
            } else {
                parser_expect($parser, "RPAREN");
                last;
            }
        }
    } else {
        parser_advance($parser);  # Skip )
    }
    
    # Parse return type
    my int $ret_type = parse_type($parser);
    $fn->{"return_type"} = $ret_type;
    
    # Parse body
    $fn->{"body"} = parse_block($parser);
    
    return $fn;
}

# Parse extern function declaration or definition
func parse_extern_function(scalar $parser) scalar {
    parser_expect($parser, "EXTERN");
    parser_expect($parser, "FUNC");
    
    my scalar $name_tok = parser_current($parser);
    parser_expect($parser, "IDENT");
    
    my scalar $fn = ast_new_extern_func($name_tok->{"value"});
    
    parser_expect($parser, "LPAREN");
    
    # Parse parameters
    if (!parser_check($parser, "RPAREN")) {
        while (1) {
            my int $param_type = parse_type($parser);
            
            # Get sigil
            my str $sigil = "$";
            if (parser_check($parser, "DOLLAR")) {
                parser_advance($parser);
            } elsif (parser_check($parser, "AT")) {
                $sigil = "@";
                parser_advance($parser);
            } elsif (parser_check($parser, "PERCENT")) {
                $sigil = "%";
                parser_advance($parser);
            }
            
            my scalar $pname_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            
            my scalar $param = ast_new_param($pname_tok->{"value"}, $param_type, $sigil);
            ast_add_param($fn, $param);
            
            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
            } else {
                parser_expect($parser, "RPAREN");
                last;
            }
        }
    } else {
        parser_advance($parser);
    }
    
    # Parse return type
    my int $ret_type = parse_type($parser);
    $fn->{"return_type"} = $ret_type;
    
    # Check if this is a declaration (;) or definition ({...})
    if (parser_check($parser, "SEMI")) {
        parser_advance($parser);
        $fn->{"has_body"} = 0;
    } else {
        # Has a body - parse it
        $fn->{"body"} = parse_block($parser);
        $fn->{"has_body"} = 1;
    }
    
    return $fn;
}

# Parse struct definition
func parse_struct(scalar $parser) scalar {
    my int $struct_line = parser_current_line($parser);
    parser_expect($parser, "STRUCT");

    my scalar $name_tok = parser_current($parser);
    parser_expect($parser, "IDENT");

    my scalar $st = ast_new_struct($name_tok->{"value"});
    ast_set_line($st, $struct_line);

    parser_expect($parser, "LBRACE");
    
    while (!parser_check($parser, "RBRACE")) {
        # Fields in structs don't have sigils: "int x;" not "int $x;"
        my int $field_type = parse_type($parser);
        
        my scalar $field_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        
        ast_add_field($st, $field_tok->{"value"}, $field_type, "$");
        
        parser_expect($parser, "SEMI");
    }
    
    parser_expect($parser, "RBRACE");
    
    return $st;
}

# Parse package declaration
func parse_package(scalar $parser, scalar $program) void {
    parser_expect($parser, "PACKAGE");
    
    my str $pkg_name = "";
    my scalar $tok = parser_current($parser);
    parser_expect($parser, "IDENT");
    $pkg_name = $tok->{"value"};
    
    # Handle Package::Name syntax
    while (parser_check($parser, "DOUBLE_COLON")) {
        parser_advance($parser);
        my scalar $next_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $pkg_name = $pkg_name . "::" . $next_tok->{"value"};
    }
    
    parser_expect($parser, "SEMI");

    $program->{"package"} = $pkg_name;
}

# Parse version declaration: version "x.y.z";
func parse_version(scalar $parser, scalar $program) void {
    parser_expect($parser, "VERSION");

    my scalar $tok = parser_current($parser);
    parser_expect($parser, "STR_LITERAL");
    my str $ver = $tok->{"value"};

    parser_expect($parser, "SEMI");

    $program->{"version"} = $ver;
}

# Parse inherit statement (top-level inheritance declaration)
# Supports: inherit Parent; or inherit Parent1, Parent2, Parent3;
func parse_inherit(scalar $parser, scalar $program) void {
    parser_expect($parser, "INHERIT");

    # Parse first parent
    my str $parent_name = "";
    my scalar $tok = parser_current($parser);
    parser_expect($parser, "IDENT");
    $parent_name = $tok->{"value"};

    # Handle Parent::Name syntax
    while (parser_check($parser, "DOUBLE_COLON")) {
        parser_advance($parser);
        my scalar $next_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $parent_name = $parent_name . "::" . $next_tok->{"value"};
    }

    ast_add_inherit($program, $parent_name);

    # Parse additional parents (comma-separated)
    while (parser_check($parser, "COMMA")) {
        parser_advance($parser);

        $parent_name = "";
        $tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $parent_name = $tok->{"value"};

        # Handle Parent::Name syntax
        while (parser_check($parser, "DOUBLE_COLON")) {
            parser_advance($parser);
            my scalar $next_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            $parent_name = $parent_name . "::" . $next_tok->{"value"};
        }

        ast_add_inherit($program, $parent_name);
    }

    parser_expect($parser, "SEMI");
}

# Convert module name to file path (POSIX -> POSIX.strada, File::IO -> File/IO.strada)
func module_to_path(str $mod_name) str {
    my str $path = "";
    my int $i = 0;
    my int $len = length($mod_name);
    while ($i < $len) {
        my str $ch = substr($mod_name, $i, 1);
        if ($ch eq ":") {
            # Skip the second colon
            $i = $i + 1;
            $path = $path . "/";
        } else {
            $path = $path . $ch;
        }
        $i = $i + 1;
    }
    return $path . ".strada";
}

# Find module file in lib paths
func find_module_file(scalar $program, str $mod_name) str {
    my str $rel_path = module_to_path($mod_name);
    my scalar $lib_paths = $program->{"lib_paths"};
    my int $i = 0;
    my int $count = $program->{"lib_path_count"};

    while ($i < $count) {
        my str $lib_path = $lib_paths->[$i];
        my str $full_path = $lib_path . "/" . $rel_path;
        # Try to read the file - if it works, file exists
        my str $content = slurp($full_path);
        if (length($content) > 0) {
            return $full_path;
        }
        $i = $i + 1;
    }

    return "";
}

# Load and parse a module, merging its functions into the program
func load_module(scalar $program, str $mod_name, str $file_path) void {
    # Read the module source
    my str $source = slurp($file_path);
    if (length($source) == 0) {
        return;
    }

    # Lex the module
    my scalar $tokens = lex_tokenize($source);

    # Parse the module
    my scalar $mod_parser = parser_new($tokens);
    my scalar $mod_program = ast_new_program();

    # Parse the module's contents
    while (!parser_check($mod_parser, "EOF")) {
        if (parser_check($mod_parser, "FUNC")) {
            my scalar $fn = parse_function($mod_parser);
            ast_add_function($mod_program, $fn);
        } elsif (parser_check($mod_parser, "PACKAGE")) {
            parse_package($mod_parser, $mod_program);
        } elsif (parser_check($mod_parser, "VERSION")) {
            parse_version($mod_parser, $mod_program);
        } elsif (parser_check($mod_parser, "STRUCT")) {
            my scalar $st = parse_struct($mod_parser);
            ast_add_struct($mod_program, $st);
        } elsif (parser_check($mod_parser, "HASH")) {
            # Skip comments that look like hash
            parser_advance($mod_parser);
        } else {
            # Skip other tokens (comments, etc)
            parser_advance($mod_parser);
        }
    }

    # Get the package name from the module (defaults to module name)
    my str $pkg_name = $mod_program->{"package"};
    if (length($pkg_name) == 0) {
        $pkg_name = $mod_name;
    }

    # Merge functions into main program with package prefix
    my scalar $mod_funcs = $mod_program->{"functions"};
    my int $i = 0;
    my int $count = $mod_program->{"function_count"};

    while ($i < $count) {
        my scalar $fn = $mod_funcs->[$i];
        my str $fn_name = $fn->{"name"};

        # Store original name and package
        $fn->{"original_name"} = $fn_name;
        $fn->{"package"} = $pkg_name;

        # Create qualified name version
        $fn->{"name"} = $pkg_name . "::" . $fn_name;

        # Add qualified version to main program
        ast_add_function($program, $fn);

        $i = $i + 1;
    }

    # Merge structs
    my scalar $mod_structs = $mod_program->{"structs"};
    $i = 0;
    $count = $mod_program->{"struct_count"};
    while ($i < $count) {
        my scalar $st = $mod_structs->[$i];
        ast_add_struct($program, $st);
        $i = $i + 1;
    }
}

# Parse use statement
func parse_use(scalar $parser, scalar $program) void {
    parser_expect($parser, "USE");

    my str $mod_name = "";
    my scalar $tok = parser_current($parser);

    # Check if it's a string path or identifier
    if ($tok->{"type"} eq "STR_LITERAL") {
        $mod_name = $tok->{"value"};
        parser_advance($parser);
    } else {
        parser_expect($parser, "IDENT");
        $mod_name = $tok->{"value"};

        # Check for "use lib" pattern followed by string
        if ($mod_name eq "lib") {
            if (parser_check($parser, "STR_LITERAL")) {
                my scalar $path_tok = parser_current($parser);
                my str $lib_path = $path_tok->{"value"};
                parser_advance($parser);
                # Store the lib path
                ast_add_lib_path($program, $lib_path);
            }
            parser_expect($parser, "SEMI");
            ast_add_use($program, "lib");
            return;
        }

        # Handle Module::Name syntax
        while (parser_check($parser, "DOUBLE_COLON")) {
            parser_advance($parser);
            my scalar $next_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            $mod_name = $mod_name . "::" . $next_tok->{"value"};
        }

        # Check for qw() import list
        if (parser_check($parser, "IDENT")) {
            my scalar $qw_tok = parser_current($parser);
            if ($qw_tok->{"value"} eq "qw") {
                parser_advance($parser);
                parser_expect($parser, "LPAREN");
                # Collect the import list
                while (!parser_check($parser, "RPAREN")) {
                    if (parser_check($parser, "IDENT")) {
                        my scalar $import_tok = parser_current($parser);
                        ast_add_import($program, $import_tok->{"value"});
                    }
                    parser_advance($parser);
                }
                parser_expect($parser, "RPAREN");
            }
        }
    }

    parser_expect($parser, "SEMI");

    # Check if module already loaded
    if (ast_is_module_loaded($program, $mod_name)) {
        ast_add_use($program, $mod_name);
        return;
    }

    # Try to find and load the module
    my str $file_path = find_module_file($program, $mod_name);
    if (length($file_path) > 0) {
        ast_mark_module_loaded($program, $mod_name);
        load_module($program, $mod_name, $file_path);
    }

    ast_add_use($program, $mod_name);
}

# Parse import_lib statement - import shared library as module
# import_lib "libname";  -> loads libname.so and reads metadata from __strada_export_info()
func parse_import_lib(scalar $parser, scalar $program) void {
    parser_expect($parser, "IMPORT_LIB");

    # Get the library name (must be a string)
    my scalar $tok = parser_current($parser);
    if ($tok->{"type"} ne "STR_LITERAL") {
        parser_error($parser, "import_lib requires a string library name");
    }
    my str $lib_name = $tok->{"value"};
    parser_advance($parser);

    parser_expect($parser, "SEMI");

    # Find the .so file in lib paths
    my str $so_path = find_so_file($program, $lib_name);
    if (length($so_path) == 0) {
        parser_error($parser, "cannot find shared library: " . $lib_name . ".so");
    }

    # Load the .so file and get metadata using runtime functions
    my scalar $lib_handle = strada_dl_open_raw($so_path);
    my int $lib_handle_int = $lib_handle;
    if ($lib_handle_int == 0) {
        parser_error($parser, "failed to load shared library: " . $so_path);
    }

    # Get the __strada_export_info function
    my scalar $export_fn = strada_dl_sym_raw($lib_handle, "__strada_export_info");
    my int $export_fn_int = $export_fn;
    if ($export_fn_int == 0) {
        strada_dl_close_raw($lib_handle);
        parser_error($parser, "library missing __strada_export_info: " . $so_path . " (was it compiled with a recent strada compiler?)");
    }

    # Call __strada_export_info to get metadata string
    my str $metadata = strada_dl_call_export_info($export_fn);
    strada_dl_close_raw($lib_handle);

    if (length($metadata) == 0) {
        parser_error($parser, "empty metadata from library: " . $so_path);
    }

    # Parse the metadata string to extract function signatures
    my scalar $lib_info = parse_export_metadata($lib_name, $so_path, $metadata);

    # Add to program
    ast_add_import_lib($program, $lib_info);
}

# Find .so file in lib paths
func find_so_file(scalar $program, str $lib_name) str {
    my str $so_name = $lib_name . ".so";
    my scalar $lib_paths = $program->{"lib_paths"};
    my int $i = 0;
    my int $count = $program->{"lib_path_count"};

    while ($i < $count) {
        my str $lib_path = $lib_paths->[$i];
        my str $full_path = $lib_path . "/" . $so_name;
        # Try to open the file to check if it exists
        my int $fd = sys::open_fd($full_path, "r");
        if ($fd > 0) {
            close_fd($fd);
            return $full_path;
        }
        $i = $i + 1;
    }

    return "";
}

# Parse export metadata string into lib_info structure
# Format: "func:name:return_type:param_count:param_types\n" for each function
# Note: Bootstrap compiler doesn't support scalar(@array), so we parse manually
func parse_export_metadata(str $lib_name, str $so_path, str $metadata) scalar {
    my hash %lib_info = ();
    $lib_info{"lib_name"} = $lib_name;
    $lib_info{"pkg_name"} = $lib_name;
    $lib_info{"so_path"} = $so_path;

    my array @functions = ();
    my int $fn_count = 0;

    # Parse metadata line by line manually (bootstrap doesn't support split well)
    my int $meta_len = length($metadata);
    my int $pos = 0;

    while ($pos < $meta_len) {
        # Extract one line
        my str $line = "";
        while ($pos < $meta_len) {
            my str $ch = substr($metadata, $pos, 1);
            $pos = $pos + 1;
            if ($ch eq "\n") {
                last;
            }
            $line = $line . $ch;
        }

        if (length($line) > 0) {
            # Parse: func:name:return_type:param_count:param_types
            my scalar $fn_info = parse_export_line($line);
            if ($fn_info != 0) {
                push(@functions, $fn_info);
                $fn_count = $fn_count + 1;
            }
        }
    }

    $lib_info{"functions"} = \@functions;
    $lib_info{"function_count"} = $fn_count;

    return \%lib_info;
}

# Parse a single export metadata line
# Format: func:name:return_type:param_count:param_types
func parse_export_line(str $line) scalar {
    # Extract fields by finding colons
    my int $len = length($line);
    my int $pos = 0;
    my int $field_num = 0;
    my str $kind = "";
    my str $fn_name = "";
    my str $ret_str = "";
    my str $param_count_str = "";
    my str $param_types_str = "";

    my str $current = "";
    while ($pos <= $len) {
        my str $ch = "";
        if ($pos < $len) {
            $ch = substr($line, $pos, 1);
        }
        if ($ch eq ":" || $pos == $len) {
            if ($field_num == 0) {
                $kind = $current;
            } elsif ($field_num == 1) {
                $fn_name = $current;
            } elsif ($field_num == 2) {
                $ret_str = $current;
            } elsif ($field_num == 3) {
                $param_count_str = $current;
            } elsif ($field_num == 4) {
                $param_types_str = $current;
            }
            $current = "";
            $field_num = $field_num + 1;
        } else {
            $current = $current . $ch;
        }
        $pos = $pos + 1;
    }

    # Only process "func" entries
    if ($kind ne "func") {
        return 0;
    }

    my int $param_count = 0;
    if (length($param_count_str) > 0) {
        $param_count = str_to_int($param_count_str);
    }

    my hash %fn_info = ();
    $fn_info{"name"} = $fn_name;
    $fn_info{"original_name"} = $fn_name;
    my int $ret_type = export_str_to_type($ret_str);
    $fn_info{"return_type"} = $ret_type;
    $fn_info{"param_count"} = $param_count;

    # Parse parameter types
    my array @params = ();
    if ($param_count > 0 && length($param_types_str) > 0) {
        my int $ppos = 0;
        my int $plen = length($param_types_str);
        my int $pnum = 0;
        my str $ptype = "";

        while ($ppos <= $plen && $pnum < $param_count) {
            my str $pch = "";
            if ($ppos < $plen) {
                $pch = substr($param_types_str, $ppos, 1);
            }
            if ($pch eq "," || $ppos == $plen) {
                my hash %param = ();
                $param{"name"} = "arg" . $pnum;
                $param{"param_type"} = export_str_to_type($ptype);
                $param{"sigil"} = "$";
                push(@params, \%param);
                $ptype = "";
                $pnum = $pnum + 1;
            } else {
                $ptype = $ptype . $pch;
            }
            $ppos = $ppos + 1;
        }
    }
    $fn_info{"params"} = \@params;

    return \%fn_info;
}

# Convert string to integer (bootstrap-compatible)
func str_to_int(str $s) int {
    my int $result = 0;
    my int $i = 0;
    my int $len = length($s);
    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        if ($ch ge "0" && $ch le "9") {
            $result = $result * 10 + (ord($ch) - ord("0"));
        }
        $i = $i + 1;
    }
    return $result;
}

# Convert export string to type constant
func export_str_to_type(str $type_str) int {
    if ($type_str eq "int") { return TYPE_INT(); }
    if ($type_str eq "num") { return TYPE_NUM(); }
    if ($type_str eq "str") { return TYPE_STR(); }
    if ($type_str eq "array") { return TYPE_ARRAY(); }
    if ($type_str eq "hash") { return TYPE_HASH(); }
    if ($type_str eq "scalar") { return TYPE_SCALAR(); }
    if ($type_str eq "void") { return TYPE_VOID(); }
    # Explicit sized types for extern functions (C interop)
    if ($type_str eq "int32") { return TYPE_INT32(); }
    if ($type_str eq "int64") { return TYPE_INT64(); }
    if ($type_str eq "float32") { return TYPE_FLOAT32(); }
    if ($type_str eq "float64") { return TYPE_FLOAT64(); }
    return TYPE_SCALAR();
}

func parse_program(scalar $parser, scalar $lib_paths, scalar $lib_paths_low) scalar {
    my scalar $program = ast_new_program();

    # Add command-line library paths first (high priority - before any use statements)
    my int $path_count = size($lib_paths);
    my int $path_i = 0;
    while ($path_i < $path_count) {
        my str $path = $lib_paths->[$path_i];
        ast_add_lib_path($program, $path);
        $path_i = $path_i + 1;
    }

    # Store low-priority paths to add after parsing
    my int $low_path_count = size($lib_paths_low);

    while (!parser_check($parser, "EOF")) {
        if (parser_check($parser, "FUNC")) {
            my scalar $fn = parse_function($parser);
            # Auto-prefix function names with package name when inside a simple package
            # (single-word packages like "Animal", not module-style "Math::Utils")
            my str $pkg = $program->{"package"};
            my str $fn_name = $fn->{"name"};
            # Store the package in the function node for OOP registration
            $fn->{"package"} = $pkg;
            # Only auto-prefix for simple single-word packages (no :: in name)
            my int $pkg_colon_idx = index($pkg, "::");
            if (length($pkg) > 0 && $pkg ne "main" && $fn_name ne "main" && $pkg_colon_idx < 0) {
                # Check if function already has the package prefix
                my str $prefix = $pkg . "_";
                my int $prefix_len = length($prefix);
                if (length($fn_name) < $prefix_len || substr($fn_name, 0, $prefix_len) ne $prefix) {
                    # Always prefix functions in a package
                    $fn->{"name"} = $pkg . "_" . $fn_name;
                }
            }
            ast_add_function($program, $fn);
        } elsif (parser_check($parser, "EXTERN")) {
            my scalar $fn = parse_extern_function($parser);
            # Do NOT auto-prefix extern function names - they link to external C functions
            # with specific names that must not be modified
            my str $pkg = $program->{"package"};
            $fn->{"package"} = $pkg;
            ast_add_function($program, $fn);
        } elsif (parser_check($parser, "STRUCT")) {
            my scalar $st = parse_struct($parser);
            ast_add_struct($program, $st);
        } elsif (parser_check($parser, "PACKAGE")) {
            parse_package($parser, $program);
        } elsif (parser_check($parser, "VERSION")) {
            parse_version($parser, $program);
        } elsif (parser_check($parser, "INHERIT")) {
            parse_inherit($parser, $program);
        } elsif (parser_check($parser, "USE")) {
            parse_use($parser, $program);
        } elsif (parser_check($parser, "IMPORT_LIB")) {
            parse_import_lib($parser, $program);
        } elsif (parser_check($parser, "MY")) {
            my scalar $var = parse_var_decl($parser);
            ast_add_global($program, $var);
        } else {
            parser_error($parser, "expected function, extern, struct, package, inherit, use, import_lib, or variable declaration");
        }
    }

    # Add low-priority library paths last (after all use lib statements)
    $path_i = 0;
    while ($path_i < $low_path_count) {
        my str $path = $lib_paths_low->[$path_i];
        ast_add_lib_path($program, $path);
        $path_i = $path_i + 1;
    }

    return $program;
}

# ============================================================
# Main Entry Point
# ============================================================

func parse(scalar $tokens, str $filename) scalar {
    my scalar $parser = parser_new($tokens);
    parser_set_filename($parser, $filename);
    my array @empty_paths = ();
    my array @empty_paths_low = ();
    return parse_program($parser, \@empty_paths, \@empty_paths_low);
}

# Parse with pre-configured library paths (from -L and -LL command line options)
func parse_with_lib_paths(scalar $tokens, str $filename, scalar $lib_paths, scalar $lib_paths_low) scalar {
    my scalar $parser = parser_new($tokens);
    parser_set_filename($parser, $filename);
    return parse_program($parser, $lib_paths, $lib_paths_low);
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# Semantic.strada - Semantic analysis and validation for Strada compiler
# Performs symbol table building, type checking, and validation

# ============================================================
# Error Reporting
# ============================================================

func semantic_error(str $msg, int $line) void {
    if ($line > 0) {
        die("error: " . $msg . " at line " . $line);
    } else {
        die("error: " . $msg);
    }
}

func semantic_warn(str $msg, int $line) void {
    if ($line > 0) {
        warn("warning: " . $msg . " at line " . $line);
    } else {
        warn("warning: " . $msg);
    }
}

# Check if a node is valid (has a type field)
# This works around the issue where != 0 doesn't work for hash references
func is_valid_node(scalar $node) int {
    my int $node_type = $node->{"type"};
    if ($node_type > 0) {
        return 1;
    }
    return 0;
}

# ============================================================
# Scope Management
# ============================================================

# Create a new scope with optional parent
func scope_new(scalar $parent) scalar {
    my hash %scope = ();
    my hash %vars = ();
    my array @var_names = ();
    $scope{"is_scope"} = 1;  # Marker to identify valid scopes
    $scope{"parent"} = $parent;
    $scope{"vars"} = \%vars;
    $scope{"var_names"} = \@var_names;
    $scope{"var_count"} = 0;
    return \%scope;
}

# Add a variable to the current scope
func scope_add_var(scalar $scope, str $name, str $sigil, int $var_type, int $line) void {
    my scalar $vars = $scope->{"vars"};
    my hash %info = ();
    $info{"sigil"} = $sigil;
    $info{"type"} = $var_type;
    $info{"line"} = $line;
    $info{"used"} = 0;
    $vars->{$name} = \%info;

    # Track variable name for iteration
    my scalar $var_names = $scope->{"var_names"};
    my int $count = $scope->{"var_count"};
    $var_names->[$count] = $name;
    $scope->{"var_count"} = $count + 1;
}

# Check if a scope is valid
func is_valid_scope(scalar $scope) int {
    my int $is_s = $scope->{"is_scope"};
    if ($is_s == 1) {
        return 1;
    }
    return 0;
}

# Look up a variable in scope chain
# Returns a hash with "found" = 1 and "info" = var_info if found
# Returns a hash with "found" = 0 if not found
func scope_lookup_var(scalar $scope, str $name) scalar {
    my hash %result = ();
    my scalar $current = $scope;
    while (is_valid_scope($current) == 1) {
        my scalar $vars = $current->{"vars"};
        my scalar $var_info = $vars->{$name};
        if (is_valid_node($var_info) == 1) {
            $result{"found"} = 1;
            $result{"info"} = $var_info;
            return \%result;
        }
        $current = $current->{"parent"};
    }
    $result{"found"} = 0;
    return \%result;
}

# Mark a variable as used
func scope_mark_used(scalar $scope, str $name) void {
    my scalar $current = $scope;
    while (is_valid_scope($current) == 1) {
        my scalar $vars = $current->{"vars"};
        my scalar $var_info = $vars->{$name};
        if (is_valid_node($var_info) == 1) {
            $var_info->{"used"} = 1;
            return;
        }
        $current = $current->{"parent"};
    }
}

# Check for unused variables in scope and warn (if warnings enabled)
func scope_check_unused(scalar $ctx, scalar $scope) void {
    my int $show_warnings = $ctx->{"show_warnings"};
    if ($show_warnings == 0) {
        return;
    }
    my scalar $vars = $scope->{"vars"};
    my scalar $var_names = $scope->{"var_names"};
    my int $count = $scope->{"var_count"};
    for (my int $i = 0; $i < $count; $i = $i + 1) {
        my str $name = $var_names->[$i];
        my scalar $info = $vars->{$name};
        if ($info->{"used"} == 0) {
            semantic_warn("unused variable '$" . $name . "'", $info->{"line"});
        }
    }
}

# ============================================================
# Builtin Function Registry
# ============================================================

func get_builtins() scalar {
    my hash %b = ();

    # ============================================================
    # CORE LANGUAGE FUNCTIONS (stay unqualified)
    # ============================================================

    # I/O functions
    $b{"say"} = 1;
    $b{"print"} = 1;
    $b{"printf"} = 1;
    $b{"sprintf"} = 1;
    $b{"warn"} = 1;
    $b{"die"} = 1;
    $b{"throw"} = 1;
    $b{"readline"} = 1;
    $b{"slurp"} = 1;  # Also sys::slurp
    $b{"spew"} = 1;   # Also sys::spew
    $b{"write_fd"} = 1;
    $b{"close_fd"} = 1;
    $b{"getpid"} = 1;
    $b{"unlink"} = 1;

    # String functions
    $b{"length"} = 1;
    $b{"bytes"} = 1;
    $b{"char_at"} = 1;  # Fast char access by byte index
    $b{"substr"} = 1;
    $b{"substr_bytes"} = 1;  # Byte-level substr
    $b{"index"} = 1;
    $b{"rindex"} = 1;
    $b{"uc"} = 1;
    $b{"lc"} = 1;
    $b{"upper"} = 1;
    $b{"lower"} = 1;
    $b{"ucfirst"} = 1;
    $b{"lcfirst"} = 1;
    $b{"trim"} = 1;
    $b{"ltrim"} = 1;
    $b{"rtrim"} = 1;
    $b{"chomp"} = 1;
    $b{"chop"} = 1;
    $b{"chr"} = 1;
    $b{"ord"} = 1;
    $b{"reverse"} = 1;
    $b{"repeat"} = 1;
    $b{"join"} = 1;
    $b{"split"} = 1;

    # Array functions
    $b{"push"} = 1;
    $b{"pop"} = 1;
    $b{"shift"} = 1;
    $b{"unshift"} = 1;
    $b{"size"} = 1;
    $b{"sort"} = 1;
    $b{"nsort"} = 1;
    $b{"splice"} = 1;
    $b{"reserve"} = 1;

    # Hash functions
    $b{"keys"} = 1;
    $b{"values"} = 1;
    $b{"exists"} = 1;
    $b{"delete"} = 1;
    $b{"each"} = 1;
    $b{"hash_new"} = 1;
    $b{"hash_get"} = 1;
    $b{"hash_set"} = 1;

    # Type functions
    $b{"defined"} = 1;
    $b{"typeof"} = 1;
    $b{"ref"} = 1;
    $b{"reftype"} = 1;
    $b{"is_ref"} = 1;
    $b{"cast_int"} = 1;
    $b{"cast_num"} = 1;
    $b{"cast_str"} = 1;
    $b{"int"} = 1;

    # Reference functions
    $b{"clone"} = 1;
    $b{"deref"} = 1;
    $b{"deref_array"} = 1;
    $b{"deref_hash"} = 1;
    $b{"deref_set"} = 1;
    $b{"refto"} = 1;
    $b{"is_refto"} = 1;
    $b{"derefto"} = 1;

    # Regex
    $b{"match"} = 1;
    $b{"replace"} = 1;
    $b{"replace_all"} = 1;
    $b{"capture"} = 1;
    $b{"captures"} = 1;

    # Control flow
    $b{"exit"} = 1;

    # Debug
    $b{"dumper"} = 1;
    $b{"dumper_str"} = 1;
    $b{"dump"} = 1;
    $b{"stacktrace"} = 1;
    $b{"stacktrace_str"} = 1;
    $b{"caller"} = 1;

    # Misc
    $b{"scalar"} = 1;
    $b{"undef"} = 1;
    $b{"refcount"} = 1;
    $b{"strada_new_undef"} = 1;

    # OOP - Blessed references
    $b{"bless"} = 1;
    $b{"blessed"} = 1;
    $b{"set_package"} = 1;
    $b{"inherit"} = 1;
    $b{"isa"} = 1;
    $b{"can"} = 1;
    $b{"UNIVERSAL::isa"} = 1;
    $b{"UNIVERSAL::can"} = 1;

    # ============================================================
    # math:: NAMESPACE
    # ============================================================

    $b{"math::sin"} = 1;
    $b{"math::cos"} = 1;
    $b{"math::tan"} = 1;
    $b{"math::asin"} = 1;
    $b{"math::acos"} = 1;
    $b{"math::atan"} = 1;
    $b{"math::atan2"} = 1;
    $b{"math::sinh"} = 1;
    $b{"math::cosh"} = 1;
    $b{"math::tanh"} = 1;
    $b{"math::log"} = 1;
    $b{"math::log10"} = 1;
    $b{"math::exp"} = 1;
    $b{"math::pow"} = 1;
    $b{"math::floor"} = 1;
    $b{"math::ceil"} = 1;
    $b{"math::round"} = 1;
    $b{"math::fabs"} = 1;
    $b{"math::fmod"} = 1;
    $b{"math::sqrt"} = 1;
    $b{"math::abs"} = 1;
    $b{"math::rand"} = 1;

    # ============================================================
    # sys:: NAMESPACE
    # ============================================================

    # sys:: File I/O
    $b{"sys::open"} = 1;
    $b{"sys::close"} = 1;
    $b{"sys::slurp"} = 1;
    $b{"sys::slurp_fh"} = 1;
    $b{"sys::slurp_fd"} = 1;
    $b{"sys::spew"} = 1;
    $b{"sys::spew_fh"} = 1;
    $b{"sys::spew_fd"} = 1;
    $b{"sys::fwrite"} = 1;
    $b{"sys::fread"} = 1;
    $b{"sys::seek"} = 1;
    $b{"sys::tell"} = 1;
    $b{"sys::rewind"} = 1;
    $b{"sys::eof"} = 1;
    $b{"sys::flush"} = 1;
    $b{"sys::readline"} = 1;

    # sys:: File system
    $b{"sys::unlink"} = 1;
    $b{"sys::link"} = 1;
    $b{"sys::symlink"} = 1;
    $b{"sys::readlink"} = 1;
    $b{"sys::rename"} = 1;
    $b{"sys::mkdir"} = 1;
    $b{"sys::rmdir"} = 1;
    $b{"sys::chdir"} = 1;
    $b{"sys::getcwd"} = 1;
    $b{"sys::chmod"} = 1;
    $b{"sys::access"} = 1;
    $b{"sys::umask"} = 1;
    $b{"sys::stat"} = 1;
    $b{"sys::lstat"} = 1;
    $b{"sys::readdir"} = 1;
    $b{"sys::readdir_full"} = 1;
    $b{"sys::is_dir"} = 1;
    $b{"sys::is_file"} = 1;
    $b{"sys::file_size"} = 1;
    $b{"sys::realpath"} = 1;
    $b{"sys::dirname"} = 1;
    $b{"sys::basename"} = 1;
    $b{"sys::file_ext"} = 1;
    $b{"sys::glob"} = 1;
    $b{"sys::fnmatch"} = 1;
    $b{"sys::path_join"} = 1;

    # StringBuilder functions for O(1) amortized string building
    $b{"sb_new"} = 1;
    $b{"sb_append"} = 1;
    $b{"sb_to_string"} = 1;
    $b{"sb_length"} = 1;
    $b{"sb_clear"} = 1;
    $b{"sb_free"} = 1;

    # sys:: Process
    $b{"sys::fork"} = 1;
    $b{"sys::exec"} = 1;
    $b{"sys::system"} = 1;
    $b{"sys::wait"} = 1;
    $b{"sys::waitpid"} = 1;
    $b{"sys::getpid"} = 1;
    $b{"sys::getppid"} = 1;
    $b{"sys::kill"} = 1;
    $b{"sys::alarm"} = 1;
    $b{"sys::signal"} = 1;
    $b{"sys::sleep"} = 1;
    $b{"sys::usleep"} = 1;
    $b{"sys::nanosleep"} = 1;
    $b{"sys::setprocname"} = 1;
    $b{"sys::getprocname"} = 1;
    $b{"sys::setproctitle"} = 1;
    $b{"sys::getproctitle"} = 1;
    $b{"sys::exit_status"} = 1;

    # thread:: Thread support
    $b{"thread::create"} = 1;
    $b{"thread::join"} = 1;
    $b{"thread::detach"} = 1;
    $b{"thread::self"} = 1;
    $b{"thread::mutex_new"} = 1;
    $b{"thread::mutex_lock"} = 1;
    $b{"thread::mutex_trylock"} = 1;
    $b{"thread::mutex_unlock"} = 1;
    $b{"thread::mutex_destroy"} = 1;
    $b{"thread::cond_new"} = 1;
    $b{"thread::cond_wait"} = 1;
    $b{"thread::cond_signal"} = 1;
    $b{"thread::cond_broadcast"} = 1;
    $b{"thread::cond_destroy"} = 1;

    # sys:: IPC
    $b{"sys::pipe"} = 1;
    $b{"sys::dup2"} = 1;
    $b{"sys::close_fd"} = 1;
    $b{"sys::read_fd"} = 1;
    $b{"sys::write_fd"} = 1;
    $b{"sys::read_all_fd"} = 1;

    # sys:: Environment
    $b{"sys::getenv"} = 1;
    $b{"sys::setenv"} = 1;
    $b{"sys::unsetenv"} = 1;

    # sys:: User/Group
    $b{"sys::getuid"} = 1;
    $b{"sys::geteuid"} = 1;
    $b{"sys::getgid"} = 1;
    $b{"sys::getegid"} = 1;

    # sys:: Time
    $b{"sys::time"} = 1;
    $b{"sys::localtime"} = 1;
    $b{"sys::gmtime"} = 1;
    $b{"sys::mktime"} = 1;
    $b{"sys::strftime"} = 1;
    $b{"sys::ctime"} = 1;
    $b{"sys::gettimeofday"} = 1;
    $b{"sys::hires_time"} = 1;
    $b{"sys::tv_interval"} = 1;
    $b{"sys::clock_gettime"} = 1;
    $b{"sys::clock_getres"} = 1;

    # sys:: Socket
    $b{"sys::socket_client"} = 1;
    $b{"sys::socket_server"} = 1;
    $b{"sys::socket_server_backlog"} = 1;
    $b{"sys::socket_accept"} = 1;
    $b{"sys::socket_recv"} = 1;
    $b{"sys::socket_send"} = 1;
    $b{"sys::socket_close"} = 1;
    $b{"sys::socket_select"} = 1;
    $b{"sys::socket_fd"} = 1;
    $b{"sys::select_fds"} = 1;

    # sys:: DNS/Network
    $b{"sys::gethostbyname"} = 1;
    $b{"sys::gethostbyname_all"} = 1;
    $b{"sys::gethostname"} = 1;
    $b{"sys::getaddrinfo"} = 1;

    # sys:: Error handling
    $b{"sys::isatty"} = 1;
    $b{"sys::strerror"} = 1;
    $b{"sys::errno"} = 1;

    # sys:: Memory
    $b{"sys::malloc"} = 1;
    $b{"sys::free"} = 1;
    $b{"sys::release"} = 1;

    # sys:: Struct functions (C interop)
    $b{"sys::cstruct_new"} = 1;
    $b{"sys::cstruct_get"} = 1;
    $b{"sys::cstruct_set"} = 1;
    $b{"sys::cstruct_ptr"} = 1;
    $b{"sys::cstruct_get_int"} = 1;
    $b{"sys::cstruct_get_num"} = 1;
    $b{"sys::cstruct_get_str"} = 1;
    $b{"sys::cstruct_get_ptr"} = 1;
    $b{"sys::cstruct_get_double"} = 1;
    $b{"sys::cstruct_get_string"} = 1;
    $b{"sys::cstruct_set_int"} = 1;
    $b{"sys::cstruct_set_num"} = 1;
    $b{"sys::cstruct_set_str"} = 1;
    $b{"sys::cstruct_set_ptr"} = 1;
    $b{"sys::cstruct_set_double"} = 1;
    $b{"sys::cstruct_set_string"} = 1;

    # sys:: Dynamic loading (FFI)
    $b{"sys::dl_open"} = 1;
    $b{"strada_dl_open_raw"} = 1;        # Internal: load .so and return handle directly
    $b{"strada_dl_sym_raw"} = 1;         # Internal: get symbol and return pointer directly
    $b{"strada_dl_close_raw"} = 1;       # Internal: close library
    $b{"strada_dl_call_export_info"} = 1; # Internal: call export info function
    $b{"sys::dl_sym"} = 1;
    $b{"sys::dl_close"} = 1;
    $b{"sys::dl_error"} = 1;
    $b{"sys::dl_call_int"} = 1;
    $b{"sys::dl_call_num"} = 1;
    $b{"sys::dl_call_str"} = 1;
    $b{"sys::dl_call_void"} = 1;
    $b{"sys::dl_call_int_sv"} = 1;
    $b{"sys::dl_call_str_sv"} = 1;
    $b{"sys::dl_call_void_sv"} = 1;
    $b{"sys::dl_call_sv"} = 1;
    $b{"sys::dl_call_export_info"} = 1;
    $b{"sys::dl_call_version"} = 1;

    # sys:: Pointer access for FFI
    $b{"sys::int_ptr"} = 1;
    $b{"sys::num_ptr"} = 1;
    $b{"sys::str_ptr"} = 1;
    $b{"sys::ptr_deref_int"} = 1;
    $b{"sys::ptr_deref_num"} = 1;
    $b{"sys::ptr_deref_str"} = 1;
    $b{"sys::ptr_set_int"} = 1;
    $b{"sys::ptr_set_num"} = 1;

    # sys:: System/process args
    $b{"sys::system_argv"} = 1;

    # ============================================================
    # NEW LIBC FUNCTIONS (Phase 1-3)
    # ============================================================

    # sys:: Additional File I/O
    $b{"sys::fgetc"} = 1;
    $b{"sys::fputc"} = 1;
    $b{"sys::fgets"} = 1;
    $b{"sys::fputs"} = 1;
    $b{"sys::ferror"} = 1;
    $b{"sys::fileno"} = 1;
    $b{"sys::clearerr"} = 1;

    # sys:: Temporary files
    $b{"sys::tmpfile"} = 1;
    $b{"sys::mkstemp"} = 1;
    $b{"sys::mkdtemp"} = 1;

    # sys:: Command execution (popen)
    $b{"sys::popen"} = 1;
    $b{"sys::pclose"} = 1;

    # sys:: Additional file system
    $b{"sys::truncate"} = 1;
    $b{"sys::ftruncate"} = 1;
    $b{"sys::chown"} = 1;
    $b{"sys::lchown"} = 1;
    $b{"sys::fchmod"} = 1;
    $b{"sys::fchown"} = 1;
    $b{"sys::utime"} = 1;
    $b{"sys::utimes"} = 1;

    # sys:: Session/process group control
    $b{"sys::setsid"} = 1;
    $b{"sys::getsid"} = 1;
    $b{"sys::setpgid"} = 1;
    $b{"sys::getpgid"} = 1;
    $b{"sys::getpgrp"} = 1;
    $b{"sys::setpgrp"} = 1;

    # sys:: User/group ID control
    $b{"sys::setuid"} = 1;
    $b{"sys::setgid"} = 1;
    $b{"sys::seteuid"} = 1;
    $b{"sys::setegid"} = 1;
    $b{"sys::setreuid"} = 1;
    $b{"sys::setregid"} = 1;

    # sys:: Additional socket operations
    $b{"sys::setsockopt"} = 1;
    $b{"sys::getsockopt"} = 1;
    $b{"sys::shutdown"} = 1;
    $b{"sys::getpeername"} = 1;
    $b{"sys::getsockname"} = 1;
    $b{"sys::inet_pton"} = 1;
    $b{"sys::inet_ntop"} = 1;
    $b{"sys::inet_addr"} = 1;
    $b{"sys::inet_ntoa"} = 1;
    $b{"sys::htons"} = 1;
    $b{"sys::htonl"} = 1;
    $b{"sys::ntohs"} = 1;
    $b{"sys::ntohl"} = 1;
    $b{"sys::poll"} = 1;

    # sys:: Random
    $b{"sys::srand"} = 1;
    $b{"sys::srandom"} = 1;
    $b{"sys::rand"} = 1;
    $b{"sys::random"} = 1;

    # sys:: Advanced signals
    $b{"sys::sigaction"} = 1;
    $b{"sys::sigprocmask"} = 1;
    $b{"sys::raise"} = 1;
    $b{"sys::killpg"} = 1;
    $b{"sys::pause"} = 1;
    $b{"sys::sigsuspend"} = 1;

    # sys:: User/Group database
    $b{"sys::getpwnam"} = 1;
    $b{"sys::getpwuid"} = 1;
    $b{"sys::getgrnam"} = 1;
    $b{"sys::getgrgid"} = 1;
    $b{"sys::getlogin"} = 1;
    $b{"sys::getgroups"} = 1;

    # sys:: Resource/Priority
    $b{"sys::nice"} = 1;
    $b{"sys::getpriority"} = 1;
    $b{"sys::setpriority"} = 1;
    $b{"sys::getrusage"} = 1;
    $b{"sys::getrlimit"} = 1;
    $b{"sys::setrlimit"} = 1;

    # sys:: Additional time functions
    $b{"sys::difftime"} = 1;
    $b{"sys::clock"} = 1;
    $b{"sys::times"} = 1;

    # sys:: Additional memory functions
    $b{"sys::calloc"} = 1;
    $b{"sys::realloc"} = 1;
    $b{"sys::mmap"} = 1;
    $b{"sys::munmap"} = 1;
    $b{"sys::mlock"} = 1;
    $b{"sys::munlock"} = 1;

    # sys:: String conversion
    $b{"sys::strtol"} = 1;
    $b{"sys::strtod"} = 1;
    $b{"sys::atoi"} = 1;
    $b{"sys::atof"} = 1;

    # sys:: Terminal/TTY
    $b{"sys::ttyname"} = 1;
    $b{"sys::tcgetattr"} = 1;
    $b{"sys::tcsetattr"} = 1;
    $b{"sys::cfgetospeed"} = 1;
    $b{"sys::cfsetospeed"} = 1;
    $b{"sys::cfgetispeed"} = 1;
    $b{"sys::cfsetispeed"} = 1;

    # sys:: Advanced file operations
    $b{"sys::fcntl"} = 1;
    $b{"sys::flock"} = 1;
    $b{"sys::ioctl"} = 1;
    $b{"sys::statvfs"} = 1;
    $b{"sys::fstatvfs"} = 1;
    $b{"sys::dup"} = 1;

    # sys:: Binary/Byte operations
    $b{"sys::ord_byte"} = 1;
    $b{"sys::get_byte"} = 1;
    $b{"sys::set_byte"} = 1;
    $b{"sys::byte_length"} = 1;
    $b{"sys::byte_substr"} = 1;
    $b{"sys::pack"} = 1;
    $b{"sys::unpack"} = 1;
    $b{"sys::base64_encode"} = 1;
    $b{"sys::base64_decode"} = 1;

    # ============================================================
    # math:: ADDITIONAL FUNCTIONS
    # ============================================================
    $b{"math::hypot"} = 1;
    $b{"math::cbrt"} = 1;
    $b{"math::isnan"} = 1;
    $b{"math::isinf"} = 1;
    $b{"math::isfinite"} = 1;
    $b{"math::fmax"} = 1;
    $b{"math::fmin"} = 1;
    $b{"math::copysign"} = 1;
    $b{"math::remainder"} = 1;
    $b{"math::trunc"} = 1;
    $b{"math::ldexp"} = 1;
    $b{"math::frexp"} = 1;
    $b{"math::modf"} = 1;
    $b{"math::scalbn"} = 1;

    return \%b;
}

# ============================================================
# Context Structure
# ============================================================

func ctx_new() scalar {
    my hash %ctx = ();
    my hash %funcs = ();
    my hash %structs = ();
    $ctx{"functions"} = \%funcs;
    $ctx{"structs"} = \%structs;
    $ctx{"builtins"} = get_builtins();
    $ctx{"scope"} = scope_new(0);
    $ctx{"current_func"} = 0;

    # Register built-in global variables: ARGV (array) and ARGC (int)
    my scalar $global_scope = $ctx{"scope"};
    scope_add_var($global_scope, "ARGV", "@", TYPE_ARRAY(), 0);
    scope_add_var($global_scope, "ARGC", "$", TYPE_INT(), 0);

    return \%ctx;
}

# ============================================================
# Registration Pass (First Pass)
# ============================================================

func register_functions(scalar $ctx, scalar $ast) void {
    my scalar $funcs = $ast->{"functions"};
    my int $count = $ast->{"function_count"};

    for (my int $i = 0; $i < $count; $i = $i + 1) {
        my scalar $fn = $funcs->[$i];
        my str $name = $fn->{"name"};
        my int $line = ast_get_line($fn);

        # Check for duplicate function
        my scalar $existing_fn = $ctx->{"functions"}->{$name};
        if ($existing_fn != 0) {
            semantic_error("function '" . $name . "' already defined", $line);
        }

        # Register function
        my hash %info = ();
        $info{"is_registered"} = 1;  # Marker to distinguish from unfound
        $info{"return_type"} = $fn->{"return_type"};
        $info{"param_count"} = $fn->{"param_count"};
        $info{"params"} = $fn->{"params"};
        $info{"is_extern"} = $fn->{"is_extern"};
        $info{"is_variadic"} = $fn->{"is_variadic"};
        $info{"line"} = $line;
        $ctx->{"functions"}->{$name} = \%info;
    }
}

func register_structs(scalar $ctx, scalar $ast) void {
    my scalar $structs = $ast->{"structs"};
    my int $count = $ast->{"struct_count"};

    for (my int $i = 0; $i < $count; $i = $i + 1) {
        my scalar $st = $structs->[$i];
        my str $name = $st->{"name"};
        my int $line = ast_get_line($st);

        # Check for duplicate struct
        my scalar $existing_st = $ctx->{"structs"}->{$name};
        my int $already_exists = $existing_st->{"is_registered"};
        if ($already_exists == 1) {
            semantic_error("struct '" . $name . "' already defined", $line);
        }

        # Build field map
        my hash %fields = ();
        my scalar $field_list = $st->{"fields"};
        my int $field_count = $st->{"field_count"};
        for (my int $j = 0; $j < $field_count; $j = $j + 1) {
            my scalar $field = $field_list->[$j];
            $fields{$field->{"name"}} = $field->{"field_type"};
        }

        # Register struct
        my hash %info = ();
        $info{"is_registered"} = 1;
        $info{"fields"} = \%fields;
        $info{"field_count"} = $field_count;
        $info{"line"} = $line;
        $ctx->{"structs"}->{$name} = \%info;
    }
}

# Register functions from import_lib statements
func register_import_lib_functions(scalar $ctx, scalar $ast) void {
    my int $lib_count = $ast->{"import_lib_count"};
    if ($lib_count == 0) {
        return;
    }

    my scalar $import_libs = $ast->{"import_libs"};

    for (my int $i = 0; $i < $lib_count; $i = $i + 1) {
        my scalar $lib_info = $import_libs->[$i];
        my scalar $lib_funcs = $lib_info->{"functions"};
        my int $fn_count = $lib_info->{"function_count"};

        for (my int $j = 0; $j < $fn_count; $j = $j + 1) {
            my scalar $fn_info = $lib_funcs->[$j];
            my str $name = $fn_info->{"name"};

            # Register function (skip if already exists)
            my scalar $existing_fn = $ctx->{"functions"}->{$name};
            if ($existing_fn != 0) {
                next;  # Function with this name already exists
            }

            my hash %info = ();
            $info{"is_registered"} = 1;
            $info{"return_type"} = $fn_info->{"return_type"};
            $info{"param_count"} = $fn_info->{"param_count"};
            $info{"params"} = $fn_info->{"params"};
            $info{"is_extern"} = 0;
            $info{"is_variadic"} = 0;
            $info{"is_import_lib"} = 1;  # Mark as import_lib function
            $info{"line"} = 0;
            $ctx->{"functions"}->{$name} = \%info;
        }
    }
}

# Register global variables in the global scope
func register_globals(scalar $ctx, scalar $ast) void {
    my int $global_count = $ast->{"global_count"};
    if ($global_count == 0) {
        return;
    }

    my scalar $globals = $ast->{"globals"};
    my scalar $scope = $ctx->{"scope"};

    for (my int $i = 0; $i < $global_count; $i = $i + 1) {
        my scalar $gvar = $globals->[$i];
        my str $name = $gvar->{"name"};
        my str $sigil = $gvar->{"sigil"};
        my int $var_type = $gvar->{"var_type"};
        my int $line = ast_get_line($gvar);

        scope_add_var($scope, $name, $sigil, $var_type, $line);
    }
}

# ============================================================
# Validation Pass (Second Pass)
# ============================================================

func analyze_expression(scalar $ctx, scalar $expr) void {
    my int $node_type = $expr->{"type"};
    my int $line = ast_get_line($expr);

    # Variable reference
    if ($node_type == NODE_VARIABLE()) {
        my str $name = $expr->{"name"};
        my str $sigil = $expr->{"sigil"};
        my scalar $lookup_result = scope_lookup_var($ctx->{"scope"}, $name);
        my int $found = $lookup_result->{"found"};
        if ($found == 0) {
            semantic_error("undefined variable '" . $sigil . $name . "'", $line);
        }
        scope_mark_used($ctx->{"scope"}, $name);
        return;
    }

    # Function call
    if ($node_type == NODE_CALL()) {
        my str $name = $expr->{"name"};
        my scalar $args = $expr->{"args"};
        my int $arg_count = $expr->{"arg_count"};

        # Check if builtin (builtins hash stores 1 for each builtin)
        my int $is_builtin = $ctx->{"builtins"}->{$name};
        if ($is_builtin == 1) {
            # Builtin - analyze arguments
            for (my int $i = 0; $i < $arg_count; $i = $i + 1) {
                analyze_expression($ctx, $args->[$i]);
            }
            return;
        }

        # Convert Package::func to Package_func for lookup (only for local packages)
        # Module functions are registered as Package::func, so try both formats
        my str $lookup_name = $name;
        my int $colon_idx = index($name, "::");
        if ($colon_idx >= 0) {
            # Try Package_func format first (for local package functions)
            my str $prefix = substr($name, 0, $colon_idx);
            my str $suffix = substr($name, $colon_idx + 2, -1);
            my str $underscore_name = $prefix . "_" . $suffix;
            my scalar $fn_info_us = $ctx->{"functions"}->{$underscore_name};
            if ($fn_info_us->{"is_registered"} == 1) {
                $lookup_name = $underscore_name;
            }
            # Otherwise keep original Package::func format (for modules)
        }

        # Check if user-defined function
        # Registered functions have is_registered = 1
        my scalar $fn_info = $ctx->{"functions"}->{$lookup_name};
        my int $is_reg = $fn_info->{"is_registered"};
        if ($is_reg == 0) {
            # Not found - but allow namespaced calls (e.g., JSON::encode)
            # These are resolved at runtime via module loading
            if ($colon_idx < 0) {
                semantic_error("undefined function '" . $name . "'", $line);
            }
            # For namespaced functions, just analyze arguments and trust runtime
            for (my int $i = 0; $i < $arg_count; $i = $i + 1) {
                analyze_expression($ctx, $args->[$i]);
            }
            return;
        }

        my int $expected = $fn_info->{"param_count"};
        my int $actual = $expr->{"arg_count"};

        # Count required parameters (those without defaults)
        my int $required = 0;
        my scalar $params = $fn_info->{"params"};
        for (my int $i = 0; $i < $expected; $i = $i + 1) {
            my scalar $param = $params->[$i];
            my int $has_def = $param->{"has_default"};
            if ($has_def == 0) {
                $required = $required + 1;
            }
        }

        if ($actual < $required) {
            semantic_error("too few arguments to '" . $name . "': expected " . $required . ", got " . $actual, $line);
        }
        if ($actual > $expected) {
            # Check if function is variadic
            my int $is_var = $fn_info->{"is_variadic"};
            if ($is_var == 0) {
                semantic_error("too many arguments to '" . $name . "': expected " . $expected . ", got " . $actual, $line);
            }
        }

        # Analyze arguments (args is already declared above)
        for (my int $i = 0; $i < $actual; $i = $i + 1) {
            analyze_expression($ctx, $args->[$i]);
        }
        return;
    }

    # Binary operation
    if ($node_type == NODE_BINARY_OP()) {
        analyze_expression($ctx, $expr->{"left"});
        analyze_expression($ctx, $expr->{"right"});
        return;
    }

    # Unary operation
    if ($node_type == NODE_UNARY_OP()) {
        analyze_expression($ctx, $expr->{"operand"});
        return;
    }

    # Assignment
    if ($node_type == NODE_ASSIGN()) {
        analyze_expression($ctx, $expr->{"target"});
        analyze_expression($ctx, $expr->{"value"});
        return;
    }

    # Array subscript
    if ($node_type == NODE_SUBSCRIPT()) {
        analyze_expression($ctx, $expr->{"array"});
        analyze_expression($ctx, $expr->{"index"});
        return;
    }

    # Hash access
    if ($node_type == NODE_HASH_ACCESS()) {
        analyze_expression($ctx, $expr->{"hash"});
        analyze_expression($ctx, $expr->{"key"});
        return;
    }

    # Reference
    if ($node_type == NODE_REF()) {
        analyze_expression($ctx, $expr->{"target"});
        return;
    }

    # Dereference
    if ($node_type == NODE_DEREF_SCALAR() || $node_type == NODE_DEREF_ARRAY() || $node_type == NODE_DEREF_HASH()) {
        analyze_expression($ctx, $expr->{"ref"});
        if ($node_type == NODE_DEREF_ARRAY()) {
            analyze_expression($ctx, $expr->{"index"});
        }
        if ($node_type == NODE_DEREF_HASH()) {
            analyze_expression($ctx, $expr->{"key"});
        }
        return;
    }

    # Field access
    if ($node_type == NODE_FIELD_ACCESS()) {
        analyze_expression($ctx, $expr->{"object"});
        # Note: We could check struct field existence here, but we'd need to
        # track the type of the object being accessed, which is complex
        return;
    }

    # Anonymous array
    if ($node_type == NODE_ANON_ARRAY()) {
        my scalar $elems = $expr->{"elements"};
        my int $count = $expr->{"element_count"};
        for (my int $i = 0; $i < $count; $i = $i + 1) {
            analyze_expression($ctx, $elems->[$i]);
        }
        return;
    }

    # Anonymous hash
    if ($node_type == NODE_ANON_HASH()) {
        my scalar $values = $expr->{"values"};
        my int $count = $expr->{"pair_count"};
        for (my int $i = 0; $i < $count; $i = $i + 1) {
            analyze_expression($ctx, $values->[$i]);
        }
        return;
    }

    # Method call
    if ($node_type == NODE_METHOD_CALL()) {
        analyze_expression($ctx, $expr->{"object"});
        my scalar $args = $expr->{"args"};
        my int $count = $expr->{"arg_count"};
        for (my int $i = 0; $i < $count; $i = $i + 1) {
            analyze_expression($ctx, $args->[$i]);
        }
        return;
    }

    # SUPER:: call
    if ($node_type == NODE_SUPER_CALL()) {
        my scalar $args = $expr->{"args"};
        my int $count = $expr->{"arg_count"};
        for (my int $i = 0; $i < $count; $i = $i + 1) {
            analyze_expression($ctx, $args->[$i]);
        }
        return;
    }

    # Closure call ($closure->(args))
    if ($node_type == NODE_CLOSURE_CALL()) {
        analyze_expression($ctx, $expr->{"closure"});
        my scalar $args = $expr->{"args"};
        my int $count = $expr->{"arg_count"};
        for (my int $i = 0; $i < $count; $i = $i + 1) {
            analyze_expression($ctx, $args->[$i]);
        }
        return;
    }

    # Literals - no validation needed
    # NODE_INT_LITERAL, NODE_NUM_LITERAL, NODE_STR_LITERAL, NODE_FUNC_REF
}

func analyze_statement(scalar $ctx, scalar $stmt) void {
    my int $node_type = $stmt->{"type"};
    my int $line = ast_get_line($stmt);

    # Variable declaration
    if ($node_type == NODE_VAR_DECL()) {
        my str $name = $stmt->{"name"};
        my str $sigil = $stmt->{"sigil"};
        my int $var_type = $stmt->{"var_type"};

        # Check for struct type validity
        if ($var_type == TYPE_STRUCT()) {
            my str $type_name = $stmt->{"type_name"};
            my scalar $struct_info = $ctx->{"structs"}->{$type_name};
            my int $struct_exists = $struct_info->{"is_registered"};
            if ($struct_exists != 1) {
                semantic_error("undefined struct type '" . $type_name . "'", $line);
            }
        }

        # Check for redeclaration in current scope
        my scalar $current_scope = $ctx->{"scope"};
        my scalar $scope_vars = $current_scope->{"vars"};
        if (exists(%{$scope_vars}, $name)) {
            my scalar $prev_info = $scope_vars->{$name};
            my int $prev_line = $prev_info->{"line"};
            semantic_error("variable '" . $sigil . $name . "' already declared in this scope (previous declaration at line " . $prev_line . ")", $line);
        }

        # Add variable to scope
        scope_add_var($current_scope, $name, $sigil, $var_type, $line);

        # Analyze initializer if present
        my scalar $init_expr = $stmt->{"init"};
        if (is_valid_node($init_expr) == 1) {
            analyze_expression($ctx, $init_expr);
        }
        return;
    }

    # Expression statement
    if ($node_type == NODE_EXPR_STMT()) {
        analyze_expression($ctx, $stmt->{"expr"});
        return;
    }

    # Return statement
    if ($node_type == NODE_RETURN_STMT()) {
        my scalar $ret_val = $stmt->{"value"};
        if (is_valid_node($ret_val) == 1) {
            analyze_expression($ctx, $ret_val);
        }
        return;
    }

    # If statement
    if ($node_type == NODE_IF_STMT()) {
        analyze_expression($ctx, $stmt->{"condition"});
        analyze_block($ctx, $stmt->{"then_block"});

        # elsif clauses
        my scalar $elsif_conds = $stmt->{"elsif_conditions"};
        my scalar $elsif_blocks = $stmt->{"elsif_blocks"};
        my int $elsif_count = $stmt->{"elsif_count"};
        for (my int $i = 0; $i < $elsif_count; $i = $i + 1) {
            analyze_expression($ctx, $elsif_conds->[$i]);
            analyze_block($ctx, $elsif_blocks->[$i]);
        }

        # else block
        my scalar $else_blk = $stmt->{"else_block"};
        if (is_valid_node($else_blk) == 1) {
            analyze_block($ctx, $else_blk);
        }
        return;
    }

    # While statement
    if ($node_type == NODE_WHILE_STMT()) {
        analyze_expression($ctx, $stmt->{"condition"});
        analyze_block($ctx, $stmt->{"body"});
        return;
    }

    # For statement
    if ($node_type == NODE_FOR_STMT()) {
        # For loop has its own scope for the init variable
        my scalar $old_scope = $ctx->{"scope"};
        $ctx->{"scope"} = scope_new($old_scope);

        my scalar $for_init = $stmt->{"init"};
        if (is_valid_node($for_init) == 1) {
            # Init could be var decl or expression
            if ($for_init->{"type"} == NODE_VAR_DECL()) {
                analyze_statement($ctx, $for_init);
            } else {
                analyze_expression($ctx, $for_init);
            }
        }
        analyze_expression($ctx, $stmt->{"condition"});
        my scalar $for_upd = $stmt->{"update"};
        if (is_valid_node($for_upd) == 1) {
            analyze_expression($ctx, $for_upd);
        }
        analyze_block($ctx, $stmt->{"body"});

        scope_check_unused($ctx, $ctx->{"scope"});
        $ctx->{"scope"} = $old_scope;
        return;
    }

    # Try/catch statement
    if ($node_type == NODE_TRY_CATCH()) {
        # Analyze try block
        analyze_block($ctx, $stmt->{"try_block"});

        # Catch block has its own scope with the exception variable
        my scalar $old_scope = $ctx->{"scope"};
        $ctx->{"scope"} = scope_new($old_scope);

        # Declare the catch variable
        my str $catch_var = $stmt->{"catch_var"};
        if (length($catch_var) > 0) {
            scope_add_var($ctx->{"scope"}, $catch_var, "$", TYPE_SCALAR(), $stmt->{"line"});
            # Mark it as used since it captures the exception
            scope_mark_used($ctx->{"scope"}, $catch_var);
        }

        analyze_block($ctx, $stmt->{"catch_block"});

        scope_check_unused($ctx, $ctx->{"scope"});
        $ctx->{"scope"} = $old_scope;
        return;
    }
}

func analyze_block(scalar $ctx, scalar $block) void {
    # Create new scope for block
    my scalar $old_scope = $ctx->{"scope"};
    $ctx->{"scope"} = scope_new($old_scope);

    my scalar $stmts = $block->{"statements"};
    my int $count = $block->{"statement_count"};

    for (my int $i = 0; $i < $count; $i = $i + 1) {
        analyze_statement($ctx, $stmts->[$i]);
    }

    # Check for unused variables
    scope_check_unused($ctx, $ctx->{"scope"});

    # Restore scope
    $ctx->{"scope"} = $old_scope;
}

func analyze_function(scalar $ctx, scalar $fn) void {
    # Set current function for return type checking
    $ctx->{"current_func"} = $fn;

    # Create function scope
    my scalar $old_scope = $ctx->{"scope"};
    $ctx->{"scope"} = scope_new($old_scope);

    # Add parameters to scope
    my scalar $params = $fn->{"params"};
    my int $param_count = $fn->{"param_count"};
    for (my int $i = 0; $i < $param_count; $i = $i + 1) {
        my scalar $param = $params->[$i];
        my str $pname = $param->{"name"};
        my str $sigil = $param->{"sigil"};
        my int $ptype = $param->{"param_type"};
        my int $pline = ast_get_line($param);
        scope_add_var($ctx->{"scope"}, $pname, $sigil, $ptype, $pline);
    }

    # Analyze function body (non-extern functions always have a body)
    analyze_block($ctx, $fn->{"body"});

    # Check for unused parameters
    scope_check_unused($ctx, $ctx->{"scope"});

    # Restore scope
    $ctx->{"scope"} = $old_scope;
    $ctx->{"current_func"} = 0;
}

# ============================================================
# Main Entry Point
# ============================================================

func semantic_analyze(scalar $ast, int $show_warnings) void {
    my scalar $ctx = ctx_new();
    $ctx->{"show_warnings"} = $show_warnings;

    # First pass: register all functions, structs, and globals
    register_functions($ctx, $ast);
    register_structs($ctx, $ast);
    register_globals($ctx, $ast);
    register_import_lib_functions($ctx, $ast);

    # Second pass: validate each function
    my scalar $funcs = $ast->{"functions"};
    my int $count = $ast->{"function_count"};

    for (my int $i = 0; $i < $count; $i = $i + 1) {
        my scalar $fn = $funcs->[$i];

        # Skip extern functions (no body to analyze)
        if ($fn->{"is_extern"} == 1) {
            next;
        }
        analyze_function($ctx, $fn);
    }
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# CodeGen.strada - C Code Generator for self-hosting Strada compiler
# Transforms AST into C source code

# ============================================================
# Code Generator State
# ============================================================

# Sanitize function names for C (replace :: with _)
func sanitize_name(str $name) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($name);
    while ($i < $len) {
        my str $ch = substr($name, $i, 1);
        if ($ch eq ":") {
            # Check for :: sequence and replace with single _
            if ($i + 1 < $len && substr($name, $i + 1, 1) eq ":") {
                $result = $result . "_";
                $i = $i + 1;  # Skip the second colon
            } else {
                $result = $result . "_";
            }
        } else {
            $result = $result . $ch;
        }
        $i = $i + 1;
    }
    return $result;
}

# Escape C keywords used as variable names by prefixing with v_
func escape_c_keyword(str $name) str {
    # C keywords that conflict with Strada variable names
    if ($name eq "for") { return "v_for"; }
    if ($name eq "while") { return "v_while"; }
    if ($name eq "if") { return "v_if"; }
    if ($name eq "else") { return "v_else"; }
    if ($name eq "switch") { return "v_switch"; }
    if ($name eq "case") { return "v_case"; }
    if ($name eq "default") { return "v_default"; }
    if ($name eq "break") { return "v_break"; }
    if ($name eq "continue") { return "v_continue"; }
    if ($name eq "return") { return "v_return"; }
    if ($name eq "goto") { return "v_goto"; }
    if ($name eq "do") { return "v_do"; }
    if ($name eq "int") { return "v_int"; }
    if ($name eq "char") { return "v_char"; }
    if ($name eq "float") { return "v_float"; }
    if ($name eq "double") { return "v_double"; }
    if ($name eq "void") { return "v_void"; }
    if ($name eq "long") { return "v_long"; }
    if ($name eq "short") { return "v_short"; }
    if ($name eq "unsigned") { return "v_unsigned"; }
    if ($name eq "signed") { return "v_signed"; }
    if ($name eq "const") { return "v_const"; }
    if ($name eq "static") { return "v_static"; }
    if ($name eq "extern") { return "v_extern"; }
    if ($name eq "register") { return "v_register"; }
    if ($name eq "volatile") { return "v_volatile"; }
    if ($name eq "auto") { return "v_auto"; }
    if ($name eq "struct") { return "v_struct"; }
    if ($name eq "union") { return "v_union"; }
    if ($name eq "enum") { return "v_enum"; }
    if ($name eq "typedef") { return "v_typedef"; }
    if ($name eq "sizeof") { return "v_sizeof"; }
    # C99/C11 keywords
    if ($name eq "inline") { return "v_inline"; }
    if ($name eq "restrict") { return "v_restrict"; }
    if ($name eq "_Bool") { return "v_Bool"; }
    if ($name eq "_Complex") { return "v_Complex"; }
    if ($name eq "_Imaginary") { return "v_Imaginary"; }
    return $name;
}

func codegen_new(str $filename, int $debug_info, int $enable_profiling) scalar {
    my hash %cg = ();
    # StringBuilder for O(1) amortized append (no O(n^2) string concat)
    $cg{"output_sb"} = sb_new();
    $cg{"preamble_content"} = "";  # Saved preamble when doing multi-phase
    $cg{"funcs_content"} = "";     # Saved funcs when doing multi-phase
    $cg{"oop_fwd_decls"} = "";     # OOP init forward declarations (generated after methods tracked)
    $cg{"indent"} = 0;
    $cg{"debug_info"} = $debug_info;  # Emit #line directives for debugging
    $cg{"enable_profiling"} = $enable_profiling;  # Emit function profiling code
    $cg{"last_line"} = 0;  # Track last emitted line to avoid duplicates
    $cg{"functions"} = {};  # Map function name -> function info
    $cg{"in_extern"} = 0;   # Track if we're inside an extern function
    $cg{"extern_params"} = {};  # Map param name -> type for extern functions
    $cg{"in_main"} = 0;     # Track if we're inside main function
    $cg{"package"} = "";    # Current package name
    $cg{"filename"} = $filename;  # Source file name for __FILE__
    $cg{"map_counter"} = 0;     # Counter for unique map variable names
    $cg{"sort_counter"} = 0;    # Counter for unique sort variable names
    $cg{"grep_counter"} = 0;    # Counter for unique grep variable names
    $cg{"foreach_counter"} = 0; # Counter for unique foreach variable names
    $cg{"in_map_block"} = 0;  # Track if inside map block (for $_)
    $cg{"in_sort_block"} = 0; # Track if inside sort block (for $a, $b)
    $cg{"in_grep_block"} = 0; # Track if inside grep block (for $_)
    $cg{"struct_vars"} = {};  # Map variable name -> struct type name
    $cg{"struct_defs"} = {};  # Map struct name -> struct definition with field info
    $cg{"anon_func_counter"} = 0;  # Counter for unique anonymous function names
    $cg{"anon_func_decls"} = "";   # Forward declarations for anonymous functions
    $cg{"anon_func_defs"} = "";    # Function definitions for anonymous functions
    $cg{"in_anon_func"} = 0;       # Track if inside anonymous function
    $cg{"anon_param_str"} = "";    # Comma-separated param names
    $cg{"anon_local_str"} = "";    # Comma-separated local names
    $cg{"anon_capture_str"} = "";  # Comma-separated capture names
    $cg{"anon_capture_count"} = 0; # Number of captures
    $cg{"current_func_name"} = ""; # Current function name for profiling
    $cg{"global_count"} = 0;       # Number of global variables
    my array @empty_globals = ();
    $cg{"globals"} = \@empty_globals;  # Array of global variable declarations
    $cg{"switch_counter"} = 0;     # Counter for unique switch variable names
    # OOP method registration - per-package tracking
    my hash %empty_pkg_methods = ();
    $cg{"pkg_methods"} = \%empty_pkg_methods;  # Hash: package -> array of method info
    my array @empty_pkg_list = ();
    $cg{"pkg_list"} = \@empty_pkg_list;        # Array of package names (to avoid keys())
    $cg{"pkg_count"} = 0;                      # Number of packages
    $cg{"pkg_seen"} = "|";                     # String of seen package names (for fast lookup)
    $cg{"method_wrappers"} = "";   # Generated wrapper functions
    # Scope tracking for memory management (using string-encoded var lists for bootstrap compat)
    # Each scope is stored as "var1,var2,var3" string (bootstrap doesn't support scalar(@arr))
    my array @scope_vars = ();   # Array of scope strings
    my array @scope_counts = (); # Parallel array of counts
    $cg{"scope_vars"} = \@scope_vars;
    $cg{"scope_counts"} = \@scope_counts;
    $cg{"scope_depth"} = 0;
    $cg{"cleanup_enabled"} = 1;  # Enable scope-based memory cleanup
    $cg{"returns_struct"} = 0;   # Track if current function returns struct
    $cg{"try_depth"} = 0;        # Track nesting depth in try blocks (for proper cleanup on return)
    return \%cg;
}

# Push a new scope onto the scope stack
func scope_push(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my int $depth = $cg->{"scope_depth"};
    push($vars, "");  # Empty scope
    push($counts, 0);
    $cg->{"scope_depth"} = $depth + 1;
}

# Track a variable in the current scope
func scope_track_var(scalar $cg, str $name) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    if ($depth == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my str $current = $vars->[$depth - 1];
    my int $count = $counts->[$depth - 1];
    if ($count == 0) {
        $vars->[$depth - 1] = $name;
    } else {
        $vars->[$depth - 1] = $current . "," . $name;
    }
    $counts->[$depth - 1] = $count + 1;
}

# Emit cleanup for current scope and pop it
func scope_pop(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    if ($depth == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my str $scope_str = $vars->[$depth - 1];
    my int $count = $counts->[$depth - 1];

    emit_scope_decref($cg, $scope_str, $count);

    pop($vars);
    pop($counts);
    $cg->{"scope_depth"} = $depth - 1;
}

# Check if a variable name is in a comma-separated string
func is_var_in_list(str $var, str $list) int {
    if (length($list) == 0) { return 0; }
    my int $pos = 0;
    my int $len = length($list);
    my str $cur = "";
    while ($pos <= $len) {
        if ($pos == $len) {
            if ($cur eq $var) { return 1; }
            $pos = $pos + 1;
        } else {
            my str $ch = substr($list, $pos, 1);
            if ($ch eq ",") {
                if ($cur eq $var) { return 1; }
                $cur = "";
            } else {
                $cur = $cur . $ch;
            }
            $pos = $pos + 1;
        }
    }
    return 0;
}

# Helper to emit decref for all vars in a scope string
func emit_scope_decref(scalar $cg, str $scope_str, int $count) void {
    if ($count == 0 || length($scope_str) == 0) {
        return;
    }
    # Get capture list to skip captured variables in closures
    my int $in_anon = $cg->{"in_anon_func"};
    my str $capture_str = $cg->{"anon_capture_str"};

    my int $pos = 0;
    my int $len = length($scope_str);
    my str $var_name = "";
    while ($pos <= $len) {
        if ($pos == $len) {
            if (length($var_name) > 0) {
                # Skip captured variables - they're accessed via __captures, not local vars
                if ($in_anon == 0 || is_var_in_list($var_name, $capture_str) == 0) {
                    emit_indent($cg);
                    emit($cg, "strada_decref(" . $var_name . ");\n");
                }
            }
            $pos = $pos + 1;
        } else {
            my str $ch = substr($scope_str, $pos, 1);
            if ($ch eq ",") {
                if (length($var_name) > 0) {
                    # Skip captured variables
                    if ($in_anon == 0 || is_var_in_list($var_name, $capture_str) == 0) {
                        emit_indent($cg);
                        emit($cg, "strada_decref(" . $var_name . ");\n");
                    }
                }
                $var_name = "";
            } else {
                $var_name = $var_name . $ch;
            }
            $pos = $pos + 1;
        }
    }
}

# Emit cleanup for current scope without popping (for early returns)
func scope_emit_cleanup(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    if ($depth == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my str $scope_str = $vars->[$depth - 1];
    my int $count = $counts->[$depth - 1];
    emit_scope_decref($cg, $scope_str, $count);
}

# Emit cleanup for all scopes (for return statements)
func scope_emit_all_cleanup(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};

    # Emit cleanup from innermost to outermost scope
    my int $d = $depth;
    while ($d > 0) {
        my str $scope_str = $vars->[$d - 1];
        my int $count = $counts->[$d - 1];
        emit_scope_decref($cg, $scope_str, $count);
        $d = $d - 1;
    }
}

# Emit STRADA_TRY_POP() for each active try block (for early returns in try blocks)
func emit_try_cleanup(scalar $cg) void {
    my int $try_depth = $cg->{"try_depth"};
    while ($try_depth > 0) {
        emit_indent($cg);
        emit($cg, "STRADA_TRY_POP();\n");
        $try_depth = $try_depth - 1;
    }
}

# Register a function with its parameters for default arg handling
func codegen_register_function(scalar $cg, scalar $fn) void {
    my str $name = sanitize_name($fn->{"name"});
    my hash %info = ();
    $info{"param_count"} = $fn->{"param_count"};
    $info{"params"} = $fn->{"params"};
    $info{"return_type"} = $fn->{"return_type"};
    # Track if this is an extern function for call site conversion
    if ($fn->{"type"} == NODE_EXTERN_FUNC()) {
        $info{"is_extern"} = 1;
    } else {
        $info{"is_extern"} = 0;
    }
    $cg->{"functions"}->{$name} = \%info;
}

# Helper to get arg from packed args array
func gen_oop_helper_decl() str {
    my str $code = "";
    $code = $code . "/* OOP method dispatch helper */\n";
    $code = $code . "static StradaValue* __strada_get_arg(StradaValue* args, int idx) {\n";
    $code = $code . "    if (!args || args->type != STRADA_ARRAY) return NULL;\n";
    $code = $code . "    if ((size_t)idx >= args->value.av->size) return NULL;\n";
    $code = $code . "    return args->value.av->elements[idx];\n";
    $code = $code . "}\n\n";
    return $code;
}

# Track a method for OOP registration (per-package)
func codegen_track_method(scalar $cg, scalar $fn, str $pkg) void {
    my str $name = sanitize_name($fn->{"name"});

    # Skip main, extern functions, and functions starting with underscore
    if ($name eq "main") { return; }
    if ($fn->{"type"} == NODE_EXTERN_FUNC()) { return; }
    if (substr($name, 0, 1) eq "_") { return; }

    # Methods must have at least one parameter (self)
    # Functions with 0 params are class init functions, not methods
    my int $param_count = $fn->{"param_count"};
    if ($param_count == 0) { return; }

    # Check if function name starts with package prefix (e.g., Cannoli_)
    my str $prefix = $pkg . "_";
    my int $prefix_len = length($prefix);
    if (length($name) <= $prefix_len) { return; }
    if (substr($name, 0, $prefix_len) ne $prefix) { return; }

    # Get method name without prefix
    my str $method = substr($name, $prefix_len, length($name) - $prefix_len);

    # Track method info
    my hash %minfo = ();
    $minfo{"func_name"} = $name;
    $minfo{"method_name"} = $method;
    $minfo{"param_count"} = $fn->{"param_count"};
    $minfo{"params"} = $fn->{"params"};
    $minfo{"return_type"} = $fn->{"return_type"};
    $minfo{"package"} = $pkg;

    # Get or create the methods info for this package
    # Use string index check instead of exists() for bootstrap compatibility
    my str $pkg_marker = "|" . $pkg . "|";
    my str $seen = $cg->{"pkg_seen"};
    my int $found_idx = index($seen, $pkg_marker);
    if ($found_idx < 0) {
        # New package - initialize it
        my hash %pkg_info = ();
        my array @new_arr = ();
        $pkg_info{"methods"} = \@new_arr;
        $pkg_info{"count"} = 0;
        my scalar $pkg_methods = $cg->{"pkg_methods"};
        $pkg_methods->{$pkg} = \%pkg_info;
        # Also track package name in the list
        my int $pkg_idx = $cg->{"pkg_count"};
        $cg->{"pkg_list"}->[$pkg_idx] = $pkg;
        $cg->{"pkg_count"} = $pkg_idx + 1;
        # Mark as seen
        $cg->{"pkg_seen"} = $seen . $pkg . "|";
    }
    my scalar $pkg_methods = $cg->{"pkg_methods"};
    my scalar $pkg_info = $pkg_methods->{$pkg};
    my int $idx = $pkg_info->{"count"};
    $pkg_info->{"methods"}->[$idx] = \%minfo;
    $pkg_info->{"count"} = $idx + 1;
}

# Generate method wrapper functions for a single package
# $pkg_info is a hash with "methods" array and "count" int
func gen_method_wrappers_for_pkg(str $pkg, scalar $pkg_info) str {
    my str $code = "";
    my int $method_count = $pkg_info->{"count"};
    my scalar $methods = $pkg_info->{"methods"};
    if ($method_count == 0) { return ""; }

    $code = $code . "/* OOP method wrappers for package " . $pkg . " */\n";

    my int $i = 0;
    while ($i < $method_count) {
        my scalar $m = $methods->[$i];
        my str $func_name = $m->{"func_name"};
        my int $param_count = $m->{"param_count"};
        my int $ret_type = $m->{"return_type"};
        my int $is_void = $ret_type == TYPE_VOID();

        # Generate wrapper: __wrap_FuncName(self, args) { ... }
        $code = $code . "static StradaValue* __wrap_" . $func_name . "(StradaValue* self, StradaValue* args) {\n";

        if ($param_count <= 1) {
            # 0 or 1 param (just self)
            $code = $code . "    (void)args;\n";
            if ($is_void == 1) {
                $code = $code . "    " . $func_name . "(self);\n";
                $code = $code . "    return strada_new_undef();\n";
            } else {
                $code = $code . "    return " . $func_name . "(self);\n";
            }
        } else {
            # Multiple params - unpack from args
            if ($is_void == 1) {
                $code = $code . "    " . $func_name . "(self";
            } else {
                $code = $code . "    return " . $func_name . "(self";
            }
            my int $j = 1;  # Skip self
            while ($j < $param_count) {
                my int $arg_idx = $j - 1;
                $code = $code . ", __strada_get_arg(args, " . $arg_idx . ")";
                $j = $j + 1;
            }
            $code = $code . ");\n";
            if ($is_void == 1) {
                $code = $code . "    return strada_new_undef();\n";
            }
        }

        $code = $code . "}\n\n";
        $i = $i + 1;
    }

    # Generate initialization function for this package
    $code = $code . "/* OOP method registration initializer */\n";
    $code = $code . "static int __" . $pkg . "_oop_initialized = 0;\n";
    $code = $code . "void __" . $pkg . "_oop_init(void) {\n";
    $code = $code . "    if (__" . $pkg . "_oop_initialized) return;\n";
    $code = $code . "    __" . $pkg . "_oop_initialized = 1;\n\n";

    $i = 0;
    while ($i < $method_count) {
        my scalar $m = $methods->[$i];
        my str $func_name = $m->{"func_name"};
        my str $method_name = $m->{"method_name"};

        $code = $code . "    strada_method_register(\"" . $pkg . "\", \"" . $method_name . "\", __wrap_" . $func_name . ");\n";
        $i = $i + 1;
    }

    $code = $code . "}\n\n";

    return $code;
}

# Generate method wrappers for ALL packages
func gen_all_method_wrappers(scalar $cg) str {
    my str $code = "";
    my int $num_pkgs = get_oop_pkg_count($cg);
    if ($num_pkgs == 0) { return ""; }

    my scalar $pkg_methods = $cg->{"pkg_methods"};
    my scalar $pkg_list = get_oop_packages($cg);

    # Add the helper function once
    $code = $code . gen_oop_helper_decl();

    # Generate wrappers for each package
    my int $i = 0;
    while ($i < $num_pkgs) {
        my str $pkg = $pkg_list->[$i];
        my scalar $pkg_info = $pkg_methods->{$pkg};
        $code = $code . gen_method_wrappers_for_pkg($pkg, $pkg_info);
        $i = $i + 1;
    }

    return $code;
}

# Get all packages that have registered methods
# Returns the pkg_list array reference (not a copy)
func get_oop_packages(scalar $cg) scalar {
    return $cg->{"pkg_list"};
}

# Get count of packages
func get_oop_pkg_count(scalar $cg) int {
    return $cg->{"pkg_count"};
}

# Check if an expression is clearly a scalar value (not an array or function call)
# Used to determine if we need to wrap it when assigning to an array variable
func is_scalar_expr(scalar $expr) int {
    my int $type = $expr->{"type"};

    # Scalar variables ($x)
    if ($type == NODE_VARIABLE()) {
        my str $sigil = $expr->{"sigil"};
        if ($sigil eq "$") {
            return 1;
        }
        return 0;
    }

    # Literal values
    if ($type == NODE_INT_LITERAL() || $type == NODE_NUM_LITERAL() || $type == NODE_STR_LITERAL()) {
        return 1;
    }

    # Unary operators on scalars
    if ($type == NODE_UNARY_OP()) {
        return 1;
    }

    # Binary operators produce scalars (arithmetic, comparison, etc.)
    if ($type == NODE_BINARY_OP()) {
        return 1;
    }

    # Ternary produces a scalar
    if ($type == NODE_TERNARY()) {
        return 1;
    }

    # Array/hash subscript returns a scalar
    if ($type == NODE_SUBSCRIPT() || $type == NODE_HASH_ACCESS()) {
        return 1;
    }

    # Field access returns a scalar
    if ($type == NODE_FIELD_ACCESS()) {
        return 1;
    }

    # Everything else (function calls, deref, etc.) - assume not scalar
    return 0;
}

func emit(scalar $cg, str $text) void {
    # O(1) amortized append using StringBuilder
    sb_append($cg->{"output_sb"}, $text);
}

# Emit #line directive for source-level debugging
# Format: #line <line_number> "<filename>"
func emit_line_directive(scalar $cg, int $line) void {
    if ($cg->{"debug_info"} == 0) {
        return;
    }
    if ($line <= 0) {
        return;
    }
    # Avoid emitting duplicate line directives
    if ($line == $cg->{"last_line"}) {
        return;
    }
    $cg->{"last_line"} = $line;

    my str $filename = $cg->{"filename"};
    emit($cg, "#line " . $line . " \"" . $filename . "\"\n");
}

# Emit #line directive before a statement (with indent)
func emit_line_for_stmt(scalar $cg, scalar $stmt) void {
    if ($cg->{"debug_info"} == 0) {
        return;
    }
    # stmt should always be defined when called from gen_statement
    my int $line = $stmt->{"line"};
    if ($line > 0) {
        emit_line_directive($cg, $line);
    }
}

# Get accumulated output as a single string
func get_output(scalar $cg) str {
    # Get the current output from StringBuilder
    my str $final = sb_to_string($cg->{"output_sb"});

    # Check if we used multi-phase generation
    my str $preamble = $cg->{"preamble_content"};
    if (length($preamble) > 0) {
        my str $funcs = $cg->{"funcs_content"};
        my str $anon_decls = $cg->{"anon_func_decls"};
        my str $oop_decls = $cg->{"oop_fwd_decls"};

        # Build result: preamble + oop_decls + anon_decls + funcs + final
        my str $result = $preamble;
        if (length($oop_decls) > 0) {
            $result = $result . $oop_decls;
        }
        if (length($anon_decls) > 0) {
            $result = $result . "/* Anonymous function forward declarations */\n";
            $result = $result . $anon_decls;
            $result = $result . "\n";
        }
        $result = $result . $funcs;
        $result = $result . $final;
        return $result;
    }

    return $final;
}

# Set output - for save/restore pattern in anonymous functions
func set_output(scalar $cg, str $text) void {
    sb_clear($cg->{"output_sb"});
    sb_append($cg->{"output_sb"}, $text);
}

func emit_line(scalar $cg, str $text) void {
    emit_indent($cg);
    emit($cg, $text . "\n");
}

func emit_indent(scalar $cg) void {
    my int $i = 0;
    while ($i < $cg->{"indent"}) {
        emit($cg, "    ");
        $i = $i + 1;
    }
}

func indent(scalar $cg) void {
    $cg->{"indent"} = $cg->{"indent"} + 1;
}

func dedent(scalar $cg) void {
    $cg->{"indent"} = $cg->{"indent"} - 1;
}

# Check if name is in comma-separated string (workaround for bootstrap limitation)
func str_contains_name(str $list, str $name) int {
    my str $search = "," . $name . ",";
    my str $padded = "," . $list . ",";
    my int $pos = index($padded, $search);
    if ($pos >= 0) { return 1; }
    return 0;
}

# Get index of name in comma-separated capture string
func get_capture_index(str $list, str $name) int {
    if ($list eq "") { return -1; }
    my int $idx = 0;
    my int $start = 0;
    my int $len = length($list);
    my int $i = 0;
    while ($i <= $len) {
        my str $ch = "";
        if ($i < $len) { $ch = substr($list, $i, 1); }
        if ($ch eq "," || $i == $len) {
            my str $part = substr($list, $start, $i - $start);
            if ($part eq $name) { return $idx; }
            $idx = $idx + 1;
            $start = $i + 1;
        }
        $i = $i + 1;
    }
    return -1;
}

# Generate code for regex pattern with variable interpolation
# Pattern like "$foo" or "^$pattern$" gets converted to runtime string building
func gen_regex_interpolated_pattern(scalar $cg, str $pattern) void {
    # Parse pattern into parts (literals and variables)
    # We manually track the count since bootstrap doesn't support scalar(@array)
    my array @parts = ();
    my int $num_parts = 0;
    my int $len = length($pattern);
    my int $i = 0;
    my str $literal = "";

    while ($i < $len) {
        my str $ch = substr($pattern, $i, 1);

        if ($ch eq "$") {
            # Save any accumulated literal
            if (length($literal) > 0) {
                my hash %part = ();
                $part{"type"} = "lit";
                $part{"value"} = $literal;
                push(@parts, \%part);
                $num_parts = $num_parts + 1;
                $literal = "";
            }

            # Parse variable name
            $i = $i + 1;
            my str $varname = "";
            while ($i < $len) {
                my str $vch = substr($pattern, $i, 1);
                if ($vch eq "_" || ($vch ge "a" && $vch le "z") || ($vch ge "A" && $vch le "Z") || ($vch ge "0" && $vch le "9")) {
                    $varname = $varname . $vch;
                    $i = $i + 1;
                } else {
                    last;
                }
            }

            if (length($varname) > 0) {
                my hash %part = ();
                $part{"type"} = "var";
                $part{"value"} = $varname;
                push(@parts, \%part);
                $num_parts = $num_parts + 1;
            }
        } else {
            $literal = $literal . $ch;
            $i = $i + 1;
        }
    }

    # Save any remaining literal
    if (length($literal) > 0) {
        my hash %part = ();
        $part{"type"} = "lit";
        $part{"value"} = $literal;
        push(@parts, \%part);
        $num_parts = $num_parts + 1;
    }

    # Generate concatenation code
    if ($num_parts == 0) {
        emit($cg, "strada_new_str(\"\")");
        return;
    }
    if ($num_parts == 1) {
        my scalar $p = @parts[0];
        if ($p->{"type"} eq "var") {
            emit($cg, $p->{"value"});
        } else {
            emit($cg, "strada_new_str(\"");
            emit_escaped_string($cg, $p->{"value"});
            emit($cg, "\")");
        }
        return;
    }

    # Multiple parts - build with strada_concat_sv chain (fast, no copies)
    # strada_concat_sv(a, strada_concat_sv(b, c))
    my int $pi = 0;
    while ($pi < $num_parts - 1) {
        emit($cg, "strada_concat_sv(");
        $pi = $pi + 1;
    }

    # Emit first part
    my scalar $first_p = @parts[0];
    if ($first_p->{"type"} eq "var") {
        emit($cg, $first_p->{"value"});
    } else {
        emit($cg, "strada_new_str(\"");
        emit_escaped_string($cg, $first_p->{"value"});
        emit($cg, "\")");
    }
    emit($cg, ", ");

    # Emit remaining parts
    $pi = 1;
    while ($pi < $num_parts) {
        my scalar $p = @parts[$pi];
        if ($p->{"type"} eq "var") {
            emit($cg, $p->{"value"});
        } else {
            emit($cg, "strada_new_str(\"");
            emit_escaped_string($cg, $p->{"value"});
            emit($cg, "\")");
        }
        emit($cg, ")");
        if ($pi < $num_parts - 1) {
            emit($cg, ", ");
        }
        $pi = $pi + 1;
    }
}

# Helper to emit an escaped C string
func emit_escaped_string(scalar $cg, str $s) void {
    my int $i = 0;
    my int $len = length($s);
    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        if ($ch eq "\\") {
            emit($cg, "\\\\");
        } elsif ($ch eq "\"") {
            emit($cg, "\\\"");
        } elsif ($ch eq "\n") {
            emit($cg, "\\n");
        } elsif ($ch eq "\t") {
            emit($cg, "\\t");
        } else {
            emit($cg, $ch);
        }
        $i = $i + 1;
    }
}

# ============================================================
# Type Conversion
# ============================================================

func type_to_c(int $type) str {
    if ($type == TYPE_INT()) { return "StradaValue*"; }
    if ($type == TYPE_NUM()) { return "StradaValue*"; }
    if ($type == TYPE_STR()) { return "StradaValue*"; }
    if ($type == TYPE_ARRAY()) { return "StradaValue*"; }
    if ($type == TYPE_HASH()) { return "StradaValue*"; }
    if ($type == TYPE_SCALAR()) { return "StradaValue*"; }
    if ($type == TYPE_VOID()) { return "void"; }
    if ($type == TYPE_STRUCT()) { return "void*"; }  # Struct pointer
    if ($type == TYPE_FUNCPTR()) { return "void*"; }  # Function pointer
    return "StradaValue*";
}

# ============================================================
# Expression Code Generation
# ============================================================

# Helper: emit a numeric operand efficiently
# For literals, emit the value directly; otherwise use strada_to_num()
func emit_num_operand(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    if ($type == NODE_INT_LITERAL()) {
        my str $val = $expr->{"value"};
        # Check if it's a hex, octal, or binary literal
        # Also check for leading zeros (octal in C)
        my str $first = substr($val, 0, 1);
        my str $second = "";
        if (length($val) > 1) {
            $second = substr($val, 1, 1);
        }
        if (substr($val, 0, 2) eq "0x" || substr($val, 0, 2) eq "0X" ||
            substr($val, 0, 2) eq "0o" || substr($val, 0, 2) eq "0O" ||
            substr($val, 0, 2) eq "0b" || substr($val, 0, 2) eq "0B") {
            # Cast hex/octal/binary to double
            emit($cg, "(double)(" . $val . ")");
        } elsif ($first eq "0" && length($val) > 1 && $second ne ".") {
            # Leading zero means octal in C - must cast to preserve value
            emit($cg, "(double)(" . $val . ")");
        } else {
            emit($cg, $val . ".0");
        }
    } elsif ($type == NODE_NUM_LITERAL()) {
        emit($cg, $expr->{"value"});
    } else {
        emit($cg, "strada_to_num(");
        gen_expression($cg, $expr);
        emit($cg, ")");
    }
}

# Helper: emit an integer operand efficiently
# For literals, emit the value directly; otherwise use strada_to_int()
func emit_int_operand(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    if ($type == NODE_INT_LITERAL()) {
        emit($cg, $expr->{"value"});
    } elsif ($type == NODE_NUM_LITERAL()) {
        emit($cg, "(int64_t)" . $expr->{"value"});
    } else {
        emit($cg, "strada_to_int(");
        gen_expression($cg, $expr);
        emit($cg, ")");
    }
}

# Helper: emit a bool operand efficiently
# For literals, emit the value directly; otherwise use strada_to_bool()
func emit_bool_operand(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    if ($type == NODE_INT_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
    } elsif ($type == NODE_NUM_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0" || $val eq "0.0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
    } else {
        emit($cg, "strada_to_bool(");
        gen_expression($cg, $expr);
        emit($cg, ")");
    }
}

# Helper: emit an expression as a C string in extern mode
# Converts non-string types (int, num) to strings using helper functions
func emit_extern_str_operand(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};

    # String literals - emit as raw C string
    if ($type == NODE_STR_LITERAL()) {
        gen_expression($cg, $expr);
        return;
    }

    # Integer literals - convert to string
    if ($type == NODE_INT_LITERAL()) {
        emit($cg, "strada_int_to_cstr(" . $expr->{"value"} . ")");
        return;
    }

    # Number literals - convert to string
    if ($type == NODE_NUM_LITERAL()) {
        emit($cg, "strada_num_to_cstr(" . $expr->{"value"} . ")");
        return;
    }

    # Variables - check extern_params for type and convert if needed
    if ($type == NODE_VARIABLE()) {
        my str $var_name = $expr->{"name"};
        my scalar $extern_params = $cg->{"extern_params"};
        if ($extern_params) {
            my scalar $param_type = $extern_params->{$var_name};
            if ($param_type) {
                if ($param_type == TYPE_INT() || $param_type == TYPE_INT32() || $param_type == TYPE_INT64()) {
                    emit($cg, "strada_int_to_cstr(" . $var_name . ")");
                    return;
                } elsif ($param_type == TYPE_NUM() || $param_type == TYPE_FLOAT32() || $param_type == TYPE_FLOAT64()) {
                    emit($cg, "strada_num_to_cstr(" . $var_name . ")");
                    return;
                }
            }
        }
        # String type or unknown - emit as-is
        emit($cg, $var_name);
        return;
    }

    # Binary op (nested concatenation) - recurse
    if ($type == NODE_BINARY_OP() && $expr->{"op"} eq ".") {
        emit($cg, "strada_cstr_concat(");
        emit_extern_str_operand($cg, $expr->{"left"});
        emit($cg, ", ");
        emit_extern_str_operand($cg, $expr->{"right"});
        emit($cg, ")");
        return;
    }

    # Other expressions - just emit (assume they return char*)
    gen_expression($cg, $expr);
}

# Helper: emit a condition as raw C boolean (avoids strada_new_int allocation)
# Used for while/for/if conditions to prevent memory leaks
func emit_condition(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};

    # Literals: emit 0 or 1 directly
    if ($type == NODE_INT_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
        return;
    }
    if ($type == NODE_NUM_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0" || $val eq "0.0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
        return;
    }

    # Binary operators: handle comparisons and logical ops without allocation
    if ($type == NODE_BINARY_OP()) {
        my str $op = $expr->{"op"};

        # Comparison operators: emit raw C comparison
        if ($op eq "==" || $op eq "!=" || $op eq "<" || $op eq ">" || $op eq "<=" || $op eq ">=") {
            emit($cg, "(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " " . $op . " ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
            return;
        }

        # Logical AND: recurse on both sides
        if ($op eq "&&") {
            emit($cg, "(");
            emit_condition($cg, $expr->{"left"});
            emit($cg, " && ");
            emit_condition($cg, $expr->{"right"});
            emit($cg, ")");
            return;
        }

        # Logical OR: recurse on both sides
        if ($op eq "||") {
            emit($cg, "(");
            emit_condition($cg, $expr->{"left"});
            emit($cg, " || ");
            emit_condition($cg, $expr->{"right"});
            emit($cg, ")");
            return;
        }
    }

    # Unary NOT: recurse
    if ($type == NODE_UNARY_OP()) {
        my str $op = $expr->{"op"};
        if ($op eq "!") {
            emit($cg, "!(");
            emit_condition($cg, $expr->{"operand"});
            emit($cg, ")");
            return;
        }
    }

    # Fallback: use strada_to_bool on the expression
    emit($cg, "strada_to_bool(");
    gen_expression($cg, $expr);
    emit($cg, ")");
}

# Helper: check if expression is a simple variable (doesn't need cleanup)
func is_variable_expr(scalar $expr) int {
    my int $type = $expr->{"type"};
    if ($type == NODE_VARIABLE()) {
        return 1;
    }
    return 0;
}

# Helper: check if expression produces an owned StradaValue* that needs cleanup
# Returns 1 for expressions we KNOW produce owned pointers (literals, concat, arithmetic)
# Returns 0 for unknown types (function calls, etc.) to be safe
func needs_temp_cleanup(scalar $expr) int {
    my int $type = $expr->{"type"};

    # Literals always create owned StradaValue*
    if ($type == NODE_INT_LITERAL() || $type == NODE_NUM_LITERAL() || $type == NODE_STR_LITERAL()) {
        return 1;
    }

    # Binary ops that produce StradaValue*
    if ($type == NODE_BINARY_OP()) {
        my str $op = $expr->{"op"};
        # These ops produce owned StradaValue*
        if ($op eq "." || $op eq "+" || $op eq "-" || $op eq "*" || $op eq "/" ||
            $op eq "%" || $op eq "**" || $op eq "==" || $op eq "!=" ||
            $op eq "<" || $op eq ">" || $op eq "<=" || $op eq ">=" ||
            $op eq "&&" || $op eq "||" || $op eq "&" || $op eq "|" ||
            $op eq "^" || $op eq "<<" || $op eq ">>") {
            return 1;
        }
    }

    # Unary ops that produce StradaValue*
    if ($type == NODE_UNARY_OP()) {
        my str $op = $expr->{"op"};
        if ($op eq "!" || $op eq "-") {
            return 1;
        }
    }

    # Array/hash constructors
    if ($type == NODE_ANON_ARRAY() || $type == NODE_ANON_HASH()) {
        return 1;
    }

    # Reference expressions (\$var, \@arr, \%hash) create owned refs
    if ($type == NODE_REF()) {
        return 1;
    }

    # Ternary produces owned StradaValue* (from either branch)
    if ($type == NODE_TERNARY()) {
        return 1;
    }

    # Variables don't need cleanup (already tracked)
    if ($type == NODE_VARIABLE()) {
        return 0;
    }

    # Function calls: check if it's a known function that returns owned StradaValue*
    if ($type == NODE_CALL()) {
        my str $name = $expr->{"name"};
        # Built-in functions that return owned StradaValue*
        if ($name eq "chr" || $name eq "ord" ||
            $name eq "sys::base64_encode" || $name eq "sys::base64_decode" ||
            $name eq "sys::pack" || $name eq "sys::unpack" ||
            $name eq "sys::ord_byte" || $name eq "sys::get_byte" ||
            $name eq "sys::byte_length" || $name eq "sys::byte_substr" ||
            $name eq "sys::set_byte" ||
            $name eq "substr" || $name eq "length" || $name eq "index" ||
            $name eq "uc" || $name eq "lc" || $name eq "ucfirst" || $name eq "lcfirst" ||
            $name eq "trim" || $name eq "ltrim" || $name eq "rtrim" ||
            $name eq "chomp" || $name eq "chop" ||
            $name eq "sprintf" || $name eq "join" || $name eq "reverse" ||
            $name eq "split" || $name eq "keys" || $name eq "values" ||
            $name eq "defined" || $name eq "exists" ||
            $name eq "ref" || $name eq "bless" ||
            $name eq "size" || $name eq "scalar" ||
            $name eq "push" || $name eq "pop" || $name eq "shift" || $name eq "unshift" ||
            $name eq "delete" ||
            $name eq "abs" || $name eq "int" || $name eq "rand" || $name eq "srand" ||
            $name eq "time" || $name eq "localtime" || $name eq "gmtime" ||
            $name eq "math::sin" || $name eq "math::cos" || $name eq "math::tan" ||
            $name eq "math::sqrt" || $name eq "math::pow" || $name eq "math::log" ||
            $name eq "math::exp" || $name eq "math::floor" || $name eq "math::ceil" ||
            $name eq "math::abs" || $name eq "math::round") {
            return 1;
        }
        # User-defined functions (non-sys::, non-math::) usually return owned values
        # But be conservative for now
        return 0;
    }

    # Default: don't cleanup (be conservative)
    return 0;
}

# Helper: check if return value needs incref before returning
# Returns 1 for variables and borrowed references (need incref to survive scope cleanup)
# Returns 0 for new/owned values (already have correct refcount)
func return_needs_incref(scalar $expr) int {
    my int $type = $expr->{"type"};

    # Variables need incref because scope cleanup will decref them
    if ($type == NODE_VARIABLE()) {
        return 1;
    }

    # Hash and array access return borrowed references - need incref
    if ($type == NODE_HASH_ACCESS() || $type == NODE_SUBSCRIPT()) {
        return 1;
    }

    # Deref expressions returning borrowed refs
    if ($type == NODE_DEREF_HASH() || $type == NODE_DEREF_ARRAY()) {
        return 1;
    }

    # Method calls return owned values
    if ($type == NODE_METHOD_CALL()) {
        return 0;
    }

    # Function calls - most return owned values, but bless() returns its argument
    if ($type == NODE_CALL()) {
        my str $name = $expr->{"name"};
        # bless() returns its first argument, so check if THAT needs incref
        if ($name eq "bless") {
            my scalar $args = $expr->{"args"};
            if ($args && $expr->{"arg_count"} > 0) {
                return return_needs_incref($args->[0]);
            }
            return 0;
        }
        return 0;
    }

    # Literals create owned values
    if ($type == NODE_INT_LITERAL() || $type == NODE_NUM_LITERAL() || $type == NODE_STR_LITERAL()) {
        return 0;
    }

    # Binary ops create owned values
    if ($type == NODE_BINARY_OP()) {
        return 0;
    }

    # Unary ops create owned values
    if ($type == NODE_UNARY_OP()) {
        return 0;
    }

    # Reference/anon constructors create owned values
    if ($type == NODE_REF() || $type == NODE_ANON_ARRAY() || $type == NODE_ANON_HASH()) {
        return 0;
    }

    # Ternary - check both branches (if either needs incref, do incref to be safe)
    if ($type == NODE_TERNARY()) {
        my int $true_needs = return_needs_incref($expr->{"true_expr"});
        my int $false_needs = return_needs_incref($expr->{"false_expr"});
        if ($true_needs == 1 || $false_needs == 1) {
            return 1;
        }
        return 0;
    }

    # Default: incref to be safe (conservative)
    return 1;
}

# Helper: generate a function call with temporary argument cleanup
# c_func_name: the C function to call (e.g., "strada_glob")
# args: array of argument expressions
# arg_count: number of arguments
# Returns nothing, emits code directly
func gen_call_with_arg_cleanup(scalar $cg, str $c_func_name, scalar $args, int $arg_count) void {
    if ($cg->{"cleanup_enabled"} == 0 || $arg_count == 0) {
        # No cleanup needed - emit simple call
        emit($cg, $c_func_name . "(");
        my int $i = 0;
        while ($i < $arg_count) {
            if ($i > 0) {
                emit($cg, ", ");
            }
            gen_expression($cg, $args->[$i]);
            $i = $i + 1;
        }
        emit($cg, ")");
        return;
    }

    # Check which arguments are temporaries (up to 8 args supported)
    my int $temp0 = 0;
    my int $temp1 = 0;
    my int $temp2 = 0;
    my int $temp3 = 0;
    my int $has_temps = 0;

    if ($arg_count > 0 && needs_temp_cleanup($args->[0]) == 1) {
        $temp0 = 1;
        $has_temps = 1;
    }
    if ($arg_count > 1 && needs_temp_cleanup($args->[1]) == 1) {
        $temp1 = 1;
        $has_temps = 1;
    }
    if ($arg_count > 2 && needs_temp_cleanup($args->[2]) == 1) {
        $temp2 = 1;
        $has_temps = 1;
    }
    if ($arg_count > 3 && needs_temp_cleanup($args->[3]) == 1) {
        $temp3 = 1;
        $has_temps = 1;
    }

    if ($has_temps == 0) {
        # No temporaries - emit simple call
        emit($cg, $c_func_name . "(");
        my int $i = 0;
        while ($i < $arg_count) {
            if ($i > 0) {
                emit($cg, ", ");
            }
            gen_expression($cg, $args->[$i]);
            $i = $i + 1;
        }
        emit($cg, ")");
        return;
    }

    # Has temporaries - wrap with cleanup
    emit($cg, "({ ");

    # Declare temp variables for each temporary argument
    if ($temp0 == 1) {
        emit($cg, "StradaValue *__call_arg0 = ");
        gen_expression($cg, $args->[0]);
        emit($cg, "; ");
    }
    if ($temp1 == 1) {
        emit($cg, "StradaValue *__call_arg1 = ");
        gen_expression($cg, $args->[1]);
        emit($cg, "; ");
    }
    if ($temp2 == 1) {
        emit($cg, "StradaValue *__call_arg2 = ");
        gen_expression($cg, $args->[2]);
        emit($cg, "; ");
    }
    if ($temp3 == 1) {
        emit($cg, "StradaValue *__call_arg3 = ");
        gen_expression($cg, $args->[3]);
        emit($cg, "; ");
    }

    # Emit the call with result capture
    emit($cg, "StradaValue *__call_result = " . $c_func_name . "(");
    my int $i = 0;
    while ($i < $arg_count) {
        if ($i > 0) {
            emit($cg, ", ");
        }
        if ($i == 0 && $temp0 == 1) {
            emit($cg, "__call_arg0");
        } elsif ($i == 1 && $temp1 == 1) {
            emit($cg, "__call_arg1");
        } elsif ($i == 2 && $temp2 == 1) {
            emit($cg, "__call_arg2");
        } elsif ($i == 3 && $temp3 == 1) {
            emit($cg, "__call_arg3");
        } else {
            gen_expression($cg, $args->[$i]);
        }
        $i = $i + 1;
    }
    emit($cg, "); ");

    # Decref all temp arguments
    if ($temp0 == 1) {
        emit($cg, "strada_decref(__call_arg0); ");
    }
    if ($temp1 == 1) {
        emit($cg, "strada_decref(__call_arg1); ");
    }
    if ($temp2 == 1) {
        emit($cg, "strada_decref(__call_arg2); ");
    }
    if ($temp3 == 1) {
        emit($cg, "strada_decref(__call_arg3); ");
    }

    # Return the result
    emit($cg, "__call_result; })");
}

func gen_expression(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    my int $in_extern = $cg->{"in_extern"};

    # Integer literal
    if ($type == NODE_INT_LITERAL()) {
        if ($in_extern) {
            emit($cg, $expr->{"value"});
        } else {
            emit($cg, "strada_new_int(" . $expr->{"value"} . ")");
        }
        return;
    }

    # Number literal
    if ($type == NODE_NUM_LITERAL()) {
        if ($in_extern) {
            emit($cg, $expr->{"value"});
        } else {
            emit($cg, "strada_new_num(" . $expr->{"value"} . ")");
        }
        return;
    }
    
    # String literal - use byte-level operations for proper UTF-8 handling
    if ($type == NODE_STR_LITERAL()) {
        # In extern mode, emit raw C string literal
        if ($in_extern) {
            emit($cg, "\"");
        } else {
            emit($cg, "strada_new_str(\"");
        }
        my str $val = $expr->{"value"};
        my int $i = 0;
        my int $len = bytes($val);
        while ($i < $len) {
            my int $code = char_at($val, $i);
            if ($code == 10) {
                emit($cg, "\\n");
            } elsif ($code == 9) {
                emit($cg, "\\t");
            } elsif ($code == 13) {
                emit($cg, "\\r");
            } elsif ($code == 0) {
                emit($cg, "\\0");
            } elsif ($code == 7) {
                emit($cg, "\\a");
            } elsif ($code == 8) {
                emit($cg, "\\b");
            } elsif ($code == 12) {
                emit($cg, "\\f");
            } elsif ($code == 11) {
                emit($cg, "\\v");
            } elsif ($code == 27) {
                emit($cg, "\\033");
            } elsif ($code == 34) {
                emit($cg, "\\\"");
            } elsif ($code == 92) {
                emit($cg, "\\\\");
            } elsif ($code >= 32 && $code <= 126) {
                # Printable ASCII - output as-is
                emit($cg, chr($code));
            } else {
                # Non-printable/high bytes - output raw byte directly
                # The C source file is UTF-8, so raw UTF-8 bytes are valid
                emit($cg, substr_bytes($val, $i, 1));
            }
            $i = $i + 1;
        }
        if ($in_extern) {
            emit($cg, "\"");
        } else {
            emit($cg, "\")");
        }
        return;
    }

    # Undef literal
    if ($type == NODE_UNDEF()) {
        emit($cg, "strada_new_undef()");
        return;
    }

    # Variable
    if ($type == NODE_VARIABLE()) {
        my str $var_name = $expr->{"name"};
        # Escape C keywords in variable names
        my str $c_var_name = escape_c_keyword($var_name);
        # Handle magic variables for map/sort/grep blocks (only when in those contexts)
        if ($var_name eq "_" && ($cg->{"in_map_block"} || $cg->{"in_grep_block"})) {
            emit($cg, "__elem_");
        } elsif ($var_name eq "a" && $cg->{"in_sort_block"}) {
            emit($cg, "__sort_a_");
        } elsif ($var_name eq "b" && $cg->{"in_sort_block"}) {
            emit($cg, "__sort_b_");
        } elsif ($cg->{"in_anon_func"}) {
            # Inside anonymous function - check if it's a param, local, or capture
            my str $param_str = $cg->{"anon_param_str"};
            my str $local_str = $cg->{"anon_local_str"};
            my str $capture_str = $cg->{"anon_capture_str"};
            if (str_contains_name($param_str, $var_name)) {
                # It's a parameter - use directly (escaped for C)
                emit($cg, $c_var_name);
            } elsif (str_contains_name($local_str, $var_name)) {
                # It's a local variable - use directly (escaped for C)
                emit($cg, $c_var_name);
            } else {
                # It's a capture - get or add index
                my int $idx = get_capture_index($capture_str, $var_name);
                if ($idx < 0) {
                    # New capture - add it
                    if ($capture_str eq "") {
                        $cg->{"anon_capture_str"} = $var_name;
                    } else {
                        $cg->{"anon_capture_str"} = $capture_str . "," . $var_name;
                    }
                    $idx = $cg->{"anon_capture_count"};
                    $cg->{"anon_capture_count"} = $idx + 1;
                }
                # Use double pointer dereference for capture-by-reference
                emit($cg, "(*__captures[" . $idx . "])");
            }
        } else {
            emit($cg, $c_var_name);
        }
        return;
    }
    
    # Binary operation
    if ($type == NODE_BINARY_OP()) {
        my str $op = $expr->{"op"};

        # For extern functions, generate raw C arithmetic
        if ($in_extern) {
            if ($op eq "+" || $op eq "-" || $op eq "*" || $op eq "/" || $op eq "%") {
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } elsif ($op eq "**") {
                # Exponentiation in extern - use pow()
                emit($cg, "pow(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, ", ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } elsif ($op eq "==" || $op eq "!=" || $op eq "<" || $op eq ">" || $op eq "<=" || $op eq ">=") {
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } elsif ($op eq "&&" || $op eq "||" || $op eq "&" || $op eq "|" || $op eq "^" || $op eq "<<" || $op eq ">>") {
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } elsif ($op eq ".") {
                # String concatenation in extern mode - use strada_cstr_concat helper
                # Need to convert non-string types to strings
                emit($cg, "strada_cstr_concat(");
                emit_extern_str_operand($cg, $expr->{"left"});
                emit($cg, ", ");
                emit_extern_str_operand($cg, $expr->{"right"});
                emit($cg, ")");
            } else {
                # Fallback for other ops
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            }
            return;
        }

        if ($op eq "+") {
            emit($cg, "strada_new_num(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " + ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "-") {
            emit($cg, "strada_new_num(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " - ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "*") {
            emit($cg, "strada_new_num(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " * ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "/") {
            emit($cg, "strada_new_num(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " / ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "**") {
            # Exponentiation - use pow() from math.h
            emit($cg, "strada_new_num(pow(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, ", ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, "))");
        } elsif ($op eq "%") {
            # Modulo - use fmod for floating point, cast to int for integer result
            emit($cg, "strada_new_int((int64_t)");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " % (int64_t)");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq ".") {
            # Fast concat directly on StradaValues - no intermediate copies
            # When cleanup enabled, properly handle temporary arguments
            my scalar $left = $expr->{"left"};
            my scalar $right = $expr->{"right"};
            my int $left_is_temp = 0;
            my int $right_is_temp = 0;
            if ($cg->{"cleanup_enabled"} == 1) {
                if (needs_temp_cleanup($left) == 1) {
                    $left_is_temp = 1;
                }
                if (needs_temp_cleanup($right) == 1) {
                    $right_is_temp = 1;
                }
            }

            if ($left_is_temp == 1 || $right_is_temp == 1) {
                emit($cg, "({ ");
                if ($left_is_temp == 1) {
                    emit($cg, "StradaValue *__concat_l = ");
                    gen_expression($cg, $left);
                    emit($cg, "; ");
                }
                if ($right_is_temp == 1) {
                    emit($cg, "StradaValue *__concat_r = ");
                    gen_expression($cg, $right);
                    emit($cg, "; ");
                }
                emit($cg, "StradaValue *__concat_res = strada_concat_sv(");
                if ($left_is_temp == 1) {
                    emit($cg, "__concat_l");
                } else {
                    gen_expression($cg, $left);
                }
                emit($cg, ", ");
                if ($right_is_temp == 1) {
                    emit($cg, "__concat_r");
                } else {
                    gen_expression($cg, $right);
                }
                emit($cg, "); ");
                if ($left_is_temp == 1) {
                    emit($cg, "strada_decref(__concat_l); ");
                }
                if ($right_is_temp == 1) {
                    emit($cg, "strada_decref(__concat_r); ");
                }
                emit($cg, "__concat_res; })");
            } else {
                emit($cg, "strada_concat_sv(");
                gen_expression($cg, $left);
                emit($cg, ", ");
                gen_expression($cg, $right);
                emit($cg, ")");
            }
        } elsif ($op eq "==") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " == ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "!=") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " != ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "<") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " < ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq ">") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " > ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "<=") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " <= ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq ">=") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " >= ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "&&") {
            emit($cg, "strada_new_int(");
            emit_bool_operand($cg, $expr->{"left"});
            emit($cg, " && ");
            emit_bool_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "||") {
            emit($cg, "strada_new_int(");
            emit_bool_operand($cg, $expr->{"left"});
            emit($cg, " || ");
            emit_bool_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "&") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " & ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "|") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " | ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "^") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " ^ ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "<<") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " << ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq ">>") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " >> ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "eq") {
            emit($cg, "strada_new_int(strcmp(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, ")) == 0)");
        } elsif ($op eq "ne") {
            emit($cg, "strada_new_int(strcmp(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, ")) != 0)");
        } elsif ($op eq "lt") {
            emit($cg, "strada_new_int(strcmp(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, ")) < 0)");
        } elsif ($op eq "gt") {
            emit($cg, "strada_new_int(strcmp(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, ")) > 0)");
        } elsif ($op eq "le") {
            emit($cg, "strada_new_int(strcmp(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, ")) <= 0)");
        } elsif ($op eq "ge") {
            emit($cg, "strada_new_int(strcmp(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, ")) >= 0)");
        } elsif ($op eq "<=>") {
            # Spaceship operator: returns -1, 0, or 1
            emit($cg, "strada_new_int(({ double __l = strada_to_num(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "); double __r = strada_to_num(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, "); (__l < __r) ? -1 : ((__l > __r) ? 1 : 0); }))");
        } elsif ($op eq "=~") {
            # Regex match with string pattern (no flags)
            emit($cg, "strada_new_int(strada_regex_match_with_capture(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, "), NULL))");
        } elsif ($op eq "!~") {
            # Negated regex match with string pattern (no flags)
            emit($cg, "strada_new_int(!strada_regex_match_with_capture(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, "), NULL))");
        }
        return;
    }

    # Regex match: $str =~ /pattern/flags or $str !~ /pattern/flags
    if ($type == NODE_REGEX_MATCH()) {
        my str $op = $expr->{"op"};
        my str $pattern = $expr->{"pattern"};
        my str $flags = $expr->{"flags"};

        if ($op eq "=~") {
            emit($cg, "strada_new_int(strada_regex_match_with_capture(strada_to_str(");
        } else {
            emit($cg, "strada_new_int(!strada_regex_match_with_capture(strada_to_str(");
        }
        gen_expression($cg, $expr->{"target"});
        emit($cg, "), ");

        # Check if pattern contains variable interpolation ($)
        my int $has_interp = 0;
        my int $check_i = 0;
        my int $pat_len = length($pattern);
        while ($check_i < $pat_len) {
            my str $ch = substr($pattern, $check_i, 1);
            if ($ch eq "$") {
                $has_interp = 1;
                last;
            }
            $check_i = $check_i + 1;
        }

        if ($has_interp == 1) {
            # Pattern has variable interpolation - build at runtime
            # Parse and generate concatenation expression
            emit($cg, "strada_to_str(");
            gen_regex_interpolated_pattern($cg, $pattern);
            emit($cg, ")");
        } else {
            # Static pattern - emit as literal string
            emit($cg, "\"");
            my int $i = 0;
            my int $len = length($pattern);
            while ($i < $len) {
                my str $ch = substr($pattern, $i, 1);
                if ($ch eq "\\") {
                    emit($cg, "\\\\");
                } elsif ($ch eq "\"") {
                    emit($cg, "\\\"");
                } elsif ($ch eq "\n") {
                    emit($cg, "\\n");
                } elsif ($ch eq "\t") {
                    emit($cg, "\\t");
                } else {
                    emit($cg, $ch);
                }
                $i = $i + 1;
            }
            emit($cg, "\"");
        }
        emit($cg, ", ");
        # Pass flags (or NULL if empty)
        if (length($flags) > 0) {
            emit($cg, "\"" . $flags . "\"");
        } else {
            emit($cg, "NULL");
        }
        emit($cg, "))");
        return;
    }

    # Regex substitution: $str =~ s/pattern/replacement/flags
    if ($type == NODE_REGEX_SUBST()) {
        my str $pattern = $expr->{"pattern"};
        my str $replacement = $expr->{"replacement"};
        my str $flags = $expr->{"flags"};

        # Check for global flag
        my int $global = 0;
        if (index($flags, "g") >= 0) {
            $global = 1;
        }

        # Generate: target = strada_new_str(strada_regex_replace[_all](strada_to_str(target), pattern, replacement, flags))
        gen_expression($cg, $expr->{"target"});
        emit($cg, " = ");

        if ($global == 1) {
            emit($cg, "strada_new_str(strada_regex_replace_all(strada_to_str(");
        } else {
            emit($cg, "strada_new_str(strada_regex_replace(strada_to_str(");
        }
        gen_expression($cg, $expr->{"target"});
        emit($cg, "), \"");
        # Escape pattern
        my int $i = 0;
        my int $len = length($pattern);
        while ($i < $len) {
            my str $ch = substr($pattern, $i, 1);
            if ($ch eq "\\") {
                emit($cg, "\\\\");
            } elsif ($ch eq "\"") {
                emit($cg, "\\\"");
            } elsif ($ch eq "\n") {
                emit($cg, "\\n");
            } elsif ($ch eq "\t") {
                emit($cg, "\\t");
            } elsif ($ch eq "\r") {
                emit($cg, "\\r");
            } else {
                emit($cg, $ch);
            }
            $i = $i + 1;
        }
        emit($cg, "\", \"");
        # Escape replacement
        $i = 0;
        $len = length($replacement);
        while ($i < $len) {
            my str $ch = substr($replacement, $i, 1);
            if ($ch eq "\\") {
                emit($cg, "\\\\");
            } elsif ($ch eq "\"") {
                emit($cg, "\\\"");
            } elsif ($ch eq "\n") {
                emit($cg, "\\n");
            } elsif ($ch eq "\t") {
                emit($cg, "\\t");
            } elsif ($ch eq "\r") {
                emit($cg, "\\r");
            } else {
                emit($cg, $ch);
            }
            $i = $i + 1;
        }
        emit($cg, "\", ");
        # Pass flags (or NULL if empty)
        if (length($flags) > 0) {
            emit($cg, "\"" . $flags . "\"");
        } else {
            emit($cg, "NULL");
        }
        emit($cg, "))");
        return;
    }

    # Unary operation
    if ($type == NODE_UNARY_OP()) {
        my str $op = $expr->{"op"};
        if ($op eq "-") {
            emit($cg, "strada_new_num(-strada_to_num(");
            gen_expression($cg, $expr->{"operand"});
            emit($cg, "))");
        } elsif ($op eq "!") {
            emit($cg, "strada_new_int(!strada_to_bool(");
            gen_expression($cg, $expr->{"operand"});
            emit($cg, "))");
        } elsif ($op eq "~") {
            emit($cg, "strada_new_int(~strada_to_int(");
            gen_expression($cg, $expr->{"operand"});
            emit($cg, "))");
        }
        return;
    }

    # Increment/decrement (++ and --)
    if ($type == NODE_INCREMENT()) {
        my str $op = $expr->{"op"};
        my int $is_prefix = $expr->{"is_prefix"};
        my scalar $operand = $expr->{"operand"};
        my int $operand_type = $operand->{"type"};

        # For simple variables, use address-of
        if ($operand_type == NODE_VARIABLE()) {
            if ($is_prefix == 1) {
                if ($op eq "++") {
                    emit($cg, "strada_preincr(&");
                } else {
                    emit($cg, "strada_predecr(&");
                }
            } else {
                if ($op eq "++") {
                    emit($cg, "strada_postincr(&");
                } else {
                    emit($cg, "strada_postdecr(&");
                }
            }
            gen_expression($cg, $operand);
            emit($cg, ")");
        } else {
            # For complex expressions, fall back to inline increment
            # This works for statement context but returns wrong value for postfix
            emit($cg, "(");
            gen_expression($cg, $operand);
            emit($cg, " = strada_new_num(strada_to_num(");
            gen_expression($cg, $operand);
            if ($op eq "++") {
                emit($cg, ") + 1))");
            } else {
                emit($cg, ") - 1))");
            }
        }
        return;
    }

    # Function call
    if ($type == NODE_CALL()) {
        my str $name = $expr->{"name"};
        
        # Built-in functions
        if ($name eq "say") {
            if ($expr->{"arg_count"} > 0) {
                my scalar $args = $expr->{"args"};
                my scalar $arg = $args->[0];
                # If cleanup enabled and arg is a temporary, wrap to decref after
                if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($arg) == 1) {
                    emit($cg, "({ StradaValue *__say_tmp = ");
                    gen_expression($cg, $arg);
                    emit($cg, "; strada_say(__say_tmp); strada_decref(__say_tmp); })");
                } else {
                    emit($cg, "strada_say(");
                    gen_expression($cg, $arg);
                    emit($cg, ")");
                }
            } else {
                emit($cg, "strada_say(strada_new_str(\"\"))");
            }
            return;
        }

        if ($name eq "print") {
            if ($expr->{"arg_count"} > 0) {
                my scalar $args = $expr->{"args"};
                my scalar $arg = $args->[0];
                # If cleanup enabled and arg is a temporary, wrap to decref after
                if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($arg) == 1) {
                    emit($cg, "({ StradaValue *__print_tmp = ");
                    gen_expression($cg, $arg);
                    emit($cg, "; strada_print(__print_tmp); strada_decref(__print_tmp); })");
                } else {
                    emit($cg, "strada_print(");
                    gen_expression($cg, $arg);
                    emit($cg, ")");
                }
            } else {
                emit($cg, "strada_print(strada_new_str(\"\"))");
            }
            return;
        }
        
        if ($name eq "length") {
            # Binary-safe length using struct_size
            emit($cg, "strada_new_int(strada_length_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "bytes") {
            emit($cg, "strada_new_int(strada_bytes(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }

        if ($name eq "char_at") {
            emit($cg, "strada_char_at(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "substr_bytes") {
            emit($cg, "strada_substr_bytes(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), ");
            if ($expr->{"arg_count"} > 2) {
                emit($cg, "strada_to_int(");
                gen_expression($cg, $args->[2]);
                emit($cg, ")");
            } else {
                emit($cg, "-1");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "substr") {
            emit($cg, "strada_substr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), ");
            if ($expr->{"arg_count"} > 2) {
                emit($cg, "strada_to_int(");
                gen_expression($cg, $args->[2]);
                emit($cg, ")");
            } else {
                emit($cg, "-1");
            }
            emit($cg, ")");
            return;
        }
        
        if ($name eq "push") {
            emit($cg, "(strada_array_push(strada_deref_array(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), ");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_new_undef())");
            return;
        }

        # reserve - pre-allocate array capacity
        if ($name eq "reserve") {
            emit($cg, "(strada_reserve_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")), strada_new_undef())");
            return;
        }

        if ($name eq "size") {
            emit($cg, "strada_new_int(strada_size(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "pop") {
            emit($cg, "strada_array_pop(strada_deref_array(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "shift") {
            emit($cg, "strada_array_shift(strada_deref_array(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "unshift") {
            emit($cg, "(strada_array_unshift(strada_deref_array(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), ");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_new_undef())");
            return;
        }

        if ($name eq "sort") {
            emit($cg, "strada_sort(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "nsort") {
            emit($cg, "strada_nsort(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "split") {
            # split(pattern, string) - like Perl
            # strada_regex_split(str, pattern) - runtime signature
            emit($cg, "(({ StradaValue *__sv = strada_new_array(); ");
            emit($cg, "__sv->value.av = strada_regex_split(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[1]);  # string comes first in runtime
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[0]);  # pattern comes second in runtime
            emit($cg, ")); __sv; }))");
            return;
        }
        
        if ($name eq "join") {
            emit($cg, "strada_new_str(strada_join(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_deref_array(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }
        
        if ($name eq "keys") {
            emit($cg, "strada_new_array_from_av(strada_hash_keys(strada_deref_hash(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        if ($name eq "values") {
            emit($cg, "strada_new_array_from_av(strada_hash_values(strada_deref_hash(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        if ($name eq "exists") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            
            # Check if single arg is a hash access node
            if ($expr->{"arg_count"} == 1 && $arg0->{"type"} == NODE_HASH_ACCESS()) {
                emit($cg, "strada_new_int(strada_hash_exists(strada_deref_hash(");
                gen_expression($cg, $arg0->{"hash"});
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $arg0->{"key"});
                emit($cg, ")))");
            } else {
                # Two arg form: exists(hash, key)
                emit($cg, "strada_new_int(strada_hash_exists(strada_deref_hash(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, ")))");
            }
            return;
        }
        
        if ($name eq "delete") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            
            # Check if single arg is a hash access node
            if ($expr->{"arg_count"} == 1 && $arg0->{"type"} == NODE_HASH_ACCESS()) {
                emit($cg, "strada_hash_delete(strada_deref_hash(");
                gen_expression($cg, $arg0->{"hash"});
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $arg0->{"key"});
                emit($cg, "))");
            } else {
                emit($cg, "strada_hash_delete(strada_deref_hash(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, "))");
            }
            return;
        }
        
        if ($name eq "hash_new") {
            emit($cg, "strada_new_hash()");
            return;
        }
        
        if ($name eq "hash_get") {
            emit($cg, "strada_hash_get(strada_deref_hash(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "hash_set") {
            emit($cg, "strada_hash_set(strada_deref_hash(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }
        
        if ($name eq "array_new") {
            emit($cg, "strada_new_array()");
            return;
        }
        
        if ($name eq "sys::cstruct_new") {
            emit($cg, "strada_new_hash()");
            return;
        }
        
        if ($name eq "defined") {
            emit($cg, "strada_defined(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        if ($name eq "ref") {
            emit($cg, "strada_new_str(strada_reftype(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "dumper") {
            emit($cg, "strada_dumper(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "dumper_str") {
            emit($cg, "strada_dumper_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "exit") {
            emit($cg, "exit(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # Process control functions
        if ($name eq "sys::sleep") {
            emit($cg, "strada_sleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::usleep") {
            emit($cg, "strada_usleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fork") {
            emit($cg, "strada_fork()");
            return;
        }

        if ($name eq "sys::wait") {
            emit($cg, "strada_wait()");
            return;
        }

        if ($name eq "sys::waitpid") {
            emit($cg, "strada_waitpid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "strada_new_int(0)");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpid") {
            emit($cg, "strada_getpid()");
            return;
        }

        if ($name eq "sys::getppid") {
            emit($cg, "strada_getppid()");
            return;
        }

        # Pipe and IPC functions
        if ($name eq "sys::pipe") {
            emit($cg, "strada_pipe()");
            return;
        }

        if ($name eq "sys::dup2") {
            emit($cg, "strada_dup2(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::close_fd") {
            emit($cg, "strada_close_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::exec") {
            emit($cg, "strada_exec(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "exec_argv") {
            emit($cg, "strada_exec_argv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::system") {
            emit($cg, "strada_system(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::system_argv") {
            emit($cg, "strada_system_argv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setprocname") {
            emit($cg, "strada_setprocname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getprocname") {
            emit($cg, "strada_getprocname()");
            return;
        }

        if ($name eq "sys::setproctitle") {
            emit($cg, "strada_setproctitle(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getproctitle") {
            emit($cg, "strada_getproctitle()");
            return;
        }

        if ($name eq "sys::read_fd") {
            emit($cg, "strada_read_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::write_fd") {
            emit($cg, "strada_write_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::read_all_fd") {
            emit($cg, "strada_read_all_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "fdopen_read") {
            emit($cg, "strada_fdopen_read(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "fdopen_write") {
            emit($cg, "strada_fdopen_write(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # POSIX functions
        if ($name eq "sys::getenv") {
            emit($cg, "strada_getenv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setenv") {
            emit($cg, "strada_setenv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::unsetenv") {
            emit($cg, "strada_unsetenv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # sys::array_default_capacity - get or set default array capacity
        if ($name eq "sys::array_default_capacity") {
            my scalar $args = $expr->{"args"};
            my int $nargs = size($args);
            if ($nargs == 0) {
                # Get current default capacity
                emit($cg, "strada_new_int(strada_get_array_default_capacity())");
            } else {
                # Set new default capacity and return it
                emit($cg, "(strada_set_array_default_capacity(strada_to_int(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")), strada_new_int(strada_get_array_default_capacity()))");
            }
            return;
        }

        # sys::hash_default_capacity - get or set default hash bucket count
        if ($name eq "sys::hash_default_capacity") {
            my scalar $args = $expr->{"args"};
            my int $nargs = size($args);
            if ($nargs == 0) {
                # Get current default capacity
                emit($cg, "strada_new_int(strada_get_hash_default_capacity())");
            } else {
                # Set new default capacity and return it
                emit($cg, "(strada_set_hash_default_capacity(strada_to_int(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")), strada_new_int(strada_get_hash_default_capacity()))");
            }
            return;
        }

        if ($name eq "sys::getcwd") {
            emit($cg, "strada_getcwd()");
            return;
        }

        if ($name eq "sys::chdir") {
            emit($cg, "strada_chdir(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mkdir") {
            emit($cg, "strada_mkdir(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "strada_new_int(0755)");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::rmdir") {
            emit($cg, "strada_rmdir(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::unlink") {
            emit($cg, "strada_unlink(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::link") {
            emit($cg, "strada_link(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::symlink") {
            emit($cg, "strada_symlink(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::readlink") {
            emit($cg, "strada_readlink(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::rename") {
            emit($cg, "strada_rename(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::chmod") {
            emit($cg, "strada_chmod(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::access") {
            emit($cg, "strada_access(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::umask") {
            emit($cg, "strada_umask(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getuid") {
            emit($cg, "strada_getuid()");
            return;
        }

        if ($name eq "sys::geteuid") {
            emit($cg, "strada_geteuid()");
            return;
        }

        if ($name eq "sys::getgid") {
            emit($cg, "strada_getgid()");
            return;
        }

        if ($name eq "sys::getegid") {
            emit($cg, "strada_getegid()");
            return;
        }

        if ($name eq "sys::kill") {
            emit($cg, "strada_kill(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::signal") {
            emit($cg, "strada_signal(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::alarm") {
            emit($cg, "strada_alarm(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::stat") {
            emit($cg, "strada_stat(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::lstat") {
            emit($cg, "strada_lstat(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::isatty") {
            emit($cg, "strada_isatty(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::strerror") {
            emit($cg, "strada_strerror(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::errno") {
            emit($cg, "strada_errno()");
            return;
        }

        if ($name eq "sys::time") {
            emit($cg, "strada_time()");
            return;
        }

        if ($name eq "sys::localtime") {
            emit($cg, "strada_localtime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::gmtime") {
            emit($cg, "strada_gmtime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mktime") {
            emit($cg, "strada_mktime(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::strftime") {
            emit($cg, "strada_strftime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($arg_count > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ctime") {
            emit($cg, "strada_ctime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::sleep") {
            emit($cg, "strada_sleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::usleep") {
            emit($cg, "strada_usleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::gettimeofday") {
            emit($cg, "strada_gettimeofday()");
            return;
        }

        if ($name eq "sys::hires_time") {
            emit($cg, "strada_hires_time()");
            return;
        }

        # Memory profiler functions
        if ($name eq "sys::memprof_enable") {
            emit($cg, "(strada_memprof_enable(), strada_new_undef())");
            return;
        }
        if ($name eq "sys::memprof_disable") {
            emit($cg, "(strada_memprof_disable(), strada_new_undef())");
            return;
        }
        if ($name eq "sys::memprof_report") {
            emit($cg, "(strada_memprof_report(), strada_new_undef())");
            return;
        }
        if ($name eq "sys::memprof_reset") {
            emit($cg, "(strada_memprof_reset(), strada_new_undef())");
            return;
        }

        if ($name eq "sys::tv_interval") {
            emit($cg, "strada_tv_interval(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($arg_count > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::nanosleep") {
            emit($cg, "strada_nanosleep_ns(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clock_gettime") {
            emit($cg, "strada_clock_gettime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clock_getres") {
            emit($cg, "strada_clock_getres(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_open") {
            emit($cg, "strada_dl_open(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "strada_dl_open_raw") {
            emit($cg, "strada_dl_open_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_sym") {
            emit($cg, "strada_dl_sym(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_close") {
            emit($cg, "strada_dl_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_error") {
            emit($cg, "strada_dl_error()");
            return;
        }

        if ($name eq "sys::dl_call_int") {
            emit($cg, "strada_dl_call_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_num") {
            emit($cg, "strada_dl_call_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_str") {
            emit($cg, "strada_dl_call_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_void") {
            emit($cg, "strada_dl_call_void(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_int_sv") {
            emit($cg, "strada_dl_call_int_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_str_sv") {
            emit($cg, "strada_dl_call_str_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_void_sv") {
            emit($cg, "strada_dl_call_void_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_sv") {
            emit($cg, "strada_dl_call_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_export_info") {
            emit($cg, "strada_dl_call_export_info(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_version") {
            emit($cg, "strada_dl_call_version(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Pointer access for FFI
        if ($name eq "sys::int_ptr") {
            emit($cg, "strada_int_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::num_ptr") {
            emit($cg, "strada_num_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::str_ptr") {
            emit($cg, "strada_str_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_int") {
            emit($cg, "strada_ptr_deref_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_num") {
            emit($cg, "strada_ptr_deref_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_str") {
            emit($cg, "strada_ptr_deref_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_int") {
            emit($cg, "strada_ptr_set_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_num") {
            emit($cg, "strada_ptr_set_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::rand") {
            emit($cg, "strada_rand()");
            return;
        }

        if ($name eq "sys::exit_status") {
            emit($cg, "strada_exit_status(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Thread functions
        if ($name eq "thread::create") {
            emit($cg, "strada_thread_create(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::join") {
            emit($cg, "strada_thread_join(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::detach") {
            emit($cg, "strada_thread_detach(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::self") {
            emit($cg, "strada_thread_self()");
            return;
        }

        if ($name eq "thread::mutex_new") {
            emit($cg, "strada_mutex_new()");
            return;
        }

        if ($name eq "thread::mutex_lock") {
            emit($cg, "strada_mutex_lock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::mutex_trylock") {
            emit($cg, "strada_mutex_trylock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::mutex_unlock") {
            emit($cg, "strada_mutex_unlock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::mutex_destroy") {
            emit($cg, "strada_mutex_destroy(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_new") {
            emit($cg, "strada_cond_new()");
            return;
        }

        if ($name eq "thread::cond_wait") {
            emit($cg, "strada_cond_wait(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_signal") {
            emit($cg, "strada_cond_signal(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_broadcast") {
            emit($cg, "strada_cond_broadcast(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_destroy") {
            emit($cg, "strada_cond_destroy(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Directory functions
        if ($name eq "sys::readdir") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_readdir", $args, 1);
            return;
        }

        if ($name eq "sys::readdir_full") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_readdir_full", $args, 1);
            return;
        }

        if ($name eq "sys::is_dir") {
            emit($cg, "strada_is_dir(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::is_file") {
            emit($cg, "strada_is_file(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::file_size") {
            emit($cg, "strada_file_size(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Math functions
        if ($name eq "math::sin") {
            emit($cg, "strada_sin(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::cos") {
            emit($cg, "strada_cos(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::tan") {
            emit($cg, "strada_tan(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::asin") {
            emit($cg, "strada_asin(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::acos") {
            emit($cg, "strada_acos(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::atan") {
            emit($cg, "strada_atan(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::atan2") {
            emit($cg, "strada_atan2(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::log") {
            emit($cg, "strada_log(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::log10") {
            emit($cg, "strada_log10(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::exp") {
            emit($cg, "strada_exp(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::pow") {
            emit($cg, "strada_pow(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::floor") {
            emit($cg, "strada_floor(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::ceil") {
            emit($cg, "strada_ceil(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::round") {
            emit($cg, "strada_round(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::fabs") {
            emit($cg, "strada_fabs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::fmod") {
            emit($cg, "strada_fmod(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::sinh") {
            emit($cg, "strada_sinh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::cosh") {
            emit($cg, "strada_cosh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::tanh") {
            emit($cg, "strada_tanh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # File seek functions
        if ($name eq "sys::seek") {
            emit($cg, "strada_seek(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 2) {
                gen_expression($cg, $args->[2]);
            } else {
                emit($cg, "strada_new_int(0)");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::tell") {
            emit($cg, "strada_tell(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::rewind") {
            emit($cg, "strada_rewind(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::eof") {
            emit($cg, "strada_eof(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::flush") {
            emit($cg, "strada_flush(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::readline") {
            emit($cg, "strada_read_line(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # DNS/Hostname functions
        if ($name eq "sys::gethostbyname") {
            emit($cg, "strada_gethostbyname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::gethostbyname_all") {
            emit($cg, "strada_gethostbyname_all(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::gethostname") {
            emit($cg, "strada_gethostname()");
            return;
        }

        if ($name eq "sys::getaddrinfo") {
            emit($cg, "strada_getaddrinfo_first(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "strada_new_str(\"\")");
            }
            emit($cg, ")");
            return;
        }

        # Path functions
        if ($name eq "sys::realpath") {
            emit($cg, "strada_realpath(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dirname") {
            emit($cg, "strada_dirname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::basename") {
            emit($cg, "strada_basename(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::glob") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_glob", $args, 1);
            return;
        }

        if ($name eq "sys::fnmatch") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_fnmatch", $args, 2);
            return;
        }

        if ($name eq "sys::file_ext") {
            emit($cg, "strada_file_ext(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::path_join") {
            emit($cg, "strada_path_join(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "int") {
            emit($cg, "strada_new_int(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "chr") {
            # Use strada_chr_sv for binary-safe chr that handles NUL bytes
            # Use emit_int_operand to avoid leaking memoria for integer literals
            emit($cg, "strada_chr_sv(");
            my scalar $args = $expr->{"args"};
            emit_int_operand($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        if ($name eq "ord") {
            emit($cg, "strada_new_int(strada_ord(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }

        # ord_byte - binary-safe ord that returns raw byte value 0-255
        if ($name eq "sys::ord_byte") {
            emit($cg, "strada_new_int(strada_ord_byte(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # get_byte - get byte at position (0-indexed), returns 0-255 or -1
        if ($name eq "sys::get_byte") {
            emit($cg, "strada_new_int(strada_get_byte(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # set_byte - set byte at position, returns new string
        if ($name eq "sys::set_byte") {
            emit($cg, "strada_set_byte(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[1]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        # byte_length - get byte length (not UTF-8 character count)
        if ($name eq "sys::byte_length") {
            emit($cg, "strada_new_int(strada_byte_length(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # byte_substr - substring by byte positions
        if ($name eq "sys::byte_substr") {
            emit($cg, "strada_byte_substr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "))");
            return;
        }

        # pack - pack values into binary string (Perl-like)
        # sys::pack($fmt, $val1, $val2, ...) -> strada_pack(fmt, array_of_values)
        if ($name eq "sys::pack") {
            emit($cg, "strada_pack(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), ");
            # Build array from remaining arguments
            my int $value_count = $expr->{"arg_count"} - 1;
            emit($cg, "strada_anon_array(" . $value_count);
            my int $i = 1;
            while ($i < $expr->{"arg_count"}) {
                emit($cg, ", ");
                gen_expression($cg, $args->[$i]);
                $i = $i + 1;
            }
            emit($cg, "))");
            return;
        }

        # unpack - unpack binary string to array (Perl-like)
        if ($name eq "sys::unpack") {
            emit($cg, "strada_unpack(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # base64_encode - encode string to base64
        if ($name eq "sys::base64_encode") {
            emit($cg, "strada_base64_encode(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # base64_decode - decode base64 to string
        if ($name eq "sys::base64_decode") {
            emit($cg, "strada_base64_decode(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "uc" || $name eq "upper") {
            emit($cg, "strada_new_str(strada_uc(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        if ($name eq "lc" || $name eq "lower") {
            emit($cg, "strada_new_str(strada_lc(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        if ($name eq "index") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count == 3) {
                # 3-argument form: index(string, substring, offset)
                emit($cg, "strada_new_int(strada_index_offset(strada_to_str(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, "), strada_to_int(");
                gen_expression($cg, $args->[2]);
                emit($cg, ")))");
            } else {
                # 2-argument form: index(string, substring)
                emit($cg, "strada_new_int(strada_index(strada_to_str(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, ")))");
            }
            return;
        }
        
        if ($name eq "sprintf") {
            emit($cg, "strada_sprintf(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            my int $i = 1;
            while ($i < $expr->{"arg_count"}) {
                emit($cg, ", strada_to_str(");
                gen_expression($cg, $args->[$i]);
                emit($cg, ")");
                $i = $i + 1;
            }
            emit($cg, ")");
            return;
        }
        
        if ($name eq "printf") {
            emit($cg, "strada_printf(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            my int $i = 1;
            while ($i < $expr->{"arg_count"}) {
                emit($cg, ", strada_to_str(");
                gen_expression($cg, $args->[$i]);
                emit($cg, ")");
                $i = $i + 1;
            }
            emit($cg, ")");
            return;
        }
        
        if ($name eq "warn") {
            emit($cg, "strada_warn(\"%s\", strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "sys::slurp" || $name eq "slurp") {
            emit($cg, "strada_slurp(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "sys::slurp_fh") {
            emit($cg, "strada_slurp_fh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::slurp_fd") {
            emit($cg, "strada_slurp_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::spew" || $name eq "spew") {
            emit($cg, "strada_spew(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        if ($name eq "sys::spew_fh") {
            emit($cg, "strada_spew_fh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::spew_fd") {
            emit($cg, "strada_spew_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # StringBuilder functions for O(1) amortized append
        if ($name eq "sb_new") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                emit($cg, "strada_sb_new_cap(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            } else {
                emit($cg, "strada_sb_new()");
            }
            return;
        }

        if ($name eq "sb_append") {
            emit($cg, "(strada_sb_append(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_new_undef())");
            return;
        }

        if ($name eq "sb_to_string") {
            emit($cg, "strada_sb_to_string(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sb_length") {
            emit($cg, "strada_sb_length(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sb_clear") {
            emit($cg, "(strada_sb_clear(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_new_undef())");
            return;
        }

        if ($name eq "sb_free") {
            emit($cg, "(strada_sb_free(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_new_undef())");
            return;
        }

        # open(filename, mode) - open file for reading/writing/appending
        if ($name eq "sys::open") {
            emit($cg, "strada_open(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        if ($name eq "sys::open_fd") {
            emit($cg, "strada_open_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # close(fh) - close file handle
        if ($name eq "sys::close") {
            emit($cg, "strada_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # write_fd(fd, str) - write to file descriptor
        if ($name eq "write_fd" || $name eq "sys::write_fd") {
            emit($cg, "strada_write_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # close_fd(fd) - close file descriptor
        if ($name eq "close_fd" || $name eq "sys::close_fd") {
            emit($cg, "strada_close_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # getpid() - get process ID
        if ($name eq "getpid" || $name eq "sys::getpid") {
            emit($cg, "strada_new_int(getpid())");
            return;
        }

        # unlink(path) - delete file
        if ($name eq "unlink" || $name eq "sys::unlink") {
            emit($cg, "strada_unlink(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # fwrite(fh, content) - write to file handle
        if ($name eq "sys::fwrite") {
            emit($cg, "strada_write_file(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # fread(fh) - read entire file from handle
        if ($name eq "sys::fread") {
            emit($cg, "strada_read_file(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "die") {
            emit($cg, "strada_die(\"%s\", strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "throw") {
            emit($cg, "strada_throw_value(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # scalar() - get array length as int
        if ($name eq "scalar") {
            emit($cg, "strada_new_int(strada_array_length(strada_deref_array(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # is_ref / is_refto - check if value is a reference
        if ($name eq "is_ref" || $name eq "is_refto") {
            emit($cg, "strada_new_int(strada_is_ref(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # reftype - get reference type string
        if ($name eq "reftype") {
            emit($cg, "strada_new_str(strada_reftype(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # refto - create a reference
        if ($name eq "refto") {
            emit($cg, "strada_new_ref(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", '$')");
            return;
        }
        
        # derefto - dereference
        if ($name eq "derefto" || $name eq "deref") {
            emit($cg, "strada_deref(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # deref_array - dereference to array (returns StradaValue*)
        if ($name eq "deref_array") {
            emit($cg, "strada_deref_array_value(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # deref_hash - dereference to hash (returns StradaValue*)
        if ($name eq "deref_hash") {
            emit($cg, "strada_deref_hash_value(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # deref_set - set value through a scalar reference
        if ($name eq "deref_set") {
            emit($cg, "strada_deref_set(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # clone - deep copy a value
        if ($name eq "clone") {
            emit($cg, "strada_clone(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # typeof - get type name string
        if ($name eq "typeof") {
            emit($cg, "strada_typeof(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # abs - absolute value
        if ($name eq "math::abs") {
            emit($cg, "strada_abs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # sqrt - square root
        if ($name eq "math::sqrt") {
            emit($cg, "strada_sqrt(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # rand - random number
        if ($name eq "math::rand") {
            emit($cg, "strada_rand()");
            return;
        }
        
        # time - current timestamp
        if ($name eq "sys::time") {
            emit($cg, "strada_time()");
            return;
        }

        # localtime - convert timestamp to local time hash
        if ($name eq "sys::localtime") {
            emit($cg, "strada_localtime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # gmtime - convert timestamp to UTC time hash
        if ($name eq "sys::gmtime") {
            emit($cg, "strada_gmtime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # mktime - convert time hash to timestamp
        if ($name eq "sys::mktime") {
            emit($cg, "strada_mktime(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # strftime - format time
        if ($name eq "sys::strftime") {
            emit($cg, "strada_strftime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($arg_count > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # ctime - convert timestamp to string
        if ($name eq "sys::ctime") {
            emit($cg, "strada_ctime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # sleep - sleep for seconds
        if ($name eq "sys::sleep") {
            emit($cg, "strada_sleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # usleep - sleep for microseconds
        if ($name eq "sys::usleep") {
            emit($cg, "strada_usleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # gettimeofday - high-res time
        if ($name eq "sys::gettimeofday") {
            emit($cg, "strada_gettimeofday()");
            return;
        }

        # hires_time - floating point seconds
        if ($name eq "sys::hires_time") {
            emit($cg, "strada_hires_time()");
            return;
        }

        # Memory profiler functions
        if ($name eq "sys::memprof_enable") {
            emit($cg, "(strada_memprof_enable(), strada_new_undef())");
            return;
        }
        if ($name eq "sys::memprof_disable") {
            emit($cg, "(strada_memprof_disable(), strada_new_undef())");
            return;
        }
        if ($name eq "sys::memprof_report") {
            emit($cg, "(strada_memprof_report(), strada_new_undef())");
            return;
        }
        if ($name eq "sys::memprof_reset") {
            emit($cg, "(strada_memprof_reset(), strada_new_undef())");
            return;
        }

        # tv_interval - time interval
        if ($name eq "sys::tv_interval") {
            emit($cg, "strada_tv_interval(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($arg_count > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # nanosleep - sleep nanoseconds
        if ($name eq "sys::nanosleep") {
            emit($cg, "strada_nanosleep_ns(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # clock_gettime - get clock time
        if ($name eq "sys::clock_gettime") {
            emit($cg, "strada_clock_gettime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # clock_getres - get clock resolution
        if ($name eq "sys::clock_getres") {
            emit($cg, "strada_clock_getres(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # dl_open - open shared library
        if ($name eq "sys::dl_open") {
            emit($cg, "strada_dl_open(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # strada_dl_open_raw - internal raw library open
        if ($name eq "strada_dl_open_raw") {
            emit($cg, "strada_dl_open_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # strada_dl_sym_raw - internal raw symbol lookup
        if ($name eq "strada_dl_sym_raw") {
            emit($cg, "strada_dl_sym_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # strada_dl_close_raw - internal raw library close
        if ($name eq "strada_dl_close_raw") {
            emit($cg, "strada_dl_close_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # dl_sym - get symbol from library
        if ($name eq "sys::dl_sym") {
            emit($cg, "strada_dl_sym(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_close - close library
        if ($name eq "sys::dl_close") {
            emit($cg, "strada_dl_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # dl_error - get last error
        if ($name eq "sys::dl_error") {
            emit($cg, "strada_dl_error()");
            return;
        }

        # dl_call_int - call function returning int
        if ($name eq "sys::dl_call_int") {
            emit($cg, "strada_dl_call_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_num - call function returning num
        if ($name eq "sys::dl_call_num") {
            emit($cg, "strada_dl_call_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_str - call function returning string
        if ($name eq "sys::dl_call_str") {
            emit($cg, "strada_dl_call_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_void - call function with no return
        if ($name eq "sys::dl_call_void") {
            emit($cg, "strada_dl_call_void(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_int_sv - call function passing StradaValue* directly, returns int
        if ($name eq "sys::dl_call_int_sv") {
            emit($cg, "strada_dl_call_int_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_str_sv - call function passing StradaValue* directly, returns string
        if ($name eq "sys::dl_call_str_sv") {
            emit($cg, "strada_dl_call_str_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_void_sv - call function passing StradaValue* directly, no return
        if ($name eq "sys::dl_call_void_sv") {
            emit($cg, "strada_dl_call_void_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_sv") {
            emit($cg, "strada_dl_call_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_export_info") {
            emit($cg, "strada_dl_call_export_info(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_version") {
            emit($cg, "strada_dl_call_version(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Pointer access for FFI
        if ($name eq "sys::int_ptr") {
            emit($cg, "strada_int_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::num_ptr") {
            emit($cg, "strada_num_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::str_ptr") {
            emit($cg, "strada_str_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_int") {
            emit($cg, "strada_ptr_deref_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_num") {
            emit($cg, "strada_ptr_deref_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_str") {
            emit($cg, "strada_ptr_deref_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_int") {
            emit($cg, "strada_ptr_set_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_num") {
            emit($cg, "strada_ptr_set_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # readline - read line from stdin or file handle
        if ($name eq "readline") {
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                # readline(fh) - read from file handle
                emit($cg, "strada_read_line(");
                my scalar $args = $expr->{"args"};
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            } else {
                # readline() - read from stdin
                emit($cg, "strada_readline()");
            }
            return;
        }
        
        # refcount - get reference count
        if ($name eq "refcount") {
            emit($cg, "strada_new_int(strada_refcount(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # free - explicitly decrement refcount and free if zero
        if ($name eq "sys::free") {
            emit($cg, "(strada_free(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_new_undef())");
            return;
        }

        # release - free value and set variable to undef (safe free)
        # release(\$var) -> frees $var's value and sets $var = undef
        if ($name eq "sys::release") {
            my scalar $args = $expr->{"args"};
            my scalar $ref_arg = $args->[0];

            # Check if argument is a reference expression like \$var
            if ($ref_arg->{"type"} == NODE_REF() && $ref_arg->{"target"}->{"type"} == NODE_VARIABLE()) {
                my str $varname = $ref_arg->{"target"}->{"name"};
                # Generate: (strada_free(varname), varname = strada_new_undef())
                emit($cg, "(strada_free(" . $varname . "), " . $varname . " = strada_new_undef())");
            } else {
                # Fallback: just call the runtime function
                emit($cg, "strada_release(");
                gen_expression($cg, $ref_arg);
                emit($cg, ")");
            }
            return;
        }

        # ucfirst - uppercase first letter
        if ($name eq "ucfirst") {
            emit($cg, "strada_new_str(strada_ucfirst(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # lcfirst - lowercase first letter
        if ($name eq "lcfirst") {
            emit($cg, "strada_new_str(strada_lcfirst(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # match - regex match
        if ($name eq "match") {
            emit($cg, "strada_new_int(strada_regex_match(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }
        
        # capture - regex capture
        if ($name eq "capture") {
            emit($cg, "strada_new_array_from_av(strada_regex_capture(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # captures - get captures from last =~ match
        if ($name eq "captures") {
            emit($cg, "strada_captures()");
            return;
        }

        # replace - regex replace (no flags for function-based API)
        if ($name eq "replace") {
            emit($cg, "strada_new_str(strada_regex_replace(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), NULL))");
            return;
        }
        
        # cstruct_set_int
        if ($name eq "sys::cstruct_set_int") {
            emit($cg, "strada_cstruct_set_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_set_string
        if ($name eq "sys::cstruct_set_string") {
            emit($cg, "strada_cstruct_set_string(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_set_double
        if ($name eq "sys::cstruct_set_double") {
            emit($cg, "strada_cstruct_set_double(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_num(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_get_int
        if ($name eq "sys::cstruct_get_int") {
            emit($cg, "strada_new_int(strada_cstruct_get_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_get_string
        if ($name eq "sys::cstruct_get_string") {
            emit($cg, "strada_new_str(strada_cstruct_get_string(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_get_double
        if ($name eq "sys::cstruct_get_double") {
            emit($cg, "strada_new_num(strada_cstruct_get_double(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_new
        if ($name eq "sys::cstruct_new") {
            emit($cg, "strada_cstruct_new(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_ptr
        if ($name eq "sys::cstruct_ptr") {
            emit($cg, "strada_cstruct_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # socket_client
        if ($name eq "sys::socket_client") {
            emit($cg, "strada_socket_client(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }
        
        # socket_server
        if ($name eq "sys::socket_server") {
            emit($cg, "strada_socket_server(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # socket_server_backlog
        if ($name eq "sys::socket_server_backlog") {
            emit($cg, "strada_socket_server_backlog(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # socket_accept
        if ($name eq "sys::socket_accept") {
            emit($cg, "strada_socket_accept(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # socket_recv
        if ($name eq "sys::socket_recv") {
            emit($cg, "strada_socket_recv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }
        
        # socket_send - use binary-safe version that handles NUL bytes
        if ($name eq "sys::socket_send") {
            emit($cg, "strada_socket_send_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }
        
        # socket_close
        if ($name eq "sys::socket_close") {
            emit($cg, "strada_socket_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # socket_select - wait for sockets to be ready for reading
        if ($name eq "sys::socket_select") {
            emit($cg, "strada_socket_select(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # socket_fd - get file descriptor from socket
        if ($name eq "sys::socket_fd") {
            emit($cg, "strada_new_int(strada_socket_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # select_fds - wait for file descriptors to be ready for reading
        if ($name eq "sys::select_fds") {
            emit($cg, "strada_select_fds(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # UDP socket functions

        # udp_socket - create a UDP socket
        if ($name eq "sys::udp_socket") {
            emit($cg, "strada_udp_socket()");
            return;
        }

        # udp_bind - bind UDP socket to a port
        if ($name eq "sys::udp_bind") {
            emit($cg, "strada_new_int(strada_udp_bind(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # udp_server - create UDP server bound to a port
        if ($name eq "sys::udp_server") {
            emit($cg, "strada_udp_server(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # udp_recvfrom - receive UDP packet with sender info
        if ($name eq "sys::udp_recvfrom") {
            emit($cg, "strada_udp_recvfrom(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # udp_sendto - send UDP packet to host:port
        if ($name eq "sys::udp_sendto") {
            emit($cg, "strada_new_int(strada_udp_sendto_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[3]);
            emit($cg, ")))");
            return;
        }

        # stacktrace - print stack trace to stderr (like Carp::cluck)
        if ($name eq "stacktrace") {
            emit($cg, "(strada_stacktrace(), strada_new_undef())");
            return;
        }

        # stacktrace_str - return stack trace as string (like Carp::longmess)
        if ($name eq "stacktrace_str") {
            emit($cg, "strada_new_str(strada_stacktrace_str())");
            return;
        }

        # caller - get caller info at given level
        if ($name eq "caller") {
            my scalar $args = $expr->{"args"};
            if ($expr->{"arg_count"} > 0) {
                emit($cg, "strada_new_str(strada_caller(strada_to_int(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")))");
            } else {
                emit($cg, "strada_new_str(strada_caller(1))");
            }
            return;
        }
        
        # trim - trim whitespace
        if ($name eq "trim") {
            emit($cg, "strada_new_str(strada_trim(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # ltrim - trim left whitespace
        if ($name eq "ltrim") {
            emit($cg, "strada_new_str(strada_ltrim(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # rtrim - trim right whitespace
        if ($name eq "rtrim") {
            emit($cg, "strada_new_str(strada_rtrim(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_new - create new C struct
        if ($name eq "sys::cstruct_new") {
            emit($cg, "strada_cstruct_new(\"struct\", ");
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_to_int(");
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_set_int - set int field in C struct
        if ($name eq "sys::cstruct_set_int") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_cstruct_set_int(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_get_int - get int field from C struct
        if ($name eq "sys::cstruct_get_int") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_int(strada_cstruct_get_int(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # reverse - reverse a string or array
        if ($name eq "reverse") {
            emit($cg, "strada_reverse_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # repeat - repeat a string
        if ($name eq "repeat") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_str(strada_repeat(strada_to_str(");
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }
        
        # replace_all - replace all occurrences
        if ($name eq "replace_all") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_str(strada_replace_all(strada_to_str(");
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # chomp - remove trailing newline
        if ($name eq "chomp") {
            emit($cg, "strada_new_str(strada_chomp(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # chop - remove last character
        if ($name eq "chop") {
            emit($cg, "strada_new_str(strada_chop(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_set_string - set string field in C struct
        if ($name eq "sys::cstruct_set_string") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_cstruct_set_string(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_set_double - set double field in C struct
        if ($name eq "sys::cstruct_set_double") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_cstruct_set_double(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_num(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cast_int - cast value to int
        if ($name eq "cast_int") {
            emit($cg, "strada_new_int(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # cast_num - cast value to num
        if ($name eq "cast_num") {
            emit($cg, "strada_new_num(strada_to_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # cast_str - cast value to str
        if ($name eq "cast_str") {
            emit($cg, "strada_new_str(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_get_string - get string field from C struct
        if ($name eq "sys::cstruct_get_string") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_str(strada_cstruct_get_string(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_get_double - get double field from C struct
        if ($name eq "sys::cstruct_get_double") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_num(strada_cstruct_get_double(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_ptr - get raw pointer from C struct
        if ($name eq "sys::cstruct_ptr") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_cstruct_ptr(");
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # OOP - bless($ref, "Package") - bless a reference into a package
        if ($name eq "bless") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_bless(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # OOP - blessed($ref) - get package name or undef
        if ($name eq "blessed") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_blessed(");
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # OOP - set_package("Name") - set current package context
        if ($name eq "set_package") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_set_package(strada_to_str(");
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # OOP - inherit("Parent") or inherit("Child", "Parent") - set up inheritance
        if ($name eq "inherit") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count == 1) {
                # Single arg: inherit from parent using current package
                emit($cg, "strada_inherit_from(strada_to_str(");
                gen_expression($cg, $args->[0]);
                emit($cg, "))");
            } else {
                # Two args: inherit(child, parent)
                emit($cg, "strada_inherit(strada_to_str(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, "))");
            }
            return;
        }

        # OOP - isa($obj, "Package") - check if object is of a type
        if ($name eq "isa") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_int(strada_isa(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # OOP - can($obj, "method") - check if object can do a method
        if ($name eq "can") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_int(strada_can(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # OOP - UNIVERSAL::isa($obj, "Package") - Perl-style type check
        if ($name eq "UNIVERSAL::isa") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_int(strada_isa(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # OOP - UNIVERSAL::can($obj, "method") - Perl-style method check
        if ($name eq "UNIVERSAL::can") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_int(strada_can(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # ============================================================
        # NEW LIBC FUNCTIONS
        # ============================================================

        # Additional File I/O
        if ($name eq "sys::fgetc") {
            emit($cg, "strada_fgetc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fputc") {
            emit($cg, "strada_fputc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fgets") {
            emit($cg, "strada_fgets(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fputs") {
            emit($cg, "strada_fputs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ferror") {
            emit($cg, "strada_ferror(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fileno") {
            emit($cg, "strada_fileno(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clearerr") {
            emit($cg, "strada_clearerr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Temporary files
        if ($name eq "sys::tmpfile") {
            emit($cg, "strada_tmpfile()");
            return;
        }

        if ($name eq "sys::mkstemp") {
            emit($cg, "strada_mkstemp(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mkdtemp") {
            emit($cg, "strada_mkdtemp(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Command execution (popen)
        if ($name eq "sys::popen") {
            emit($cg, "strada_popen(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::pclose") {
            emit($cg, "strada_pclose(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Additional file system
        if ($name eq "sys::truncate") {
            emit($cg, "strada_truncate(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ftruncate") {
            emit($cg, "strada_ftruncate(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::chown") {
            emit($cg, "strada_chown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::lchown") {
            emit($cg, "strada_lchown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fchmod") {
            emit($cg, "strada_fchmod(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fchown") {
            emit($cg, "strada_fchown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::utime") {
            emit($cg, "strada_utime(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::utimes") {
            emit($cg, "strada_utimes(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        # Session/process group control
        if ($name eq "sys::setsid") {
            emit($cg, "strada_setsid()");
            return;
        }

        if ($name eq "sys::getsid") {
            emit($cg, "strada_getsid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setpgid") {
            emit($cg, "strada_setpgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpgid") {
            emit($cg, "strada_getpgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpgrp") {
            emit($cg, "strada_getpgrp()");
            return;
        }

        if ($name eq "sys::setpgrp") {
            emit($cg, "strada_setpgrp()");
            return;
        }

        # User/group ID control
        if ($name eq "sys::setuid") {
            emit($cg, "strada_setuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setgid") {
            emit($cg, "strada_setgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::seteuid") {
            emit($cg, "strada_seteuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setegid") {
            emit($cg, "strada_setegid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setreuid") {
            emit($cg, "strada_setreuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setregid") {
            emit($cg, "strada_setregid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # Additional socket operations
        if ($name eq "sys::setsockopt") {
            emit($cg, "strada_setsockopt(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ", ");
            gen_expression($cg, $args->[3]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getsockopt") {
            emit($cg, "strada_getsockopt(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::shutdown") {
            emit($cg, "strada_shutdown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpeername") {
            emit($cg, "strada_getpeername(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getsockname") {
            emit($cg, "strada_getsockname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_pton") {
            emit($cg, "strada_inet_pton(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_ntop") {
            emit($cg, "strada_inet_ntop(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_addr") {
            emit($cg, "strada_inet_addr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_ntoa") {
            emit($cg, "strada_inet_ntoa(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::htons") {
            emit($cg, "strada_htons(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::htonl") {
            emit($cg, "strada_htonl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ntohs") {
            emit($cg, "strada_ntohs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ntohl") {
            emit($cg, "strada_ntohl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::poll") {
            emit($cg, "strada_poll(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # Random seeding
        if ($name eq "sys::srand") {
            emit($cg, "strada_srand(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::srandom") {
            emit($cg, "strada_srandom(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::rand") {
            emit($cg, "strada_libc_rand()");
            return;
        }

        if ($name eq "sys::random") {
            emit($cg, "strada_libc_random()");
            return;
        }

        # Advanced signals
        if ($name eq "sys::sigprocmask") {
            emit($cg, "strada_sigprocmask(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::raise") {
            emit($cg, "strada_raise(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::killpg") {
            emit($cg, "strada_killpg(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::pause") {
            emit($cg, "strada_pause()");
            return;
        }

        # User/Group database
        if ($name eq "sys::getpwnam") {
            emit($cg, "strada_getpwnam(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpwuid") {
            emit($cg, "strada_getpwuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getgrnam") {
            emit($cg, "strada_getgrnam(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getgrgid") {
            emit($cg, "strada_getgrgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getlogin") {
            emit($cg, "strada_getlogin()");
            return;
        }

        if ($name eq "sys::getgroups") {
            emit($cg, "strada_getgroups()");
            return;
        }

        # Resource/Priority
        if ($name eq "sys::nice") {
            emit($cg, "strada_nice(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpriority") {
            emit($cg, "strada_getpriority(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setpriority") {
            emit($cg, "strada_setpriority(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getrusage") {
            emit($cg, "strada_getrusage(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getrlimit") {
            emit($cg, "strada_getrlimit(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setrlimit") {
            emit($cg, "strada_setrlimit(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # Additional time functions
        if ($name eq "sys::difftime") {
            emit($cg, "strada_difftime(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clock") {
            emit($cg, "strada_clock()");
            return;
        }

        if ($name eq "sys::times") {
            emit($cg, "strada_times()");
            return;
        }

        # Additional memory functions
        if ($name eq "sys::calloc") {
            emit($cg, "strada_calloc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::realloc") {
            emit($cg, "strada_realloc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mmap") {
            emit($cg, "strada_mmap(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ", ");
            gen_expression($cg, $args->[3]);
            emit($cg, ", ");
            gen_expression($cg, $args->[4]);
            emit($cg, ", ");
            gen_expression($cg, $args->[5]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::munmap") {
            emit($cg, "strada_munmap(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mlock") {
            emit($cg, "strada_mlock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::munlock") {
            emit($cg, "strada_munlock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # String conversion
        if ($name eq "sys::strtol") {
            emit($cg, "strada_strtol(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::strtod") {
            emit($cg, "strada_strtod(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::atoi") {
            emit($cg, "strada_atoi(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::atof") {
            emit($cg, "strada_atof(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Terminal/TTY
        if ($name eq "sys::ttyname") {
            emit($cg, "strada_ttyname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::tcgetattr") {
            emit($cg, "strada_tcgetattr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::tcsetattr") {
            emit($cg, "strada_tcsetattr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfgetospeed") {
            emit($cg, "strada_cfgetospeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfsetospeed") {
            emit($cg, "strada_cfsetospeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfgetispeed") {
            emit($cg, "strada_cfgetispeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfsetispeed") {
            emit($cg, "strada_cfsetispeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # serial_open - high-level serial port open
        if ($name eq "sys::serial_open") {
            emit($cg, "strada_serial_open(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), ");
            if ($expr->{"arg_count"} > 2) {
                emit($cg, "strada_to_str(");
                gen_expression($cg, $args->[2]);
                emit($cg, ")");
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # tcflush - flush input/output queues
        if ($name eq "sys::tcflush") {
            emit($cg, "strada_tcflush(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # tcdrain - wait for output to be transmitted
        if ($name eq "sys::tcdrain") {
            emit($cg, "strada_tcdrain(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Baud rate constants
        if ($name eq "sys::B0") { emit($cg, "strada_new_int(B0)"); return; }
        if ($name eq "sys::B50") { emit($cg, "strada_new_int(B50)"); return; }
        if ($name eq "sys::B75") { emit($cg, "strada_new_int(B75)"); return; }
        if ($name eq "sys::B110") { emit($cg, "strada_new_int(B110)"); return; }
        if ($name eq "sys::B134") { emit($cg, "strada_new_int(B134)"); return; }
        if ($name eq "sys::B150") { emit($cg, "strada_new_int(B150)"); return; }
        if ($name eq "sys::B200") { emit($cg, "strada_new_int(B200)"); return; }
        if ($name eq "sys::B300") { emit($cg, "strada_new_int(B300)"); return; }
        if ($name eq "sys::B600") { emit($cg, "strada_new_int(B600)"); return; }
        if ($name eq "sys::B1200") { emit($cg, "strada_new_int(B1200)"); return; }
        if ($name eq "sys::B1800") { emit($cg, "strada_new_int(B1800)"); return; }
        if ($name eq "sys::B2400") { emit($cg, "strada_new_int(B2400)"); return; }
        if ($name eq "sys::B4800") { emit($cg, "strada_new_int(B4800)"); return; }
        if ($name eq "sys::B9600") { emit($cg, "strada_new_int(B9600)"); return; }
        if ($name eq "sys::B19200") { emit($cg, "strada_new_int(B19200)"); return; }
        if ($name eq "sys::B38400") { emit($cg, "strada_new_int(B38400)"); return; }
        if ($name eq "sys::B57600") { emit($cg, "strada_new_int(B57600)"); return; }
        if ($name eq "sys::B115200") { emit($cg, "strada_new_int(B115200)"); return; }
        if ($name eq "sys::B230400") { emit($cg, "strada_new_int(B230400)"); return; }
        if ($name eq "sys::B460800") { emit($cg, "strada_new_int(B460800)"); return; }
        if ($name eq "sys::B500000") { emit($cg, "strada_new_int(B500000)"); return; }
        if ($name eq "sys::B576000") { emit($cg, "strada_new_int(B576000)"); return; }
        if ($name eq "sys::B921600") { emit($cg, "strada_new_int(B921600)"); return; }
        if ($name eq "sys::B1000000") { emit($cg, "strada_new_int(B1000000)"); return; }
        if ($name eq "sys::B1152000") { emit($cg, "strada_new_int(B1152000)"); return; }
        if ($name eq "sys::B1500000") { emit($cg, "strada_new_int(B1500000)"); return; }
        if ($name eq "sys::B2000000") { emit($cg, "strada_new_int(B2000000)"); return; }

        # Termios control mode flags (c_cflag)
        if ($name eq "sys::CSIZE") { emit($cg, "strada_new_int(CSIZE)"); return; }
        if ($name eq "sys::CS5") { emit($cg, "strada_new_int(CS5)"); return; }
        if ($name eq "sys::CS6") { emit($cg, "strada_new_int(CS6)"); return; }
        if ($name eq "sys::CS7") { emit($cg, "strada_new_int(CS7)"); return; }
        if ($name eq "sys::CS8") { emit($cg, "strada_new_int(CS8)"); return; }
        if ($name eq "sys::CSTOPB") { emit($cg, "strada_new_int(CSTOPB)"); return; }
        if ($name eq "sys::CREAD") { emit($cg, "strada_new_int(CREAD)"); return; }
        if ($name eq "sys::PARENB") { emit($cg, "strada_new_int(PARENB)"); return; }
        if ($name eq "sys::PARODD") { emit($cg, "strada_new_int(PARODD)"); return; }
        if ($name eq "sys::HUPCL") { emit($cg, "strada_new_int(HUPCL)"); return; }
        if ($name eq "sys::CLOCAL") { emit($cg, "strada_new_int(CLOCAL)"); return; }
        if ($name eq "sys::CRTSCTS") { emit($cg, "strada_new_int(CRTSCTS)"); return; }

        # Termios input mode flags (c_iflag)
        if ($name eq "sys::IGNBRK") { emit($cg, "strada_new_int(IGNBRK)"); return; }
        if ($name eq "sys::BRKINT") { emit($cg, "strada_new_int(BRKINT)"); return; }
        if ($name eq "sys::IGNPAR") { emit($cg, "strada_new_int(IGNPAR)"); return; }
        if ($name eq "sys::PARMRK") { emit($cg, "strada_new_int(PARMRK)"); return; }
        if ($name eq "sys::INPCK") { emit($cg, "strada_new_int(INPCK)"); return; }
        if ($name eq "sys::ISTRIP") { emit($cg, "strada_new_int(ISTRIP)"); return; }
        if ($name eq "sys::INLCR") { emit($cg, "strada_new_int(INLCR)"); return; }
        if ($name eq "sys::IGNCR") { emit($cg, "strada_new_int(IGNCR)"); return; }
        if ($name eq "sys::ICRNL") { emit($cg, "strada_new_int(ICRNL)"); return; }
        if ($name eq "sys::IXON") { emit($cg, "strada_new_int(IXON)"); return; }
        if ($name eq "sys::IXOFF") { emit($cg, "strada_new_int(IXOFF)"); return; }
        if ($name eq "sys::IXANY") { emit($cg, "strada_new_int(IXANY)"); return; }

        # Termios output mode flags (c_oflag)
        if ($name eq "sys::OPOST") { emit($cg, "strada_new_int(OPOST)"); return; }
        if ($name eq "sys::ONLCR") { emit($cg, "strada_new_int(ONLCR)"); return; }
        if ($name eq "sys::OCRNL") { emit($cg, "strada_new_int(OCRNL)"); return; }

        # Termios local mode flags (c_lflag)
        if ($name eq "sys::ISIG") { emit($cg, "strada_new_int(ISIG)"); return; }
        if ($name eq "sys::ICANON") { emit($cg, "strada_new_int(ICANON)"); return; }
        if ($name eq "sys::ECHO") { emit($cg, "strada_new_int(ECHO)"); return; }
        if ($name eq "sys::ECHOE") { emit($cg, "strada_new_int(ECHOE)"); return; }
        if ($name eq "sys::ECHOK") { emit($cg, "strada_new_int(ECHOK)"); return; }
        if ($name eq "sys::ECHONL") { emit($cg, "strada_new_int(ECHONL)"); return; }
        if ($name eq "sys::NOFLSH") { emit($cg, "strada_new_int(NOFLSH)"); return; }
        if ($name eq "sys::TOSTOP") { emit($cg, "strada_new_int(TOSTOP)"); return; }
        if ($name eq "sys::IEXTEN") { emit($cg, "strada_new_int(IEXTEN)"); return; }

        # tcsetattr when values
        if ($name eq "sys::TCSANOW") { emit($cg, "strada_new_int(TCSANOW)"); return; }
        if ($name eq "sys::TCSADRAIN") { emit($cg, "strada_new_int(TCSADRAIN)"); return; }
        if ($name eq "sys::TCSAFLUSH") { emit($cg, "strada_new_int(TCSAFLUSH)"); return; }

        # tcflush queue selectors
        if ($name eq "sys::TCIFLUSH") { emit($cg, "strada_new_int(TCIFLUSH)"); return; }
        if ($name eq "sys::TCOFLUSH") { emit($cg, "strada_new_int(TCOFLUSH)"); return; }
        if ($name eq "sys::TCIOFLUSH") { emit($cg, "strada_new_int(TCIOFLUSH)"); return; }

        # File open flags (for low-level open)
        if ($name eq "sys::O_RDONLY") { emit($cg, "strada_new_int(O_RDONLY)"); return; }
        if ($name eq "sys::O_WRONLY") { emit($cg, "strada_new_int(O_WRONLY)"); return; }
        if ($name eq "sys::O_RDWR") { emit($cg, "strada_new_int(O_RDWR)"); return; }
        if ($name eq "sys::O_CREAT") { emit($cg, "strada_new_int(O_CREAT)"); return; }
        if ($name eq "sys::O_EXCL") { emit($cg, "strada_new_int(O_EXCL)"); return; }
        if ($name eq "sys::O_NOCTTY") { emit($cg, "strada_new_int(O_NOCTTY)"); return; }
        if ($name eq "sys::O_TRUNC") { emit($cg, "strada_new_int(O_TRUNC)"); return; }
        if ($name eq "sys::O_APPEND") { emit($cg, "strada_new_int(O_APPEND)"); return; }
        if ($name eq "sys::O_NONBLOCK") { emit($cg, "strada_new_int(O_NONBLOCK)"); return; }
        if ($name eq "sys::O_SYNC") { emit($cg, "strada_new_int(O_SYNC)"); return; }

        # Advanced file operations
        if ($name eq "sys::fcntl") {
            emit($cg, "strada_fcntl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 2) {
                gen_expression($cg, $args->[2]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::flock") {
            emit($cg, "strada_flock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ioctl") {
            emit($cg, "strada_ioctl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 2) {
                gen_expression($cg, $args->[2]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::statvfs") {
            emit($cg, "strada_statvfs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fstatvfs") {
            emit($cg, "strada_fstatvfs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dup") {
            emit($cg, "strada_dup(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Additional math functions
        if ($name eq "math::hypot") {
            emit($cg, "strada_hypot(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::cbrt") {
            emit($cg, "strada_cbrt(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::isnan") {
            emit($cg, "strada_isnan(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::isinf") {
            emit($cg, "strada_isinf(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::isfinite") {
            emit($cg, "strada_isfinite(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::fmax") {
            emit($cg, "strada_fmax(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::fmin") {
            emit($cg, "strada_fmin(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::copysign") {
            emit($cg, "strada_copysign(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::remainder") {
            emit($cg, "strada_remainder(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::trunc") {
            emit($cg, "strada_trunc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::ldexp") {
            emit($cg, "strada_ldexp(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::frexp") {
            emit($cg, "strada_frexp(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::modf") {
            emit($cg, "strada_modf(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::scalbn") {
            emit($cg, "strada_scalbn(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # User-defined function - check for default parameters
        my str $c_name = sanitize_name($name);
        my scalar $func_info = $cg->{"functions"}->{$c_name};
        my scalar $args = $expr->{"args"};
        my int $arg_count = $expr->{"arg_count"};

        # Handle extern function calls - convert between StradaValue* and raw C types
        if ($func_info && $func_info->{"is_extern"} == 1) {
            my int $ret_type = $func_info->{"return_type"};
            my int $param_count = $func_info->{"param_count"};
            my scalar $params = $func_info->{"params"};

            # Generate block for extern call with conversion
            emit($cg, "({ ");

            # Create temps for args and convert from StradaValue* to raw C types
            my int $t = 0;
            while ($t < $arg_count) {
                my int $param_type = TYPE_SCALAR();
                if ($t < $param_count) {
                    $param_type = $params->[$t]->{"param_type"};
                }
                emit($cg, "StradaValue *__sv_arg" . $t . " = ");
                gen_expression($cg, $args->[$t]);
                emit($cg, "; ");
                $t = $t + 1;
            }

            # Call the extern function with converted args
            if ($ret_type == TYPE_VOID()) {
                emit($cg, $c_name . "(");
            } elsif ($ret_type == TYPE_STR()) {
                emit($cg, "char *__ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_INT()) {
                emit($cg, "int __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_NUM()) {
                emit($cg, "double __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_INT32()) {
                emit($cg, "int32_t __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_INT64()) {
                emit($cg, "int64_t __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_FLOAT32()) {
                emit($cg, "float __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_FLOAT64()) {
                emit($cg, "double __ext_ret = " . $c_name . "(");
            } else {
                emit($cg, "void *__ext_ret = " . $c_name . "(");
            }

            # Pass converted arguments
            my int $a = 0;
            while ($a < $arg_count) {
                if ($a > 0) {
                    emit($cg, ", ");
                }
                my int $param_type = TYPE_SCALAR();
                if ($a < $param_count) {
                    $param_type = $params->[$a]->{"param_type"};
                }
                if ($param_type == TYPE_STR()) {
                    emit($cg, "strada_to_str(__sv_arg" . $a . ")");
                } elsif ($param_type == TYPE_INT()) {
                    emit($cg, "(int)strada_to_int(__sv_arg" . $a . ")");
                } elsif ($param_type == TYPE_INT32()) {
                    emit($cg, "(int32_t)strada_to_int(__sv_arg" . $a . ")");
                } elsif ($param_type == TYPE_INT64()) {
                    emit($cg, "strada_to_int(__sv_arg" . $a . ")");
                } elsif ($param_type == TYPE_NUM() || $param_type == TYPE_FLOAT64()) {
                    emit($cg, "strada_to_num(__sv_arg" . $a . ")");
                } elsif ($param_type == TYPE_FLOAT32()) {
                    emit($cg, "(float)strada_to_num(__sv_arg" . $a . ")");
                } else {
                    emit($cg, "strada_to_str(__sv_arg" . $a . ")");
                }
                $a = $a + 1;
            }
            emit($cg, "); ");

            # Decref the temp StradaValue args
            my int $d = 0;
            while ($d < $arg_count) {
                if (needs_temp_cleanup($args->[$d]) == 1) {
                    emit($cg, "strada_decref(__sv_arg" . $d . "); ");
                }
                $d = $d + 1;
            }

            # Convert return value back to StradaValue*
            if ($ret_type == TYPE_VOID()) {
                emit($cg, "strada_new_undef(); })");
            } elsif ($ret_type == TYPE_STR()) {
                emit($cg, "strada_new_str(__ext_ret); })");
            } elsif ($ret_type == TYPE_INT() || $ret_type == TYPE_INT32() || $ret_type == TYPE_INT64()) {
                emit($cg, "strada_new_int(__ext_ret); })");
            } elsif ($ret_type == TYPE_NUM() || $ret_type == TYPE_FLOAT32() || $ret_type == TYPE_FLOAT64()) {
                emit($cg, "strada_new_num(__ext_ret); })");
            } else {
                emit($cg, "strada_new_undef(); })");
            }
            return;
        }

        # Check if any arguments need temp cleanup (anonymous values)
        my int $needs_temps = 0;
        my int $check_i = 0;
        while ($check_i < $arg_count) {
            if (needs_temp_cleanup($args->[$check_i]) == 1) {
                $needs_temps = 1;
            }
            $check_i = $check_i + 1;
        }

        if ($needs_temps == 1) {
            # Check if function returns void
            # Default to non-void when we don't have func_info (safer - allows use in expression context)
            my int $returns_void = 0;
            if ($func_info) {
                my int $ret_type = $func_info->{"return_type"};
                if ($ret_type == TYPE_VOID()) {
                    $returns_void = 1;
                }
            }

            # Generate block with temp variables for cleanup
            emit($cg, "({ ");
            # Declare temps for args that need cleanup
            my int $t = 0;
            while ($t < $arg_count) {
                if (needs_temp_cleanup($args->[$t]) == 1) {
                    emit($cg, "StradaValue *__arg" . $t . " = ");
                    gen_expression($cg, $args->[$t]);
                    emit($cg, "; ");
                }
                $t = $t + 1;
            }
            # Emit the function call, storing result if not void
            if ($returns_void == 0) {
                emit($cg, "StradaValue *__call_result = ");
            }
            emit($cg, $c_name . "(");
            if ($func_info) {
                my int $param_count = $func_info->{"param_count"};
                my scalar $params = $func_info->{"params"};
                my int $i = 0;
                while ($i < $param_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    if ($i < $arg_count) {
                        if (needs_temp_cleanup($args->[$i]) == 1) {
                            emit($cg, "__arg" . $i);
                        } else {
                            gen_expression($cg, $args->[$i]);
                        }
                    } else {
                        my scalar $param = $params->[$i];
                        if ($param->{"has_default"} == 1) {
                            gen_expression($cg, $param->{"default"});
                        } else {
                            emit($cg, "strada_new_undef()");
                        }
                    }
                    $i = $i + 1;
                }
            } else {
                my int $i = 0;
                while ($i < $arg_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    if (needs_temp_cleanup($args->[$i]) == 1) {
                        emit($cg, "__arg" . $i);
                    } else {
                        gen_expression($cg, $args->[$i]);
                    }
                    $i = $i + 1;
                }
            }
            emit($cg, "); ");
            # Decref temps
            my int $d = 0;
            while ($d < $arg_count) {
                if (needs_temp_cleanup($args->[$d]) == 1) {
                    emit($cg, "strada_decref(__arg" . $d . "); ");
                }
                $d = $d + 1;
            }
            # Return result if not void
            if ($returns_void == 0) {
                emit($cg, "__call_result; })");
            } else {
                emit($cg, "})");
            }
        } else {
            # No temps needed, simple call
            emit($cg, $c_name . "(");
            if ($func_info) {
                my int $param_count = $func_info->{"param_count"};
                my scalar $params = $func_info->{"params"};
                my int $i = 0;
                while ($i < $param_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    if ($i < $arg_count) {
                        gen_expression($cg, $args->[$i]);
                    } else {
                        my scalar $param = $params->[$i];
                        if ($param->{"has_default"} == 1) {
                            gen_expression($cg, $param->{"default"});
                        } else {
                            emit($cg, "strada_new_undef()");
                        }
                    }
                    $i = $i + 1;
                }
            } else {
                my int $i = 0;
                while ($i < $arg_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    gen_expression($cg, $args->[$i]);
                    $i = $i + 1;
                }
            }
            emit($cg, ")");
        }
        return;
    }
    
    # Assignment
    if ($type == NODE_ASSIGN()) {
        my str $op = $expr->{"op"};
        my scalar $target = $expr->{"target"};
        my int $target_type = $target->{"type"};
        
        if ($op eq "=") {
            # Special case: hash assignment %hash{key} = value
            # strada_hash_set handles incref internally for shared ownership
            # For anonymous values, we need to decref after hash_set takes ownership
            if ($target_type == NODE_HASH_ACCESS()) {
                my scalar $val = $expr->{"value"};
                my int $val_type = $val->{"type"};
                # Check if value is anonymous (needs decref after storing)
                my int $is_anonymous = 0;
                if ($val_type == NODE_ANON_ARRAY() || $val_type == NODE_ANON_HASH() ||
                    $val_type == NODE_INT_LITERAL() || $val_type == NODE_NUM_LITERAL() ||
                    $val_type == NODE_STR_LITERAL() || $val_type == NODE_CALL() ||
                    $val_type == NODE_REF() || $val_type == NODE_METHOD_CALL()) {
                    $is_anonymous = 1;
                }
                if ($is_anonymous == 1) {
                    # Anonymous value: store in temp, hash_set takes shared ownership, then release our copy
                    emit($cg, "({ StradaValue *__hset_v = ");
                    # Handle empty () which parser returns as anon_hash
                    if ($val_type == NODE_ANON_HASH() && $val->{"pair_count"} == 0) {
                        emit($cg, "strada_new_hash()");
                    } else {
                        gen_expression($cg, $val);
                    }
                    emit($cg, "; strada_hash_set(strada_deref_hash(");
                    gen_expression($cg, $target->{"hash"});
                    emit($cg, "), strada_to_str(");
                    gen_expression($cg, $target->{"key"});
                    emit($cg, "), __hset_v); strada_decref(__hset_v); })");
                } else {
                    # Borrowed value: just pass to hash_set which handles incref
                    emit($cg, "strada_hash_set(strada_deref_hash(");
                    gen_expression($cg, $target->{"hash"});
                    emit($cg, "), strada_to_str(");
                    gen_expression($cg, $target->{"key"});
                    emit($cg, "), ");
                    gen_expression($cg, $val);
                    emit($cg, ")");
                }
                return;
            }
            # Special case: hash deref assignment $ref->{key} = value
            # strada_hash_set handles incref internally for shared ownership
            # For anonymous values, we need to decref after hash_set takes ownership
            if ($target_type == NODE_DEREF_HASH()) {
                my scalar $val = $expr->{"value"};
                my int $val_type = $val->{"type"};
                # Check if value is anonymous (needs decref after storing)
                my int $is_anonymous = 0;
                if ($val_type == NODE_ANON_ARRAY() || $val_type == NODE_ANON_HASH() ||
                    $val_type == NODE_INT_LITERAL() || $val_type == NODE_NUM_LITERAL() ||
                    $val_type == NODE_STR_LITERAL() || $val_type == NODE_CALL() ||
                    $val_type == NODE_REF() || $val_type == NODE_METHOD_CALL()) {
                    $is_anonymous = 1;
                }
                if ($is_anonymous == 1) {
                    # Anonymous value: store in temp, hash_set takes shared ownership, then release our copy
                    emit($cg, "({ StradaValue *__hset_v = ");
                    gen_expression($cg, $val);
                    emit($cg, "; strada_hash_set(strada_deref_hash(");
                    gen_expression($cg, $target->{"ref"});
                    emit($cg, "), strada_to_str(");
                    gen_expression($cg, $target->{"key"});
                    emit($cg, "), __hset_v); strada_decref(__hset_v); })");
                } else {
                    # Borrowed value: just pass to hash_set which handles incref
                    emit($cg, "strada_hash_set(strada_deref_hash(");
                    gen_expression($cg, $target->{"ref"});
                    emit($cg, "), strada_to_str(");
                    gen_expression($cg, $target->{"key"});
                    emit($cg, "), ");
                    gen_expression($cg, $val);
                    emit($cg, ")");
                }
                return;
            }
            # Special case: array subscript assignment @arr[idx] = value
            if ($target_type == NODE_SUBSCRIPT()) {
                emit($cg, "strada_array_set(strada_deref_array(");
                gen_expression($cg, $target->{"array"});
                emit($cg, "), strada_to_int(");
                gen_expression($cg, $target->{"index"});
                emit($cg, "), ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")");
                return;
            }
            # Special case: array deref assignment $ref->[idx] = value
            if ($target_type == NODE_DEREF_ARRAY()) {
                emit($cg, "strada_array_set(strada_deref_array(");
                gen_expression($cg, $target->{"ref"});
                emit($cg, "), strada_to_int(");
                gen_expression($cg, $target->{"index"});
                emit($cg, "), ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")");
                return;
            }
            # Special case: scalar deref assignment $$ref = value
            if ($target_type == NODE_DEREF_SCALAR()) {
                emit($cg, "strada_deref_set(");
                gen_expression($cg, $target->{"ref"});
                emit($cg, ", ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")");
                return;
            }
            # Special case: assigning scalar to array variable @arr = ($x)
            if ($target_type == NODE_VARIABLE() && $target->{"sigil"} eq "@") {
                my scalar $val = $expr->{"value"};
                my int $val_type = $val->{"type"};
                if ($val_type == NODE_ANON_HASH() && $val->{"pair_count"} == 0) {
                    # Empty () - clear and reset array
                    gen_expression($cg, $target);
                    emit($cg, " = strada_new_array()");
                } elsif ($val_type == NODE_ANON_ARRAY()) {
                    # Array literal [1, 2, 3] - assign directly
                    gen_expression($cg, $target);
                    emit($cg, " = ");
                    gen_expression($cg, $val);
                } elsif (is_scalar_expr($val)) {
                    # Single scalar - wrap in array
                    gen_expression($cg, $target);
                    emit($cg, " = strada_new_array(); strada_array_push(");
                    gen_expression($cg, $target);
                    emit($cg, "->value.av, ");
                    gen_expression($cg, $val);
                    emit($cg, ")");
                } else {
                    # Assume value returns an array
                    gen_expression($cg, $target);
                    emit($cg, " = ");
                    gen_expression($cg, $val);
                }
                return;
            }
            # Normal assignment with reference counting
            # Runtime returns owned references, so we just decref the old value
            # For variable-to-variable copy, need to incref since we're sharing
            my scalar $rhs = $expr->{"value"};
            my int $rhs_type = $rhs->{"type"};
            my int $rhs_is_var = 0;
            if ($rhs_type == NODE_VARIABLE()) {
                $rhs_is_var = 1;
            }
            if ($target_type == NODE_VARIABLE() && $cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__old = ");
                gen_expression($cg, $target);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = ");
                gen_expression($cg, $rhs);
                emit($cg, "; ");
                # Incref only for variable-to-variable copy
                if ($rhs_is_var == 1) {
                    emit($cg, "strada_incref(");
                    gen_expression($cg, $target);
                    emit($cg, "); ");
                }
                emit($cg, "strada_decref(__old); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = ");
                gen_expression($cg, $rhs);
            }
        } elsif ($op eq "+=") {
            if ($target_type == NODE_VARIABLE() && $cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__old = ");
                gen_expression($cg, $target);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(__old) + strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")); strada_decref(__old); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(");
                gen_expression($cg, $target);
                emit($cg, ") + strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, "))");
            }
        } elsif ($op eq "-=") {
            if ($target_type == NODE_VARIABLE() && $cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__old = ");
                gen_expression($cg, $target);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(__old) - strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")); strada_decref(__old); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(");
                gen_expression($cg, $target);
                emit($cg, ") - strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, "))");
            }
        } elsif ($op eq ".=") {
            if ($target_type == NODE_VARIABLE() && $cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__old = ");
                gen_expression($cg, $target);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = strada_concat_sv(__old, ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, "); strada_decref(__old); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = strada_concat_sv(");
                gen_expression($cg, $target);
                emit($cg, ", ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")");
            }
        }
        return;
    }
    
    # Array subscript - use strada_deref_array to handle both direct arrays and refs
    if ($type == NODE_SUBSCRIPT()) {
        emit($cg, "strada_array_get(strada_deref_array(");
        gen_expression($cg, $expr->{"array"});
        emit($cg, "), strada_to_int(");
        gen_expression($cg, $expr->{"index"});
        emit($cg, "))");
        return;
    }
    
    # Hash access - use strada_deref_hash to handle both direct hashes and refs
    if ($type == NODE_HASH_ACCESS()) {
        emit($cg, "strada_hash_get(strada_deref_hash(");
        gen_expression($cg, $expr->{"hash"});
        emit($cg, "), strada_to_str(");
        gen_expression($cg, $expr->{"key"});
        emit($cg, "))");
        return;
    }
    
    # Reference
    if ($type == NODE_REF()) {
        my str $ref_type = $expr->{"ref_type"};
        if ($ref_type eq "&") {
            # Function reference - use strada_cpointer_new
            emit($cg, "strada_cpointer_new((void*)");
            gen_expression($cg, $expr->{"target"});
            emit($cg, ")");
        } else {
            emit($cg, "strada_new_ref(");
            gen_expression($cg, $expr->{"target"});
            emit($cg, ", '");
            emit($cg, $ref_type);
            emit($cg, "')");
        }
        return;
    }
    
    # Hash dereference
    if ($type == NODE_DEREF_HASH()) {
        emit($cg, "strada_hash_get(strada_deref_hash(");
        gen_expression($cg, $expr->{"ref"});
        emit($cg, "), strada_to_str(");
        gen_expression($cg, $expr->{"key"});
        emit($cg, "))");
        return;
    }
    
    # Array dereference
    if ($type == NODE_DEREF_ARRAY()) {
        emit($cg, "strada_array_get(strada_deref_array(");
        gen_expression($cg, $expr->{"ref"});
        emit($cg, "), strada_to_int(");
        gen_expression($cg, $expr->{"index"});
        emit($cg, "))");
        return;
    }
    
    # Scalar/Array/Hash dereference (@{}, %{}, $$)
    if ($type == NODE_DEREF_SCALAR()) {
        my str $sigil = $expr->{"sigil"};
        if ($sigil eq "@") {
            emit($cg, "strada_deref_array_value(");
        } elsif ($sigil eq "%") {
            emit($cg, "strada_deref_hash_value(");
        } else {
            emit($cg, "strada_deref(");
        }
        gen_expression($cg, $expr->{"ref"});
        emit($cg, ")");
        return;
    }
    
    # Field access (obj->field)
    if ($type == NODE_FIELD_ACCESS()) {
        gen_expression($cg, $expr->{"object"});
        emit($cg, "->" . $expr->{"field"});
        return;
    }
    
    # Function reference (&func_name)
    if ($type == NODE_FUNC_REF()) {
        emit($cg, "&" . $expr->{"name"});
        return;
    }
    
    # Method call ($obj->method(args)) - Perl-style blessed reference method dispatch
    # OR struct function pointer call ($struct->funcptr(args))
    if ($type == NODE_METHOD_CALL()) {
        my int $arg_count = $expr->{"arg_count"};
        my str $method = $expr->{"method"};
        my scalar $obj = $expr->{"object"};

        # Check if this is a struct function pointer call
        # The object will be a FIELD_ACCESS node (e.g., $calc->operation)
        # whose object is a VAR_REF to a struct variable
        my int $is_funcptr_call = 0;
        if ($obj->{"type"} == NODE_FIELD_ACCESS()) {
            my scalar $struct_obj = $obj->{"object"};
            if ($struct_obj->{"type"} == NODE_VARIABLE()) {
                my str $var_name = $struct_obj->{"name"};
                my scalar $struct_vars = $cg->{"struct_vars"};
                if ($struct_vars->{$var_name}) {
                    my str $struct_type = $struct_vars->{$var_name};
                    my scalar $struct_defs = $cg->{"struct_defs"};
                    if ($struct_defs->{$struct_type}) {
                        my scalar $struct_info = $struct_defs->{$struct_type};
                        my scalar $field_info = $struct_info->{"fields"}->{$method};
                        if ($field_info && $field_info->{"is_funcptr"}) {
                            $is_funcptr_call = 1;
                        }
                    }
                }
            }
        }

        if ($is_funcptr_call) {
            # Generate direct function pointer call with proper cast
            # ((StradaValue*(*)(StradaValue*, ...))ptr)(arg1, arg2, ...)
            emit($cg, "((StradaValue*(*)(");
            if ($arg_count == 0) {
                emit($cg, "void");
            } else {
                my int $p = 0;
                while ($p < $arg_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    emit($cg, "StradaValue*");
                    $p = $p + 1;
                }
            }
            emit($cg, "))");
            gen_expression($cg, $obj);
            emit($cg, ")(");
            my scalar $args = $expr->{"args"};
            my int $i = 0;
            while ($i < $arg_count) {
                if ($i > 0) {
                    emit($cg, ", ");
                }
                gen_expression($cg, $args->[$i]);
                $i = $i + 1;
            }
            emit($cg, ")");
        } else {
            # OOP method call - use base_object (the original object, not field access)
            # Generate: strada_method_call(obj, "method", strada_pack_args(count, arg1, arg2, ...))
            emit($cg, "strada_method_call(");
            # Use base_object if available (set by parser for ->method() calls)
            my scalar $base_obj = $expr->{"base_object"};
            if ($base_obj) {
                gen_expression($cg, $base_obj);
            } else {
                gen_expression($cg, $obj);
            }
            emit($cg, ", \"" . $method . "\", strada_pack_args(" . $arg_count);

            my scalar $args = $expr->{"args"};
            my int $i = 0;
            while ($i < $arg_count) {
                emit($cg, ", ");
                gen_expression($cg, $args->[$i]);
                $i = $i + 1;
            }
            emit($cg, "))");
        }
        return;
    }

    # SUPER::method($self, args...) - calls parent method
    if ($type == NODE_SUPER_CALL()) {
        my int $arg_count = $expr->{"arg_count"};
        my str $method = $expr->{"method"};
        my scalar $args = $expr->{"args"};

        # SUPER::method requires at least one argument (the object/self)
        if ($arg_count < 1) {
            emit($cg, "strada_new_undef() /* SUPER call requires self argument */");
            return;
        }

        # Generate: strada_super_call(self, __PACKAGE__, "method", strada_pack_args(remaining...))
        emit($cg, "strada_super_call(");

        # First argument is self/object
        gen_expression($cg, $args->[0]);

        # Use compile-time package for SUPER resolution (not runtime strada_current_package())
        my str $fn_pkg = $cg->{"current_fn_package"};
        emit($cg, ", \"" . $fn_pkg . "\", \"" . $method . "\", strada_pack_args(");

        # Remaining arguments (skip first which is $self)
        my int $remaining = $arg_count - 1;
        emit($cg, "" . $remaining);

        my int $i = 1;
        while ($i < $arg_count) {
            emit($cg, ", ");
            gen_expression($cg, $args->[$i]);
            $i = $i + 1;
        }
        emit($cg, "))");
        return;
    }

    # __PACKAGE__ - returns current package name
    if ($type == NODE_DUNDER_PACKAGE()) {
        emit($cg, "strada_new_str(strada_current_package() ? strada_current_package() : \"\")");
        return;
    }

    # __FILE__ - returns current file name
    if ($type == NODE_DUNDER_FILE()) {
        my str $filename = $cg->{"filename"};
        emit($cg, "strada_new_str(\"" . $filename . "\")");
        return;
    }

    # __LINE__ - returns current line number
    if ($type == NODE_DUNDER_LINE()) {
        my int $line = $expr->{"line_value"};
        emit($cg, "strada_new_int(" . $line . ")");
        return;
    }

    # Anonymous hash
    if ($type == NODE_ANON_HASH()) {
        emit($cg, "strada_anon_hash(" . $expr->{"pair_count"});
        my scalar $keys = $expr->{"keys"};
        my scalar $values = $expr->{"values"};
        my int $i = 0;
        while ($i < $expr->{"pair_count"}) {
            emit($cg, ", \"" . $keys->[$i] . "\", ");
            gen_expression($cg, $values->[$i]);
            $i = $i + 1;
        }
        emit($cg, ")");
        return;
    }
    
    # Anonymous array
    if ($type == NODE_ANON_ARRAY()) {
        emit($cg, "strada_anon_array(" . $expr->{"element_count"});
        my scalar $elems = $expr->{"elements"};
        my int $i = 0;
        while ($i < $expr->{"element_count"}) {
            emit($cg, ", ");
            gen_expression($cg, $elems->[$i]);
            $i = $i + 1;
        }
        emit($cg, ")");
        return;
    }

    # Map expression: map { block } @array
    if ($type == NODE_MAP()) {
        my scalar $block = $expr->{"block"};
        my scalar $array_expr = $expr->{"array"};
        my int $map_id = $cg->{"map_counter"};
        $cg->{"map_counter"} = $map_id + 1;

        emit($cg, "({ ");
        emit($cg, "StradaArray *__map_input_" . $map_id . " = strada_deref_array(");
        gen_expression($cg, $array_expr);
        emit($cg, "); ");
        emit($cg, "StradaValue *__map_result_" . $map_id . " = strada_new_array(); ");
        emit($cg, "int __map_len_" . $map_id . " = strada_array_length(__map_input_" . $map_id . "); ");
        emit($cg, "for (int __map_i_" . $map_id . " = 0; __map_i_" . $map_id . " < __map_len_" . $map_id . "; __map_i_" . $map_id . "++) { ");
        emit($cg, "StradaValue *__elem_ = strada_array_get(__map_input_" . $map_id . ", __map_i_" . $map_id . "); ");

        # Set flag to enable $_ magic variable
        $cg->{"in_map_block"} = 1;

        # Generate block - the last statement's expression is the result
        my scalar $stmts = $block->{"statements"};
        my int $stmt_count = $block->{"statement_count"};
        if ($stmt_count > 0) {
            # Handle all but last statement normally
            my int $i = 0;
            while ($i < $stmt_count - 1) {
                gen_statement($cg, $stmts->[$i]);
                $i = $i + 1;
            }
            # Last statement - extract its expression for the result
            my scalar $last_stmt = $stmts->[$stmt_count - 1];
            if ($last_stmt->{"type"} == NODE_EXPR_STMT()) {
                emit($cg, "strada_array_push(strada_deref_array(__map_result_" . $map_id . "), ");
                gen_expression($cg, $last_stmt->{"expr"});
                emit($cg, "); ");
            }
        }

        # Reset flag
        $cg->{"in_map_block"} = 0;

        emit($cg, "} ");
        emit($cg, "__map_result_" . $map_id . "; })");
        return;
    }

    # Sort expression: sort { $a <=> $b } @array
    if ($type == NODE_SORT()) {
        my scalar $block = $expr->{"block"};
        my scalar $array_expr = $expr->{"array"};

        # Default sort (no block)
        if (!$block) {
            emit($cg, "strada_sort(");
            gen_expression($cg, $array_expr);
            emit($cg, ")");
            return;
        }

        # Custom sort with comparator block
        my int $sort_id = $cg->{"sort_counter"};
        $cg->{"sort_counter"} = $sort_id + 1;

        emit($cg, "({ ");
        emit($cg, "StradaArray *__sort_input_" . $sort_id . " = strada_deref_array(");
        gen_expression($cg, $array_expr);
        emit($cg, "); ");
        emit($cg, "int __sort_len_" . $sort_id . " = strada_array_length(__sort_input_" . $sort_id . "); ");
        emit($cg, "StradaValue *__sort_result_" . $sort_id . " = strada_new_array(); ");
        # Copy elements to result
        emit($cg, "for (int __si_" . $sort_id . " = 0; __si_" . $sort_id . " < __sort_len_" . $sort_id . "; __si_" . $sort_id . "++) { ");
        emit($cg, "strada_array_push(strada_deref_array(__sort_result_" . $sort_id . "), strada_array_get(__sort_input_" . $sort_id . ", __si_" . $sort_id . ")); } ");
        # Bubble sort with custom comparator (simple implementation)
        emit($cg, "for (int __i_" . $sort_id . " = 0; __i_" . $sort_id . " < __sort_len_" . $sort_id . " - 1; __i_" . $sort_id . "++) { ");
        emit($cg, "for (int __j_" . $sort_id . " = 0; __j_" . $sort_id . " < __sort_len_" . $sort_id . " - __i_" . $sort_id . " - 1; __j_" . $sort_id . "++) { ");
        emit($cg, "StradaValue *__sort_a_ = strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . "); ");
        emit($cg, "StradaValue *__sort_b_ = strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . " + 1); ");
        emit($cg, "int __cmp_" . $sort_id . " = strada_to_int(");

        # Set flag to enable $a/$b magic variables
        $cg->{"in_sort_block"} = 1;

        # Generate comparator block - extract the comparison expression
        my scalar $stmts = $block->{"statements"};
        my int $stmt_count = $block->{"statement_count"};
        if ($stmt_count > 0) {
            my scalar $last_stmt = $stmts->[$stmt_count - 1];
            if ($last_stmt->{"type"} == NODE_EXPR_STMT()) {
                gen_expression($cg, $last_stmt->{"expr"});
            }
        }

        # Reset flag
        $cg->{"in_sort_block"} = 0;

        emit($cg, "); ");
        emit($cg, "if (__cmp_" . $sort_id . " > 0) { ");
        emit($cg, "StradaValue *__tmp_" . $sort_id . " = strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . "); ");
        emit($cg, "strada_array_set(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . ", strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . " + 1)); ");
        emit($cg, "strada_array_set(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . " + 1, __tmp_" . $sort_id . "); ");
        emit($cg, "} } } ");
        emit($cg, "__sort_result_" . $sort_id . "; })");
        return;
    }

    # Grep expression: grep { block } @array
    if ($type == NODE_GREP()) {
        my scalar $block = $expr->{"block"};
        my scalar $array_expr = $expr->{"array"};
        my int $grep_id = $cg->{"grep_counter"};
        $cg->{"grep_counter"} = $grep_id + 1;

        emit($cg, "({ ");
        emit($cg, "StradaArray *__grep_input_" . $grep_id . " = strada_deref_array(");
        gen_expression($cg, $array_expr);
        emit($cg, "); ");
        emit($cg, "StradaValue *__grep_result_" . $grep_id . " = strada_new_array(); ");
        emit($cg, "int __grep_len_" . $grep_id . " = strada_array_length(__grep_input_" . $grep_id . "); ");
        emit($cg, "for (int __grep_i_" . $grep_id . " = 0; __grep_i_" . $grep_id . " < __grep_len_" . $grep_id . "; __grep_i_" . $grep_id . "++) { ");
        emit($cg, "StradaValue *__elem_ = strada_array_get(__grep_input_" . $grep_id . ", __grep_i_" . $grep_id . "); ");
        emit($cg, "if (strada_to_bool(");

        # Set flag to enable $_ magic variable
        $cg->{"in_grep_block"} = 1;

        # Generate block - evaluate to boolean
        my scalar $stmts = $block->{"statements"};
        my int $stmt_count = $block->{"statement_count"};
        if ($stmt_count > 0) {
            my scalar $last_stmt = $stmts->[$stmt_count - 1];
            if ($last_stmt->{"type"} == NODE_EXPR_STMT()) {
                gen_expression($cg, $last_stmt->{"expr"});
            }
        }

        # Reset flag
        $cg->{"in_grep_block"} = 0;

        emit($cg, ")) { ");
        emit($cg, "strada_array_push(strada_deref_array(__grep_result_" . $grep_id . "), __elem_); } ");
        emit($cg, "} ");
        emit($cg, "__grep_result_" . $grep_id . "; })");
        return;
    }

    # Anonymous function
    if ($type == NODE_ANON_FUNC()) {
        my int $id = $cg->{"anon_func_counter"};
        $cg->{"anon_func_counter"} = $id + 1;
        my str $func_name = "__anon_func_" . $id;

        my scalar $params = $expr->{"params"};
        my int $param_count = $expr->{"param_count"};

        # Save current capture state (for nested closures)
        my int $saved_in_anon = $cg->{"in_anon_func"};
        my str $saved_param_str = $cg->{"anon_param_str"};
        my str $saved_local_str = $cg->{"anon_local_str"};
        my str $saved_capture_str = $cg->{"anon_capture_str"};
        my int $saved_capture_count = $cg->{"anon_capture_count"};

        # Set up capture context for this closure
        $cg->{"in_anon_func"} = 1;
        $cg->{"anon_local_str"} = "";
        $cg->{"anon_capture_str"} = "";
        $cg->{"anon_capture_count"} = 0;

        # Build param string from parameters
        my str $param_str = "";
        my int $i = 0;
        while ($i < $param_count) {
            my scalar $p = $params->[$i];
            if ($param_str eq "") {
                $param_str = $p->{"name"};
            } else {
                $param_str = $param_str . "," . $p->{"name"};
            }
            $i = $i + 1;
        }
        $cg->{"anon_param_str"} = $param_str;

        # Generate forward declaration (triple pointer for capture-by-reference)
        my str $decl = "StradaValue* " . $func_name . "(StradaValue ***__captures";
        $i = 0;
        while ($i < $param_count) {
            my scalar $p = $params->[$i];
            $decl = $decl . ", StradaValue *" . $p->{"name"};
            $i = $i + 1;
        }
        $decl = $decl . ")";
        $cg->{"anon_func_decls"} = $cg->{"anon_func_decls"} . $decl . ";\n";

        my str $def = $decl . " {\n";

        # Save current output (using StringBuilder)
        my str $saved_output = sb_to_string($cg->{"output_sb"});
        my int $saved_indent = $cg->{"indent"};
        my int $saved_in_main = $cg->{"in_main"};

        # Save scope state (closures are separate functions with their own scope)
        my scalar $saved_scope_vars = $cg->{"scope_vars"};
        my scalar $saved_scope_counts = $cg->{"scope_counts"};
        my int $saved_scope_depth = $cg->{"scope_depth"};

        # Start fresh for function body (closures are NOT main)
        sb_clear($cg->{"output_sb"});
        $cg->{"indent"} = 1;
        $cg->{"in_main"} = 0;

        # Reset scope for closure (it's a new function)
        my array @new_scope_vars = ();
        my array @new_scope_counts = ();
        $cg->{"scope_vars"} = \@new_scope_vars;
        $cg->{"scope_counts"} = \@new_scope_counts;
        $cg->{"scope_depth"} = 0;

        # Generate body (this will populate capture_str as variables are accessed)
        my scalar $body = $expr->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $stmt_count = $body->{"statement_count"};
        $i = 0;
        while ($i < $stmt_count) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Get body content
        my str $body_content = sb_to_string($cg->{"output_sb"});
        $def = $def . $body_content;
        $def = $def . "}\n\n";

        # Capture the capture info before restoring state
        my str $capture_str = $cg->{"anon_capture_str"};
        my int $capture_count = $cg->{"anon_capture_count"};

        # Restore output (using StringBuilder)
        sb_clear($cg->{"output_sb"});
        sb_append($cg->{"output_sb"}, $saved_output);
        $cg->{"indent"} = $saved_indent;
        $cg->{"in_main"} = $saved_in_main;

        # Restore scope state
        $cg->{"scope_vars"} = $saved_scope_vars;
        $cg->{"scope_counts"} = $saved_scope_counts;
        $cg->{"scope_depth"} = $saved_scope_depth;

        # Restore capture state
        $cg->{"in_anon_func"} = $saved_in_anon;
        $cg->{"anon_param_str"} = $saved_param_str;
        $cg->{"anon_local_str"} = $saved_local_str;
        $cg->{"anon_capture_str"} = $saved_capture_str;
        $cg->{"anon_capture_count"} = $saved_capture_count;

        $cg->{"anon_func_defs"} = $cg->{"anon_func_defs"} . $def;

        # Emit closure creation with captures (using double pointers for capture-by-reference)
        if ($capture_count == 0) {
            emit($cg, "strada_closure_new((void*)&" . $func_name . ", " . $param_count . ", 0, NULL)");
        } else {
            # Build capture array inline with addresses for capture-by-reference
            emit($cg, "strada_closure_new((void*)&" . $func_name . ", " . $param_count . ", " . $capture_count . ", ");
            emit($cg, "(StradaValue**[]){");
            # Parse capture_str to emit address of each captured variable
            my int $cap_idx = 0;
            my int $start = 0;
            my int $len = length($capture_str);
            $i = 0;
            while ($i <= $len) {
                my str $ch = "";
                if ($i < $len) { $ch = substr($capture_str, $i, 1); }
                if ($ch eq "," || $i == $len) {
                    if ($cap_idx > 0) { emit($cg, ", "); }
                    my str $cap_name = substr($capture_str, $start, $i - $start);
                    emit($cg, "&" . $cap_name);
                    $cap_idx = $cap_idx + 1;
                    $start = $i + 1;
                }
                $i = $i + 1;
            }
            emit($cg, "})");
        }
        return;
    }

    # Closure call
    if ($type == NODE_CLOSURE_CALL()) {
        emit($cg, "strada_closure_call(");
        gen_expression($cg, $expr->{"closure"});
        my scalar $args = $expr->{"args"};
        my int $arg_count = $expr->{"arg_count"};
        emit($cg, ", " . $arg_count);
        my int $i = 0;
        while ($i < $arg_count) {
            emit($cg, ", ");
            gen_expression($cg, $args->[$i]);
            $i = $i + 1;
        }
        emit($cg, ")");
        return;
    }

    # Ternary expression: cond ? true_expr : false_expr
    if ($type == NODE_TERNARY()) {
        emit($cg, "(");
        emit_condition($cg, $expr->{"condition"});
        emit($cg, " ? ");
        gen_expression($cg, $expr->{"true_expr"});
        emit($cg, " : ");
        gen_expression($cg, $expr->{"false_expr"});
        emit($cg, ")");
        return;
    }

    # Range expression: start..end
    if ($type == NODE_RANGE()) {
        emit($cg, "strada_range(");
        gen_expression($cg, $expr->{"start"});
        emit($cg, ", ");
        gen_expression($cg, $expr->{"end"});
        emit($cg, ")");
        return;
    }
}

# ============================================================
# Statement Code Generation
# ============================================================

func gen_block(scalar $cg, scalar $block) void {
    emit($cg, "{\n");
    indent($cg);
    scope_push($cg);

    my scalar $stmts = $block->{"statements"};
    my int $i = 0;
    while ($i < $block->{"statement_count"}) {
        gen_statement($cg, $stmts->[$i]);
        $i = $i + 1;
    }

    scope_pop($cg);
    dedent($cg);
    emit_indent($cg);
    emit($cg, "}");
}

func gen_statement(scalar $cg, scalar $stmt) void {
    # Emit #line directive for source-level debugging
    emit_line_for_stmt($cg, $stmt);

    my int $type = $stmt->{"type"};

    # Variable declaration
    if ($type == NODE_VAR_DECL()) {
        emit_indent($cg);

        # Track local variables when inside anonymous function
        if ($cg->{"in_anon_func"}) {
            my str $var_name = $stmt->{"name"};
            my str $local_str = $cg->{"anon_local_str"};
            if ($local_str eq "") {
                $cg->{"anon_local_str"} = $var_name;
            } else {
                $cg->{"anon_local_str"} = $local_str . "," . $var_name;
            }
        }

        my str $sigil = $stmt->{"sigil"};
        my int $var_type = $stmt->{"var_type"};
        # Escape C keywords in variable names (e.g., $for -> v_for)
        my str $c_name = escape_c_keyword($stmt->{"name"});

        # Struct type
        if ($var_type == TYPE_STRUCT()) {
            my str $type_name = $stmt->{"type_name"};
            # Register this variable as a struct type for function pointer detection
            $cg->{"struct_vars"}->{$stmt->{"name"}} = $type_name;
            emit($cg, $type_name . " *" . $c_name);
            if ($stmt->{"init"}) {
                my scalar $init = $stmt->{"init"};
                # Handle clone() for structs specially
                if ($init->{"type"} == NODE_CALL() && $init->{"name"} eq "clone") {
                    emit($cg, " = malloc(sizeof(" . $type_name . ")); memcpy(" . $c_name . ", ");
                    my scalar $args = $init->{"args"};
                    gen_expression($cg, $args->[0]);
                    emit($cg, ", sizeof(" . $type_name . "))");
                } else {
                    emit($cg, " = ");
                    gen_expression($cg, $init);
                }
            } else {
                emit($cg, " = malloc(sizeof(" . $type_name . "))");
            }
        } elsif ($sigil eq "%" || $var_type == TYPE_HASH()) {
            emit($cg, "StradaValue *" . $c_name);
            if ($stmt->{"init"}) {
                emit($cg, " = ");
                # Handle empty () which parser returns as anon_hash
                my scalar $init = $stmt->{"init"};
                if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                    emit($cg, "strada_new_hash()");
                } else {
                    gen_expression($cg, $init);
                    # If initializing from a variable or deref, incref to share ownership properly
                    my int $init_type = $init->{"type"};
                    if ($init_type == NODE_VARIABLE()) {
                        emit($cg, "; strada_incref(" . $c_name . ")");
                    } elsif ($init_type == NODE_DEREF_SCALAR() && $init->{"sigil"} eq "%") {
                        # Hash deref like %{$ref} returns borrowed reference - need to incref
                        emit($cg, "; strada_incref(" . $c_name . ")");
                    }
                }
            } else {
                emit($cg, " = strada_new_hash()");
            }
            # Handle initial capacity: my hash %name{size};
            if ($stmt->{"initial_capacity"}) {
                emit($cg, "; strada_hash_reserve_sv(" . $c_name . ", strada_to_int(");
                gen_expression($cg, $stmt->{"initial_capacity"});
                emit($cg, "))");
            }
        } elsif ($sigil eq "@" || $var_type == TYPE_ARRAY()) {
            emit($cg, "StradaValue *" . $c_name);
            if ($stmt->{"init"}) {
                emit($cg, " = ");
                # Handle empty () which parser returns as anon_hash
                my scalar $init = $stmt->{"init"};
                my int $init_type = $init->{"type"};
                if ($init_type == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                    emit($cg, "strada_new_array()");
                } elsif ($init_type == NODE_ANON_ARRAY()) {
                    # Array literal like [1, 2, 3] - generate directly
                    gen_expression($cg, $init);
                } elsif (is_scalar_expr($init)) {
                    # Single scalar expression like ($x) - wrap in array
                    # Create array and push the element
                    emit($cg, "strada_new_array(); strada_array_push(" . $c_name . "->value.av, ");
                    gen_expression($cg, $init);
                    emit($cg, ")");
                } else {
                    # Could be array/hash/function returning array - assign directly
                    gen_expression($cg, $init);
                    # If initializing from a variable or deref, incref to share ownership properly
                    # This is needed because the local variable will be decref'd at end of scope
                    if ($init_type == NODE_VARIABLE()) {
                        emit($cg, "; strada_incref(" . $c_name . ")");
                    } elsif ($init_type == NODE_DEREF_SCALAR() && $init->{"sigil"} eq "@") {
                        # Array deref like @{$ref} returns borrowed reference - need to incref
                        emit($cg, "; strada_incref(" . $c_name . ")");
                    }
                }
            } else {
                emit($cg, " = strada_new_array()");
            }
            # Handle initial capacity: my array @name[size];
            if ($stmt->{"initial_capacity"}) {
                emit($cg, "; strada_reserve_sv(" . $c_name . ", strada_to_int(");
                gen_expression($cg, $stmt->{"initial_capacity"});
                emit($cg, "))");
            }
        } else {
            emit($cg, "StradaValue *" . $c_name);
            if ($stmt->{"init"}) {
                emit($cg, " = ");
                gen_expression($cg, $stmt->{"init"});
                # If initializing from borrowed reference, incref to share ownership properly
                # This prevents the original value from being freed when this one goes out of scope
                my scalar $init = $stmt->{"init"};
                my int $init_type = $init->{"type"};
                if ($init_type == NODE_VARIABLE()) {
                    emit($cg, "; strada_incref(" . $c_name . ")");
                } elsif ($init_type == NODE_HASH_ACCESS()) {
                    # Hash access returns borrowed reference - need to incref
                    emit($cg, "; strada_incref(" . $c_name . ")");
                } elsif ($init_type == NODE_SUBSCRIPT()) {
                    # Array subscript also returns borrowed reference
                    emit($cg, "; strada_incref(" . $c_name . ")");
                } elsif ($init_type == NODE_DEREF_ARRAY()) {
                    # Arrow array dereference $ref->[idx] returns borrowed reference
                    emit($cg, "; strada_incref(" . $c_name . ")");
                } elsif ($init_type == NODE_DEREF_HASH()) {
                    # Arrow hash dereference $ref->{key} returns borrowed reference
                    emit($cg, "; strada_incref(" . $c_name . ")");
                }
            } else {
                emit($cg, " = strada_new_undef()");
            }
        }
        emit($cg, ";\n");
        # Track variable for scope cleanup (only StradaValue*, not structs)
        # Use escaped name for C code generation
        if ($var_type != TYPE_STRUCT()) {
            scope_track_var($cg, $c_name);
        }
        return;
    }
    
    # If statement
    if ($type == NODE_IF_STMT()) {
        emit_indent($cg);
        emit($cg, "if (");
        emit_condition($cg, $stmt->{"condition"});
        emit($cg, ") ");
        gen_block($cg, $stmt->{"then_block"});

        # Elsif clauses
        my scalar $elsif_conds = $stmt->{"elsif_conditions"};
        my scalar $elsif_blocks = $stmt->{"elsif_blocks"};
        my int $i = 0;
        while ($i < $stmt->{"elsif_count"}) {
            emit($cg, " else if (");
            emit_condition($cg, $elsif_conds->[$i]);
            emit($cg, ") ");
            gen_block($cg, $elsif_blocks->[$i]);
            $i = $i + 1;
        }
        
        # Else clause
        if ($stmt->{"else_block"}) {
            emit($cg, " else ");
            gen_block($cg, $stmt->{"else_block"});
        }
        
        emit($cg, "\n");
        return;
    }
    
    # While statement
    if ($type == NODE_WHILE_STMT()) {
        my str $label = $stmt->{"label"};
        emit_indent($cg);
        emit($cg, "while (");
        emit_condition($cg, $stmt->{"condition"});
        emit($cg, ") {\n");
        indent($cg);
        scope_push($cg);

        my scalar $body = $stmt->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Add continue label at end of loop body if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_continue: ;\n");
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Add break label after loop if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_break: ;\n");
        }
        return;
    }
    
    # For statement
    if ($type == NODE_FOR_STMT()) {
        my str $label = $stmt->{"label"};
        my str $loop_var_name = "";
        my int $has_var_decl = 0;

        # Check if init declares a variable that needs cleanup
        if ($stmt->{"init"}) {
            my scalar $init = $stmt->{"init"};
            if ($init->{"type"} == NODE_VAR_DECL()) {
                $has_var_decl = 1;
                $loop_var_name = escape_c_keyword($init->{"name"});
                # Wrap in a block for proper scoping
                emit_indent($cg);
                emit($cg, "{\n");
                indent($cg);
                emit_indent($cg);
                emit($cg, "StradaValue *" . $loop_var_name . " = ");
                if ($init->{"init"}) {
                    gen_expression($cg, $init->{"init"});
                } else {
                    emit($cg, "strada_new_undef()");
                }
                emit($cg, ";\n");
            }
        }

        emit_indent($cg);
        emit($cg, "for (");

        if ($stmt->{"init"} && $has_var_decl == 0) {
            gen_expression($cg, $stmt->{"init"});
        }
        emit($cg, "; ");

        if ($stmt->{"condition"}) {
            emit_condition($cg, $stmt->{"condition"});
        }
        emit($cg, "; ");

        if ($stmt->{"update"}) {
            my scalar $update = $stmt->{"update"};
            # Check if update is an increment/decrement - its return value must be freed
            if ($update->{"type"} == NODE_INCREMENT()) {
                emit($cg, "({ StradaValue *__upd_tmp = ");
                gen_expression($cg, $update);
                emit($cg, "; strada_decref(__upd_tmp); })");
            } else {
                gen_expression($cg, $update);
            }
        }

        emit($cg, ") {\n");
        indent($cg);
        scope_push($cg);

        my scalar $body = $stmt->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Add continue label at end of loop body if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_continue: ;\n");
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Clean up loop variable if we declared one
        if ($has_var_decl == 1) {
            emit_indent($cg);
            emit($cg, "strada_decref(" . $loop_var_name . ");\n");
            dedent($cg);
            emit_indent($cg);
            emit($cg, "}\n");
        }

        # Add break label after loop if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_break: ;\n");
        }
        return;
    }

    # Foreach statement
    if ($type == NODE_FOREACH_STMT()) {
        my str $label = $stmt->{"label"};
        my scalar $var_decl = $stmt->{"var_decl"};
        my str $var_name = escape_c_keyword($stmt->{"var_name"});
        my scalar $array_expr = $stmt->{"array"};
        my scalar $body = $stmt->{"body"};

        my int $foreach_id = $cg->{"foreach_counter"};
        $cg->{"foreach_counter"} = $foreach_id + 1;

        # Open a block scope
        emit_indent($cg);
        emit($cg, "{\n");
        indent($cg);
        scope_push($cg);

        # Get the array and iterate
        emit_indent($cg);
        emit($cg, "StradaValue *__foreach_arr_" . $foreach_id . " = ");
        gen_expression($cg, $array_expr);
        emit($cg, ";\n");

        emit_indent($cg);
        emit($cg, "StradaArray *__foreach_av_" . $foreach_id . " = strada_deref_array(__foreach_arr_" . $foreach_id . ");\n");

        emit_indent($cg);
        emit($cg, "int __foreach_len_" . $foreach_id . " = strada_array_length(__foreach_av_" . $foreach_id . ");\n");

        emit_indent($cg);
        emit($cg, "for (int __foreach_i_" . $foreach_id . " = 0; __foreach_i_" . $foreach_id . " < __foreach_len_" . $foreach_id . "; __foreach_i_" . $foreach_id . "++) {\n");
        indent($cg);
        scope_push($cg);

        # Declare or assign the loop variable
        emit_indent($cg);
        if ($var_decl) {
            # New variable declaration
            emit($cg, "StradaValue *" . $var_name . " = strada_array_get(__foreach_av_" . $foreach_id . ", __foreach_i_" . $foreach_id . ");\n");
        } else {
            # Existing variable - assign to it
            emit($cg, $var_name . " = strada_array_get(__foreach_av_" . $foreach_id . ", __foreach_i_" . $foreach_id . ");\n");
        }

        # Generate body statements
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Add continue label at end of loop body if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_continue: ;\n");
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Close block scope
        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Add break label after loop if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_break: ;\n");
        }
        return;
    }

    # Return statement
    if ($type == NODE_RETURN_STMT()) {
        my int $in_main = $cg->{"in_main"};
        my int $returns_struct = $cg->{"returns_struct"};
        my int $cleanup_enabled = $cg->{"cleanup_enabled"};
        my int $profiling = $cg->{"enable_profiling"};
        my str $func_name = $cg->{"current_func_name"};
        my int $in_extern = $cg->{"in_extern"};

        # extern functions - simple return with raw C types
        if ($in_extern == 1) {
            emit_indent($cg);
            emit($cg, "return");
            if ($stmt->{"value"}) {
                emit($cg, " ");
                gen_expression($cg, $stmt->{"value"});
            }
            emit($cg, ";\n");
            return;
        }

        # main() and struct-returning functions - evaluate return value, cleanup, then return
        if ($in_main == 1 || $returns_struct == 1) {
            if ($stmt->{"value"}) {
                # Evaluate return expression BEFORE cleanup to avoid use-after-free
                emit_indent($cg);
                if ($in_main == 1) {
                    if ($stmt->{"value"}->{"type"} == NODE_INT_LITERAL()) {
                        # Simple literal - can emit directly after cleanup
                        if ($cleanup_enabled == 1) {
                            scope_emit_all_cleanup($cg);
                        }
                        emit_try_cleanup($cg);
                        emit_indent($cg);
                        emit($cg, "return " . $stmt->{"value"}->{"value"} . ";\n");
                    } else {
                        # Complex expression - evaluate first, then cleanup
                        emit($cg, "{ int __main_ret = strada_to_int(");
                        gen_expression($cg, $stmt->{"value"});
                        emit($cg, ");\n");
                        indent($cg);
                        if ($cleanup_enabled == 1) {
                            scope_emit_all_cleanup($cg);
                        }
                        emit_try_cleanup($cg);
                        emit_indent($cg);
                        emit($cg, "return __main_ret; }\n");
                        dedent($cg);
                    }
                } else {
                    # Struct return - evaluate first
                    emit($cg, "{ ");
                    my str $ret_type = $cg->{"current_func_return_type_str"};
                    if (length($ret_type) == 0) {
                        $ret_type = "void*";
                    }
                    emit($cg, $ret_type . " __struct_ret = ");
                    gen_expression($cg, $stmt->{"value"});
                    emit($cg, ";\n");
                    indent($cg);
                    if ($cleanup_enabled == 1) {
                        scope_emit_all_cleanup($cg);
                    }
                    emit_try_cleanup($cg);
                    emit_indent($cg);
                    emit($cg, "return __struct_ret; }\n");
                    dedent($cg);
                }
            } else {
                # No return value - cleanup then return
                if ($cleanup_enabled == 1) {
                    scope_emit_all_cleanup($cg);
                }
                emit_try_cleanup($cg);
                emit_indent($cg);
                emit($cg, "return;\n");
            }
        } elsif ($cleanup_enabled == 0) {
            # Cleanup disabled - simple return
            # Still need to pop try blocks even if cleanup is disabled
            emit_try_cleanup($cg);
            # Add profiling exit if enabled (for non-main)
            if ($profiling == 1 && $in_main == 0 && length($func_name) > 0) {
                if ($stmt->{"value"}) {
                    # Save return value, call profile_exit, then return
                    emit_indent($cg);
                    emit($cg, "{ StradaValue *__retval = ");
                    gen_expression($cg, $stmt->{"value"});
                    emit($cg, "; strada_profile_exit(\"" . $func_name . "\"); return __retval; }\n");
                } else {
                    emit_indent($cg);
                    emit($cg, "strada_profile_exit(\"" . $func_name . "\");\n");
                    emit_indent($cg);
                    emit($cg, "return;\n");
                }
            } else {
                emit_indent($cg);
                emit($cg, "return");
                if ($stmt->{"value"}) {
                    emit($cg, " ");
                    gen_expression($cg, $stmt->{"value"});
                }
                emit($cg, ";\n");
            }
        } elsif ($stmt->{"value"}) {
            # Non-main function with return value - save, cleanup, return
            emit_indent($cg);
            emit($cg, "{ StradaValue *__retval = ");
            gen_expression($cg, $stmt->{"value"});
            emit($cg, ";\n");
            indent($cg);
            # Only incref if returning a variable/borrowed ref (not for new values)
            if (return_needs_incref($stmt->{"value"}) == 1) {
                emit_indent($cg);
                emit($cg, "strada_incref(__retval);\n");
            }
            scope_emit_all_cleanup($cg);
            # Pop any active try blocks before returning
            emit_try_cleanup($cg);
            # Add profiling exit if enabled
            if ($profiling == 1 && length($func_name) > 0) {
                emit_indent($cg);
                emit($cg, "strada_profile_exit(\"" . $func_name . "\");\n");
            }
            emit_indent($cg);
            emit($cg, "return __retval; }\n");
            dedent($cg);
        } else {
            # Void return - cleanup then return
            scope_emit_all_cleanup($cg);
            # Pop any active try blocks before returning
            emit_try_cleanup($cg);
            # Add profiling exit if enabled
            if ($profiling == 1 && length($func_name) > 0) {
                emit_indent($cg);
                emit($cg, "strada_profile_exit(\"" . $func_name . "\");\n");
            }
            emit_indent($cg);
            emit($cg, "return;\n");
        }
        return;
    }
    
    # Expression statement
    if ($type == NODE_EXPR_STMT()) {
        emit_indent($cg);
        my scalar $expr = $stmt->{"expr"};
        # Check if expression is an increment/decrement - its return value must be freed
        if ($expr->{"type"} == NODE_INCREMENT()) {
            emit($cg, "({ StradaValue *__expr_tmp = ");
            gen_expression($cg, $expr);
            emit($cg, "; strada_decref(__expr_tmp); });\n");
        } else {
            gen_expression($cg, $expr);
            emit($cg, ";\n");
        }
        return;
    }
    
    # Last (break)
    if ($type == 100) {
        my str $label = $stmt->{"label"};
        emit_indent($cg);
        if (length($label) > 0) {
            emit($cg, "goto ");
            emit($cg, $label);
            emit($cg, "_break;\n");
        } else {
            emit($cg, "break;\n");
        }
        return;
    }

    # Next (continue)
    if ($type == 101) {
        my str $label = $stmt->{"label"};
        emit_indent($cg);
        if (length($label) > 0) {
            emit($cg, "goto ");
            emit($cg, $label);
            emit($cg, "_continue;\n");
        } else {
            emit($cg, "continue;\n");
        }
        return;
    }

    # Try/Catch statement
    if ($type == NODE_TRY_CATCH()) {
        my str $catch_var = $stmt->{"catch_var"};
        emit_indent($cg);
        emit($cg, "if (setjmp(*STRADA_TRY_PUSH()) == 0) {\n");
        indent($cg);
        scope_push($cg);

        # Track that we're inside a try block (for proper cleanup on return)
        my int $try_depth = $cg->{"try_depth"};
        $cg->{"try_depth"} = $try_depth + 1;

        # Generate try block
        my scalar $try_block = $stmt->{"try_block"};
        my scalar $stmts = $try_block->{"statements"};
        my int $i = 0;
        while ($i < $try_block->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Decrement try_depth before we emit the pop (return after this point doesn't need extra cleanup)
        $cg->{"try_depth"} = $try_depth;

        emit_indent($cg);
        emit($cg, "STRADA_TRY_POP();\n");
        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "} else {\n");
        indent($cg);
        scope_push($cg);
        emit_indent($cg);
        emit($cg, "STRADA_TRY_POP();\n");

        # Declare catch variable and get exception
        emit_indent($cg);
        emit($cg, "StradaValue *");
        emit($cg, $catch_var);
        emit($cg, " = strada_get_exception();\n");
        # Track catch variable for cleanup
        scope_track_var($cg, $catch_var);

        # Generate catch block
        my scalar $catch_block = $stmt->{"catch_block"};
        my scalar $catch_stmts = $catch_block->{"statements"};
        my int $j = 0;
        while ($j < $catch_block->{"statement_count"}) {
            gen_statement($cg, $catch_stmts->[$j]);
            $j = $j + 1;
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");
        return;
    }

    # Throw statement
    if ($type == NODE_THROW()) {
        emit_indent($cg);
        emit($cg, "strada_throw_value(");
        gen_expression($cg, $stmt->{"expr"});
        emit($cg, ");\n");
        return;
    }

    # Label statement
    if ($type == NODE_LABEL()) {
        emit($cg, $stmt->{"name"} . ":;\n");
        return;
    }

    # Goto statement
    if ($type == NODE_GOTO()) {
        emit_indent($cg);
        emit($cg, "goto " . $stmt->{"target"} . ";\n");
        return;
    }

    # Switch statement
    if ($type == NODE_SWITCH()) {
        # Generate a unique variable to hold the switch expression
        my int $switch_id = $cg->{"switch_counter"};
        $cg->{"switch_counter"} = $switch_id + 1;
        my str $switch_var = "_switch_val_" . $switch_id;

        emit_indent($cg);
        emit($cg, "{\n");
        indent($cg);

        # Evaluate switch expression once
        emit_indent($cg);
        emit($cg, "StradaValue *" . $switch_var . " = ");
        gen_expression($cg, $stmt->{"expr"});
        emit($cg, ";\n");

        my scalar $cases = $stmt->{"cases"};
        my scalar $blocks = $stmt->{"blocks"};
        my int $case_count = $stmt->{"case_count"};
        my int $i = 0;

        while ($i < $case_count) {
            emit_indent($cg);
            if ($i == 0) {
                emit($cg, "if (strcmp(strada_to_str(" . $switch_var . "), strada_to_str(");
            } else {
                emit($cg, "} else if (strcmp(strada_to_str(" . $switch_var . "), strada_to_str(");
            }
            gen_expression($cg, $cases->[$i]);
            emit($cg, ")) == 0) {\n");
            indent($cg);

            # Generate the block body (statements only, not the braces)
            my scalar $block = $blocks->[$i];
            my scalar $stmts = $block->{"statements"};
            my int $j = 0;
            while ($j < $block->{"statement_count"}) {
                gen_statement($cg, $stmts->[$j]);
                $j = $j + 1;
            }

            dedent($cg);
            $i = $i + 1;
        }

        # Default block
        my int $has_default = $stmt->{"has_default"};
        if ($has_default) {
            my scalar $default_block = $stmt->{"default_block"};
            emit_indent($cg);
            if ($case_count > 0) {
                emit($cg, "} else {\n");
            } else {
                emit($cg, "{\n");
            }
            indent($cg);

            my scalar $def_stmts = $default_block->{"statements"};
            my int $k = 0;
            while ($k < $default_block->{"statement_count"}) {
                gen_statement($cg, $def_stmts->[$k]);
                $k = $k + 1;
            }

            dedent($cg);
        }

        if ($case_count > 0 || $has_default) {
            emit_indent($cg);
            emit($cg, "}\n");
        }

        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");
        return;
    }
}

# ============================================================
# Function and Program Code Generation
# ============================================================

func gen_function(scalar $cg, scalar $fn) void {
    my str $ret_type = type_to_c($fn->{"return_type"});
    my str $name = sanitize_name($fn->{"name"});
    my int $ret_type_id = $fn->{"return_type"};

    # Track if function returns a struct (for return statement handling)
    if ($ret_type_id == TYPE_STRUCT()) {
        $cg->{"returns_struct"} = 1;
    } else {
        $cg->{"returns_struct"} = 0;
    }

    # Special case for main
    if ($name eq "main") {
        $cg->{"in_main"} = 1;
        emit($cg, "int main(int _argc, char **_argv) {\n");
        emit($cg, "    /* Initialize proctitle support */\n");
        emit($cg, "    strada_init_proctitle(_argc, _argv);\n\n");

        # Initialize profiling if enabled
        if ($cg->{"enable_profiling"} == 1) {
            emit($cg, "    /* Initialize function profiling */\n");
            emit($cg, "    strada_profile_init();\n");
            emit($cg, "    atexit(strada_profile_report);\n\n");
        }
        emit($cg, "    /* Populate global ARGV array */\n");
        emit($cg, "    ARGV = strada_new_array();\n");
        emit($cg, "    for (int i = 0; i < _argc; i++) {\n");
        emit($cg, "        strada_array_push(ARGV->value.av, strada_new_str(_argv[i]));\n");
        emit($cg, "    }\n");
        emit($cg, "    ARGC = strada_new_int(_argc);\n\n");

        # Set package if declared at file level
        my str $pkg = $cg->{"package"};
        if ($pkg ne "") {
            emit($cg, "    /* Set package from file-level declaration */\n");
            emit($cg, "    strada_set_package(\"" . $pkg . "\");\n\n");
        }

        # Set up inheritance from file-level declarations
        my scalar $inherits = $cg->{"inherits"};
        my int $inherit_count = $cg->{"inherit_count"};
        if ($inherit_count > 0) {
            emit($cg, "    /* Set up inheritance from file-level declarations */\n");
            my int $inh = 0;
            while ($inh < $inherit_count) {
                my str $parent = $inherits->[$inh];
                emit($cg, "    strada_inherit_from(\"" . $parent . "\");\n");
                $inh = $inh + 1;
            }
            emit($cg, "\n");
        }

        # Initialize OOP method registration for all packages that have methods
        my int $num_oop_pkgs = get_oop_pkg_count($cg);
        if ($num_oop_pkgs > 0) {
            my scalar $oop_pkgs = get_oop_packages($cg);
            emit($cg, "    /* Initialize OOP method registration */\n");
            my int $oop_i = 0;
            while ($oop_i < $num_oop_pkgs) {
                my str $oop_pkg = $oop_pkgs->[$oop_i];
                emit($cg, "    __" . $oop_pkg . "_oop_init();\n");
                $oop_i = $oop_i + 1;
            }
            emit($cg, "\n");
        }

        # If main has parameters, bind argc/argv to them
        my scalar $params = $fn->{"params"};
        my int $param_count = $fn->{"param_count"};
        if ($param_count >= 1) {
            # First parameter gets argc
            my scalar $p1 = $params->[0];
            emit($cg, "    StradaValue* " . $p1->{"name"} . " = ARGC;\n");
        }
        if ($param_count >= 2) {
            # Second parameter gets argv array
            my scalar $p2 = $params->[1];
            emit($cg, "    StradaValue* " . $p2->{"name"} . " = ARGV;\n");
        }
        if ($param_count > 0) {
            emit($cg, "\n");
        }

        # Initialize global variables
        my int $global_count = $cg->{"global_count"};
        if ($global_count > 0) {
            emit($cg, "    /* Initialize global variables */\n");
            my scalar $globals = $cg->{"globals"};
            my int $g = 0;
            while ($g < $global_count) {
                my scalar $gvar = $globals->[$g];
                my int $var_type = $gvar->{"var_type"};
                my str $sigil = $gvar->{"sigil"};
                my str $name = $gvar->{"name"};
                my scalar $init = $gvar->{"init"};

                emit($cg, "    " . $name . " = ");
                if ($var_type == TYPE_STRUCT()) {
                    my str $type_name = $gvar->{"type_name"};
                    if ($init) {
                        gen_expression($cg, $init);
                    } else {
                        emit($cg, "malloc(sizeof(" . $type_name . "))");
                    }
                } elsif ($sigil eq "%" || $var_type == TYPE_HASH()) {
                    if ($init) {
                        # Handle empty () which parser returns as anon_hash
                        if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                            emit($cg, "strada_new_hash()");
                        } else {
                            gen_expression($cg, $init);
                        }
                    } else {
                        emit($cg, "strada_new_hash()");
                    }
                } elsif ($sigil eq "@" || $var_type == TYPE_ARRAY()) {
                    if ($init) {
                        # Handle empty () which parser returns as anon_hash
                        if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                            emit($cg, "strada_new_array()");
                        } else {
                            gen_expression($cg, $init);
                        }
                    } else {
                        emit($cg, "strada_new_array()");
                    }
                } else {
                    if ($init) {
                        gen_expression($cg, $init);
                    } else {
                        emit($cg, "strada_new_undef()");
                    }
                }
                emit($cg, ";\n");
                $g = $g + 1;
            }
            emit($cg, "\n");
        }

        # Generate the body statements directly (without the outer braces)
        # Push scope for main's local variables
        scope_push($cg);
        my scalar $body = $fn->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }
        scope_pop($cg);
        emit($cg, "}\n\n");
        $cg->{"in_main"} = 0;
    } else {
        emit($cg, $ret_type . " " . $name . "(");
        
        my scalar $params = $fn->{"params"};
        my int $i = 0;
        while ($i < $fn->{"param_count"}) {
            if ($i > 0) {
                emit($cg, ", ");
            }
            my scalar $param = $params->[$i];
            my int $ptype = $param->{"param_type"};
            my str $c_param_name = escape_c_keyword($param->{"name"});
            if ($ptype == TYPE_STRUCT()) {
                # Register struct-typed parameter for function pointer detection
                $cg->{"struct_vars"}->{$param->{"name"}} = $param->{"type_name"};
                emit($cg, $param->{"type_name"} . " *" . $c_param_name);
            } else {
                emit($cg, type_to_c($ptype) . " " . $c_param_name);
            }
            $i = $i + 1;
        }

        if ($fn->{"param_count"} == 0) {
            emit($cg, "void");
        }

        emit($cg, ") {\n");

        # Add profiling entry if enabled
        if ($cg->{"enable_profiling"} == 1) {
            emit($cg, "    strada_profile_enter(\"" . $name . "\");\n");
        }

        # Store current function name for profiling exit in return statements
        $cg->{"current_func_name"} = $name;

        # Store current function's package for SUPER:: calls
        $cg->{"current_fn_package"} = $fn->{"package"};

        # Generate the function body (without the outer braces, we handle them)
        scope_push($cg);
        my scalar $body = $fn->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $stmt_i = 0;
        while ($stmt_i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$stmt_i]);
            $stmt_i = $stmt_i + 1;
        }
        scope_pop($cg);

        # Add implicit profiling exit for void functions (no explicit return)
        if ($cg->{"enable_profiling"} == 1 && $ret_type_id == TYPE_VOID()) {
            emit($cg, "    strada_profile_exit(\"" . $name . "\");\n");
        }
        emit($cg, "}\n");

        $cg->{"current_func_name"} = "";
        $cg->{"current_fn_package"} = "";

        # Clear struct_vars for parameters (they go out of scope)
        $i = 0;
        while ($i < $fn->{"param_count"}) {
            my scalar $param = $params->[$i];
            if ($param->{"param_type"} == TYPE_STRUCT()) {
                $cg->{"struct_vars"}->{$param->{"name"}} = "";
            }
            $i = $i + 1;
        }
        emit($cg, "\n\n");
    }
}

func gen_program(scalar $cg, scalar $program) void {
    # First pass: register all functions for default parameter handling
    my scalar $funcs = $program->{"functions"};
    my int $i = 0;
    my int $reg = 0;
    while ($reg < $program->{"function_count"}) {
        codegen_register_function($cg, $funcs->[$reg]);
        $reg = $reg + 1;
    }
    
    # Store package name in codegen context for later use
    $cg->{"package"} = $program->{"package"};

    # Store inherits in codegen context for later use
    $cg->{"inherits"} = $program->{"inherits"};
    $cg->{"inherit_count"} = $program->{"inherit_count"};

    # Header
    emit($cg, "/* Generated by Strada Self-Hosting Compiler */\n");

    # Package name
    if ($program->{"package"} ne "") {
        emit($cg, "/* Package: " . $program->{"package"} . " */\n");
    }
    
    emit($cg, "#include \"strada_runtime.h\"\n");
    emit($cg, "#include <string.h>\n");
    emit($cg, "#include <stdint.h>\n");
    emit($cg, "#include <stdbool.h>\n");
    emit($cg, "#include <dlfcn.h>\n");
    emit($cg, "#include <math.h>\n\n");
    
    # Check if there's a main function
    my int $has_main = 0;
    $i = 0;
    while ($i < $program->{"function_count"}) {
        if ($funcs->[$i]->{"name"} eq "main") {
            $has_main = 1;
            last;
        }
        $i = $i + 1;
    }
    
    # Global ARGV and ARGC (only for files with main)
    if ($has_main == 1) {
        emit($cg, "/* Global command-line argument variables */\n");
        emit($cg, "StradaValue *ARGV = NULL;\n");
        emit($cg, "StradaValue *ARGC = NULL;\n\n");
    } else {
        emit($cg, "/* External globals from main module */\n");
        emit($cg, "extern StradaValue *ARGV;\n");
        emit($cg, "extern StradaValue *ARGC;\n\n");
    }

    # Emit global variable declarations
    my int $global_count = $program->{"global_count"};
    if ($global_count > 0) {
        my scalar $globals = $program->{"globals"};
        emit($cg, "/* Global variables */\n");
        my int $g = 0;
        while ($g < $global_count) {
            my scalar $gvar = $globals->[$g];
            my int $var_type = $gvar->{"var_type"};
            my str $name = $gvar->{"name"};

            if ($var_type == TYPE_STRUCT()) {
                my str $type_name = $gvar->{"type_name"};
                emit($cg, $type_name . " *" . $name . " = NULL;\n");
            } else {
                emit($cg, "StradaValue *" . $name . " = NULL;\n");
            }
            $g = $g + 1;
        }
        emit($cg, "\n");
    }

    # Store globals in codegen context for initialization in main
    $cg->{"globals"} = $program->{"globals"};
    $cg->{"global_count"} = $program->{"global_count"};

    # Build struct definitions map for later use (function pointer detection)
    my scalar $structs = $program->{"structs"};
    my int $s = 0;
    while ($s < $program->{"struct_count"}) {
        my scalar $st = $structs->[$s];
        my str $struct_name = $st->{"name"};
        my hash %struct_info = ();
        $struct_info{"fields"} = {};

        my scalar $fields = $st->{"fields"};
        my int $f = 0;
        while ($f < $st->{"field_count"}) {
            my scalar $field = $fields->[$f];
            my int $ftype = $field->{"field_type"};
            my hash %field_info = ();
            $field_info{"is_funcptr"} = $ftype == TYPE_FUNCPTR();
            $struct_info{"fields"}->{$field->{"name"}} = \%field_info;
            $f = $f + 1;
        }
        $cg->{"struct_defs"}->{$struct_name} = \%struct_info;
        $s = $s + 1;
    }

    # Generate struct definitions
    $s = 0;
    while ($s < $program->{"struct_count"}) {
        my scalar $st = $structs->[$s];
        emit($cg, "typedef struct {\n");

        my scalar $fields = $st->{"fields"};
        my int $f = 0;
        while ($f < $st->{"field_count"}) {
            my scalar $field = $fields->[$f];
            my int $ftype = $field->{"field_type"};

            if ($ftype == TYPE_FUNCPTR()) {
                # Function pointer field - generate as void pointer for now
                # In a full implementation, we'd track the exact signature
                emit($cg, "    void *" . $field->{"name"} . ";\n");
            } else {
                emit($cg, "    StradaValue *" . $field->{"name"} . ";\n");
            }
            $f = $f + 1;
        }

        emit($cg, "} " . $st->{"name"} . ";\n\n");
        $s = $s + 1;
    }
    
    # Generate extern declarations for imported functions
    my int $imp_count = $program->{"import_count"};
    if ($imp_count > 0) {
        emit($cg, "/* Imported function declarations */\n");
        my scalar $imports = $program->{"imports"};
        my int $imp = 0;
        while ($imp < $imp_count) {
            my str $imp_name = $imports->[$imp];
            # Generate generic extern declaration (assume StradaValue* return and variadic params)
            emit($cg, "extern StradaValue* " . $imp_name . "();\n");
            $imp = $imp + 1;
        }
        emit($cg, "\n");
    }
    
    # Generate extern declarations for qualified module function calls
    my int $use_count = $program->{"use_count"};
    if ($use_count > 0) {
        my scalar $uses = $program->{"uses"};
        my int $u = 0;
        while ($u < $use_count) {
            my str $mod_name = $uses->[$u];
            # Skip "lib" pseudo-module
            if ($mod_name ne "lib") {
                # Convert :: to __ for C identifier prefix
                my str $prefix = "";
                my int $p = 0;
                my int $plen = length($mod_name);
                while ($p < $plen) {
                    my str $ch = substr($mod_name, $p, 1);
                    if ($ch eq ":") {
                        $prefix = $prefix . "_";
                    } else {
                        $prefix = $prefix . $ch;
                    }
                    $p = $p + 1;
                }
                $prefix = $prefix . "__";
                
                # Generate extern declarations for imported funcs with qualified names
                emit($cg, "/* Qualified imports from " . $mod_name . " */\n");
                my scalar $imports = $program->{"imports"};
                my int $imp = 0;
                while ($imp < $program->{"import_count"}) {
                    my str $imp_name = $imports->[$imp];
                    emit($cg, "extern StradaValue* " . $prefix . $imp_name . "();\n");
                    $imp = $imp + 1;
                }
                emit($cg, "\n");
            }
            $u = $u + 1;
        }
    }

    # Generate import_lib wrapper infrastructure
    my int $import_lib_count = $program->{"import_lib_count"};
    if ($import_lib_count > 0) {
        my scalar $import_libs = $program->{"import_libs"};

        emit($cg, "/* import_lib: static library handles and function pointers */\n");

        my int $lib_idx = 0;
        while ($lib_idx < $import_lib_count) {
            my scalar $lib_info = $import_libs->[$lib_idx];
            my str $lib_name = $lib_info->{"lib_name"};
            my str $safe_lib = sanitize_name($lib_name);

            # Static handle for the library
            emit($cg, "static void *__import_lib_" . $safe_lib . "_handle = NULL;\n");

            # Static function pointers for each function
            my scalar $lib_funcs = $lib_info->{"functions"};
            my int $fn_idx = 0;
            my int $fn_count = $lib_info->{"function_count"};
            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $lib_funcs->[$fn_idx];
                my str $fn_name = sanitize_name($fn_info->{"name"});
                emit($cg, "static void *__import_lib_" . $safe_lib . "_fn_" . $fn_name . " = NULL;\n");
                $fn_idx = $fn_idx + 1;
            }

            $lib_idx = $lib_idx + 1;
        }
        emit($cg, "\n");

        # Forward declarations for wrapper functions
        emit($cg, "/* import_lib: wrapper function forward declarations */\n");
        $lib_idx = 0;
        while ($lib_idx < $import_lib_count) {
            my scalar $lib_info = $import_libs->[$lib_idx];
            my scalar $lib_funcs = $lib_info->{"functions"};
            my int $fn_idx = 0;
            my int $fn_count = $lib_info->{"function_count"};

            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $lib_funcs->[$fn_idx];
                my str $fn_name = sanitize_name($fn_info->{"name"});
                my int $ret_type = $fn_info->{"return_type"};
                my int $param_count = $fn_info->{"param_count"};
                my scalar $params = $fn_info->{"params"};

                emit($cg, type_to_c($ret_type) . " " . $fn_name . "(");

                my int $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$p];
                    my int $ptype = $param->{"param_type"};
                    emit($cg, type_to_c($ptype) . " " . escape_c_keyword($param->{"name"}));
                    $p = $p + 1;
                }

                if ($param_count == 0) {
                    emit($cg, "void");
                }

                emit($cg, ");\n");
                $fn_idx = $fn_idx + 1;
            }

            $lib_idx = $lib_idx + 1;
        }
        emit($cg, "\n");
    }

    # Forward declarations
    $i = 0;
    while ($i < $program->{"function_count"}) {
        my scalar $fn = $funcs->[$i];
        my str $name = sanitize_name($fn->{"name"});
        my int $fn_type = $fn->{"type"};
        
        # Skip extern functions (they're declared elsewhere)
        if ($fn_type == NODE_EXTERN_FUNC()) {
            # Generate extern declaration
            emit($cg, "extern ");
            gen_extern_decl($cg, $fn);
            $i = $i + 1;
            next;
        }
        
        if ($name eq "main") {
            emit($cg, "int main(int _argc, char **_argv);\n");
        } else {
            emit($cg, type_to_c($fn->{"return_type"}) . " " . $name . "(");
            
            my scalar $params = $fn->{"params"};
            my int $j = 0;
            while ($j < $fn->{"param_count"}) {
                if ($j > 0) {
                    emit($cg, ", ");
                }
                my scalar $param = $params->[$j];
                my int $ptype = $param->{"param_type"};
                my str $c_pname = escape_c_keyword($param->{"name"});
                if ($ptype == TYPE_STRUCT()) {
                    emit($cg, $param->{"type_name"} . " *" . $c_pname);
                } else {
                    emit($cg, type_to_c($ptype) . " " . $c_pname);
                }
                $j = $j + 1;
            }

            if ($fn->{"param_count"} == 0) {
                emit($cg, "void");
            }

            emit($cg, ");\n");
        }
        $i = $i + 1;
    }

    # NOTE: OOP init forward declarations are generated after methods are tracked
    # and stored in oop_fwd_decls for insertion in get_output()

    emit($cg, "\n");

    # Save preamble content and start fresh for function definitions
    $cg->{"preamble_content"} = sb_to_string($cg->{"output_sb"});
    sb_clear($cg->{"output_sb"});

    # Function definitions (skip extern declarations without bodies)
    $i = 0;
    while ($i < $program->{"function_count"}) {
        my scalar $fn = $funcs->[$i];
        my int $fn_type = $fn->{"type"};

        if ($fn_type == NODE_EXTERN_FUNC()) {
            # Extern with body - generate the function
            if ($fn->{"has_body"} == 1) {
                gen_extern_function($cg, $fn);
            }
        } else {
            gen_function($cg, $fn);
        }

        # Track method for OOP registration using the function's stored package
        # (check package string directly - parser always sets it)
        my str $fn_pkg = $fn->{"package"};
        if (length($fn_pkg) > 0 && $fn_pkg ne "main") {
            codegen_track_method($cg, $fn, $fn_pkg);
        }

        $i = $i + 1;
    }

    # Generate OOP init forward declarations (now that methods are tracked)
    my int $num_fwd_pkgs = get_oop_pkg_count($cg);
    if ($num_fwd_pkgs > 0) {
        my scalar $fwd_pkgs = get_oop_packages($cg);
        my str $fwd_decls = "\n/* OOP method registration forward declarations */\n";
        my int $fwd_i = 0;
        while ($fwd_i < $num_fwd_pkgs) {
            my str $fwd_pkg = $fwd_pkgs->[$fwd_i];
            $fwd_decls = $fwd_decls . "void __" . $fwd_pkg . "_oop_init(void);\n";
            $fwd_i = $fwd_i + 1;
        }
        $cg->{"oop_fwd_decls"} = $fwd_decls;
    }

    # Emit anonymous function definitions
    my str $anon_defs = $cg->{"anon_func_defs"};
    if (length($anon_defs) > 0) {
        emit($cg, "\n/* Anonymous function definitions */\n");
        emit($cg, $anon_defs);
    }

    # Emit OOP method wrappers for all packages
    my str $wrappers = gen_all_method_wrappers($cg);
    if (length($wrappers) > 0) {
        emit($cg, "\n");
        emit($cg, $wrappers);
    }

    # Generate import_lib wrapper function implementations
    if ($import_lib_count > 0) {
        my scalar $import_libs = $program->{"import_libs"};
        emit($cg, "\n/* import_lib: wrapper function implementations */\n");

        my int $lib_idx = 0;
        while ($lib_idx < $import_lib_count) {
            my scalar $lib_info = $import_libs->[$lib_idx];
            my str $lib_name = $lib_info->{"lib_name"};
            my str $safe_lib = sanitize_name($lib_name);
            my str $so_path = $lib_info->{"so_path"};

            my scalar $lib_funcs = $lib_info->{"functions"};
            my int $fn_idx = 0;
            my int $fn_count = $lib_info->{"function_count"};

            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $lib_funcs->[$fn_idx];
                my str $fn_name = sanitize_name($fn_info->{"name"});
                my int $ret_type = $fn_info->{"return_type"};
                my int $param_count = $fn_info->{"param_count"};
                my scalar $params = $fn_info->{"params"};

                # Function signature
                emit($cg, type_to_c($ret_type) . " " . $fn_name . "(");

                my int $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$p];
                    my int $ptype = $param->{"param_type"};
                    emit($cg, type_to_c($ptype) . " " . escape_c_keyword($param->{"name"}));
                    $p = $p + 1;
                }

                if ($param_count == 0) {
                    emit($cg, "void");
                }

                emit($cg, ") {\n");

                # Lazy load the library
                emit($cg, "    if (__import_lib_" . $safe_lib . "_handle == NULL) {\n");
                emit($cg, "        __import_lib_" . $safe_lib . "_handle = dlopen(\"" . $so_path . "\", RTLD_LAZY);\n");
                emit($cg, "        if (__import_lib_" . $safe_lib . "_handle == NULL) {\n");
                emit($cg, "            fprintf(stderr, \"import_lib: failed to load " . $so_path . ": %s\\n\", dlerror());\n");
                emit($cg, "            exit(1);\n");
                emit($cg, "        }\n");
                emit($cg, "    }\n");

                # Lazy lookup the function pointer
                emit($cg, "    if (__import_lib_" . $safe_lib . "_fn_" . $fn_name . " == NULL) {\n");
                emit($cg, "        __import_lib_" . $safe_lib . "_fn_" . $fn_name . " = dlsym(__import_lib_" . $safe_lib . "_handle, \"" . $fn_name . "\");\n");
                emit($cg, "        if (__import_lib_" . $safe_lib . "_fn_" . $fn_name . " == NULL) {\n");
                emit($cg, "            fprintf(stderr, \"import_lib: symbol not found: " . $fn_name . ": %s\\n\", dlerror());\n");
                emit($cg, "            exit(1);\n");
                emit($cg, "        }\n");
                emit($cg, "    }\n");

                # Generate typedef for the function pointer type
                emit($cg, "    typedef " . type_to_c($ret_type) . " (*__fn_type_" . $fn_name . ")(");
                $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    emit($cg, "StradaValue*");
                    $p = $p + 1;
                }
                if ($param_count == 0) {
                    emit($cg, "void");
                }
                emit($cg, ");\n");

                # Cast and call the function directly
                emit($cg, "    __fn_type_" . $fn_name . " __fn = (__fn_type_" . $fn_name . ")__import_lib_" . $safe_lib . "_fn_" . $fn_name . ";\n");
                if ($ret_type == TYPE_VOID()) {
                    emit($cg, "    __fn(");
                } else {
                    emit($cg, "    return __fn(");
                }
                $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$p];
                    emit($cg, escape_c_keyword($param->{"name"}));
                    $p = $p + 1;
                }
                emit($cg, ");\n");

                emit($cg, "}\n\n");
                $fn_idx = $fn_idx + 1;
            }

            $lib_idx = $lib_idx + 1;
        }
    }

    # Save funcs content and start fresh for remaining code
    $cg->{"funcs_content"} = sb_to_string($cg->{"output_sb"});
    sb_clear($cg->{"output_sb"});

    # Generate qualified name aliases if package is declared
    my str $pkg_alias = $program->{"package"};
    if ($pkg_alias ne "") {
        # Convert :: to __ for C identifier
        my str $prefix = "";
        my int $p = 0;
        my int $plen = length($pkg_alias);
        while ($p < $plen) {
            my str $ch = substr($pkg_alias, $p, 1);
            if ($ch eq ":") {
                $prefix = $prefix . "_";
            } else {
                $prefix = $prefix . $ch;
            }
            $p = $p + 1;
        }
        $prefix = $prefix . "__";

        emit($cg, "/* Qualified name aliases for package " . $pkg_alias . " */\n");
        $i = 0;
        while ($i < $program->{"function_count"}) {
            my scalar $fn = $funcs->[$i];
            my int $fn_type = $fn->{"type"};
            my str $name = sanitize_name($fn->{"name"});

            # Skip main and extern functions
            if ($name ne "main" && $fn_type != NODE_EXTERN_FUNC()) {
                my str $ret = type_to_c($fn->{"return_type"});
                my str $qname = sanitize_name($prefix . $fn->{"name"});

                # Generate: RetType QualifiedName(params) { return UnqualifiedName(params); }
                emit($cg, $ret . " " . $qname . "(");

                my scalar $params = $fn->{"params"};
                my int $j = 0;
                while ($j < $fn->{"param_count"}) {
                    if ($j > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$j];
                    my int $ptype = $param->{"param_type"};
                    my str $c_pname = escape_c_keyword($param->{"name"});
                    if ($ptype == TYPE_STRUCT()) {
                        emit($cg, $param->{"type_name"} . " *" . $c_pname);
                    } else {
                        emit($cg, type_to_c($ptype) . " " . $c_pname);
                    }
                    $j = $j + 1;
                }
                if ($fn->{"param_count"} == 0) {
                    emit($cg, "void");
                }
                emit($cg, ") { return " . $name . "(");

                $j = 0;
                while ($j < $fn->{"param_count"}) {
                    if ($j > 0) {
                        emit($cg, ", ");
                    }
                    emit($cg, escape_c_keyword($params->[$j]->{"name"}));
                    $j = $j + 1;
                }
                emit($cg, "); }\n");
            }
            $i = $i + 1;
        }
        emit($cg, "\n");
    }

    # Generate __strada_export_info function for shared library metadata
    # This allows import_lib to work without needing the .strada source file
    gen_export_info($cg, $program);
}

# Generate __strada_export_info function that returns metadata about exported functions
# Format: "func:name:return_type:param_count:param_types\n" for each function
func gen_export_info(scalar $cg, scalar $program) void {
    emit($cg, "\n/* Strada export metadata for import_lib */\n");
    emit($cg, "const char* __strada_export_info(void) {\n");
    emit($cg, "    return \"");

    my scalar $funcs = $program->{"functions"};
    my int $i = 0;
    my int $count = $program->{"function_count"};

    while ($i < $count) {
        my scalar $fn = $funcs->[$i];
        my str $name = $fn->{"name"};
        my int $fn_type = $fn->{"type"};

        # Skip main function and extern functions
        if ($name ne "main" && $fn_type != NODE_EXTERN_FUNC()) {
            my int $ret_type = $fn->{"return_type"};
            my int $param_count = $fn->{"param_count"};

            # func:name:return_type:param_count:param_types
            emit($cg, "func:" . sanitize_name($name) . ":" . type_to_export($ret_type) . ":" . $param_count . ":");

            my scalar $params = $fn->{"params"};
            my int $j = 0;
            while ($j < $param_count) {
                if ($j > 0) {
                    emit($cg, ",");
                }
                my scalar $param = $params->[$j];
                emit($cg, type_to_export($param->{"param_type"}));
                $j = $j + 1;
            }
            emit($cg, "\\n");
        }
        $i = $i + 1;
    }

    emit($cg, "\";\n");
    emit($cg, "}\n");

    # Also generate version info if specified
    gen_version_info($cg, $program);
}

# Generate __strada_version function that returns the module version
func gen_version_info(scalar $cg, scalar $program) void {
    my str $version = "";
    if ($program->{"version"} ne "") {
        $version = $program->{"version"};
    }

    emit($cg, "\n/* Strada module version */\n");
    emit($cg, "const char* __strada_version(void) {\n");
    emit($cg, "    return \"" . $version . "\";\n");
    emit($cg, "}\n");
}

# Convert type constant to export string
func type_to_export(int $type) str {
    if ($type == TYPE_INT()) { return "int"; }
    if ($type == TYPE_NUM()) { return "num"; }
    if ($type == TYPE_STR()) { return "str"; }
    if ($type == TYPE_ARRAY()) { return "array"; }
    if ($type == TYPE_HASH()) { return "hash"; }
    if ($type == TYPE_SCALAR()) { return "scalar"; }
    if ($type == TYPE_VOID()) { return "void"; }
    return "scalar";
}

# Generate extern function with body
func gen_extern_function(scalar $cg, scalar $fn) void {
    my str $ret_type = type_to_c_raw($fn->{"return_type"});
    my str $name = sanitize_name($fn->{"name"});

    emit($cg, $ret_type . " " . $name . "(");

    my scalar $params = $fn->{"params"};
    my int $i = 0;
    while ($i < $fn->{"param_count"}) {
        if ($i > 0) {
            emit($cg, ", ");
        }
        my scalar $param = $params->[$i];
        emit($cg, type_to_c_raw($param->{"param_type"}) . " " . escape_c_keyword($param->{"name"}));
        $i = $i + 1;
    }

    if ($fn->{"param_count"} == 0) {
        emit($cg, "void");
    }

    emit($cg, ") ");
    $cg->{"in_extern"} = 1;  # Enable raw C code generation
    # Track extern function parameter types for string interpolation conversion
    # Use escaped names to match variable references
    my hash %extern_params = ();
    my int $p = 0;
    while ($p < $fn->{"param_count"}) {
        my scalar $param = $params->[$p];
        my str $c_pname = escape_c_keyword($param->{"name"});
        $extern_params{$c_pname} = $param->{"param_type"};
        $p = $p + 1;
    }
    $cg->{"extern_params"} = \%extern_params;
    gen_block($cg, $fn->{"body"});
    $cg->{"in_extern"} = 0;  # Disable raw C code generation
    $cg->{"extern_params"} = {};
    emit($cg, "\n\n");
}

# Generate extern function declaration
func gen_extern_decl(scalar $cg, scalar $fn) void {
    my str $ret_type = type_to_c_raw($fn->{"return_type"});
    emit($cg, $ret_type . " " . sanitize_name($fn->{"name"}) . "(");

    my scalar $params = $fn->{"params"};
    my int $i = 0;
    while ($i < $fn->{"param_count"}) {
        if ($i > 0) {
            emit($cg, ", ");
        }
        my scalar $param = $params->[$i];
        emit($cg, type_to_c_raw($param->{"param_type"}) . " " . escape_c_keyword($param->{"name"}));
        $i = $i + 1;
    }

    if ($fn->{"param_count"} == 0) {
        emit($cg, "void");
    }
    
    emit($cg, ");\n");
}

# Convert type to raw C type (for extern functions)
func type_to_c_raw(int $type) str {
    if ($type == TYPE_INT()) { return "int"; }
    if ($type == TYPE_NUM()) { return "double"; }
    if ($type == TYPE_STR()) { return "char*"; }
    if ($type == TYPE_VOID()) { return "void"; }
    # Explicit sized types
    if ($type == TYPE_INT32()) { return "int32_t"; }
    if ($type == TYPE_INT64()) { return "int64_t"; }
    if ($type == TYPE_FLOAT32()) { return "float"; }
    if ($type == TYPE_FLOAT64()) { return "double"; }
    return "void*";
}

# ============================================================
# Main Entry Point
# ============================================================

func generate(scalar $ast, str $filename, int $debug_info, int $enable_profiling) str {
    my scalar $cg = codegen_new($filename, $debug_info, $enable_profiling);
    gen_program($cg, $ast);
    return get_output($cg);  # Join array into final string
}
/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# Main.strada - Entry point for self-hosting Strada compiler
# This is the main compiler executable

func compile(str $source, str $filename, int $debug_info, int $show_timing, int $show_warnings, int $enable_profiling, scalar $lib_paths, scalar $lib_paths_low) str {
    my num $t0 = 0.0;
    my num $t1 = 0.0;

    # Tokenize
    $t0 = sys::hires_time();
    my scalar $tokens = lex_tokenize($source);
    $t1 = sys::hires_time();
    if ($show_timing == 1) {
        say("  Lexer:    " . ($t1 - $t0) . " seconds");
    }

    # Parse (with optional library paths from -L and -LL flags)
    $t0 = sys::hires_time();
    my scalar $ast = parse_with_lib_paths($tokens, $filename, $lib_paths, $lib_paths_low);
    $t1 = sys::hires_time();
    if ($show_timing == 1) {
        say("  Parser:   " . ($t1 - $t0) . " seconds");
    }

    # Semantic analysis (validates symbols, types, etc.)
    $t0 = sys::hires_time();
    semantic_analyze($ast, $show_warnings);
    $t1 = sys::hires_time();
    if ($show_timing == 1) {
        say("  Semantic: " . ($t1 - $t0) . " seconds");
    }

    # Generate code (pass debug flag for #line directives, profiling flag)
    $t0 = sys::hires_time();
    my str $code = generate($ast, $filename, $debug_info, $enable_profiling);
    $t1 = sys::hires_time();
    if ($show_timing == 1) {
        say("  CodeGen:  " . ($t1 - $t0) . " seconds");
    }

    return $code;
}

func print_usage() void {
    say("Strada Compiler v1.0 (Self-Hosting)");
    say("Usage: stradac [options] <input.strada> <output.c>");
    say("");
    say("Options:");
    say("  -L <path>       Add library search path (high priority, searched first)");
    say("  -LL <path>      Add library search path (low priority, searched last)");
    say("  -g, --debug     Emit #line directives for source-level debugging");
    say("  -p, --profile   Enable function profiling (timing and call counts)");
    say("  -t, --timing    Show compilation phase timing");
    say("  -w, --warnings  Show warnings (unused variables, etc.)");
    say("  -h, --help      Show this help message");
    say("");
    say("The self-hosting Strada compiler, written in Strada.");
}

func main() int {
    my int $arg_count = size(@ARGV);

    # Parse command-line arguments
    my int $debug_info = 0;
    my int $show_timing = 0;
    my int $show_warnings = 0;
    my int $enable_profiling = 0;
    my str $input_file = "";
    my str $output_file = "";
    my array @lib_paths = ();
    my array @lib_paths_low = ();
    my int $i = 1;

    while ($i < $arg_count) {
        my str $arg = @ARGV[$i];

        if ($arg eq "-g" || $arg eq "--debug") {
            $debug_info = 1;
        } elsif ($arg eq "-p" || $arg eq "--profile") {
            $enable_profiling = 1;
        } elsif ($arg eq "-t" || $arg eq "--timing") {
            $show_timing = 1;
        } elsif ($arg eq "-w" || $arg eq "--warnings") {
            $show_warnings = 1;
        } elsif ($arg eq "-LL") {
            # -LL <path> - add low-priority library search path
            $i = $i + 1;
            if ($i < $arg_count) {
                push(@lib_paths_low, @ARGV[$i]);
            } else {
                say("Error: -LL requires a path argument");
                return 1;
            }
        } elsif (substr($arg, 0, 3) eq "-LL") {
            # -LL<path> (no space) - add low-priority library search path
            my str $path = substr($arg, 3, length($arg) - 3);
            push(@lib_paths_low, $path);
        } elsif ($arg eq "-L") {
            # -L <path> - add library search path
            $i = $i + 1;
            if ($i < $arg_count) {
                push(@lib_paths, @ARGV[$i]);
            } else {
                say("Error: -L requires a path argument");
                return 1;
            }
        } elsif (substr($arg, 0, 2) eq "-L") {
            # -L<path> (no space) - add library search path
            my str $path = substr($arg, 2, length($arg) - 2);
            push(@lib_paths, $path);
        } elsif ($arg eq "-h" || $arg eq "--help") {
            print_usage();
            return 0;
        } elsif (substr($arg, 0, 1) eq "-") {
            say("Unknown option: " . $arg);
            print_usage();
            return 1;
        } elsif (length($input_file) == 0) {
            $input_file = $arg;
        } elsif (length($output_file) == 0) {
            $output_file = $arg;
        }

        $i = $i + 1;
    }

    # Check required arguments
    if (length($input_file) == 0 || length($output_file) == 0) {
        print_usage();
        return 1;
    }

    say("Strada Compiler (Self-Hosting)");
    if ($debug_info == 1) {
        say("Debug mode: emitting #line directives");
    }
    if ($enable_profiling == 1) {
        say("Profiling mode: instrumenting functions for timing");
    }
    say("Compiling: " . $input_file . " -> " . $output_file);

    # Read source file
    my str $source = slurp($input_file);

    # Compile (pass lib paths)
    my str $code = compile($source, $input_file, $debug_info, $show_timing, $show_warnings, $enable_profiling, \@lib_paths, \@lib_paths_low);

    # Write output
    spew($output_file, $code);

    say("Success! Generated " . $output_file);

    return 0;
}
