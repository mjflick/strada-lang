/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# CodeGen.strada - C Code Generator for self-hosting Strada compiler
# Transforms AST into C source code

# ============================================================
# Code Generator State
# ============================================================

# Sanitize function names for C (replace :: with _)
func sanitize_name(str $name) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($name);
    while ($i < $len) {
        my str $ch = substr($name, $i, 1);
        if ($ch eq ":") {
            # Check for :: sequence and replace with single _
            if ($i + 1 < $len && substr($name, $i + 1, 1) eq ":") {
                $result = $result . "_";
                $i = $i + 1;  # Skip the second colon
            } else {
                $result = $result . "_";
            }
        } else {
            $result = $result . $ch;
        }
        $i = $i + 1;
    }
    return $result;
}

func codegen_new(str $filename, int $debug_info, int $enable_profiling) scalar {
    my hash %cg = ();
    # StringBuilder for O(1) amortized append (no O(n^2) string concat)
    $cg{"output_sb"} = sb_new();
    $cg{"preamble_content"} = "";  # Saved preamble when doing multi-phase
    $cg{"funcs_content"} = "";     # Saved funcs when doing multi-phase
    $cg{"oop_fwd_decls"} = "";     # OOP init forward declarations (generated after methods tracked)
    $cg{"indent"} = 0;
    $cg{"debug_info"} = $debug_info;  # Emit #line directives for debugging
    $cg{"enable_profiling"} = $enable_profiling;  # Emit function profiling code
    $cg{"last_line"} = 0;  # Track last emitted line to avoid duplicates
    $cg{"functions"} = {};  # Map function name -> function info
    $cg{"in_extern"} = 0;   # Track if we're inside an extern function
    $cg{"in_main"} = 0;     # Track if we're inside main function
    $cg{"package"} = "";    # Current package name
    $cg{"filename"} = $filename;  # Source file name for __FILE__
    $cg{"map_counter"} = 0;     # Counter for unique map variable names
    $cg{"sort_counter"} = 0;    # Counter for unique sort variable names
    $cg{"grep_counter"} = 0;    # Counter for unique grep variable names
    $cg{"foreach_counter"} = 0; # Counter for unique foreach variable names
    $cg{"in_map_block"} = 0;  # Track if inside map block (for $_)
    $cg{"in_sort_block"} = 0; # Track if inside sort block (for $a, $b)
    $cg{"in_grep_block"} = 0; # Track if inside grep block (for $_)
    $cg{"struct_vars"} = {};  # Map variable name -> struct type name
    $cg{"struct_defs"} = {};  # Map struct name -> struct definition with field info
    $cg{"anon_func_counter"} = 0;  # Counter for unique anonymous function names
    $cg{"anon_func_decls"} = "";   # Forward declarations for anonymous functions
    $cg{"anon_func_defs"} = "";    # Function definitions for anonymous functions
    $cg{"in_anon_func"} = 0;       # Track if inside anonymous function
    $cg{"anon_param_str"} = "";    # Comma-separated param names
    $cg{"anon_local_str"} = "";    # Comma-separated local names
    $cg{"anon_capture_str"} = "";  # Comma-separated capture names
    $cg{"anon_capture_count"} = 0; # Number of captures
    $cg{"current_func_name"} = ""; # Current function name for profiling
    $cg{"global_count"} = 0;       # Number of global variables
    my array @empty_globals = ();
    $cg{"globals"} = \@empty_globals;  # Array of global variable declarations
    $cg{"switch_counter"} = 0;     # Counter for unique switch variable names
    # OOP method registration - per-package tracking
    my hash %empty_pkg_methods = ();
    $cg{"pkg_methods"} = \%empty_pkg_methods;  # Hash: package -> array of method info
    my array @empty_pkg_list = ();
    $cg{"pkg_list"} = \@empty_pkg_list;        # Array of package names (to avoid keys())
    $cg{"pkg_count"} = 0;                      # Number of packages
    $cg{"pkg_seen"} = "|";                     # String of seen package names (for fast lookup)
    $cg{"method_wrappers"} = "";   # Generated wrapper functions
    # Scope tracking for memory management (using string-encoded var lists for bootstrap compat)
    # Each scope is stored as "var1,var2,var3" string (bootstrap doesn't support scalar(@arr))
    my array @scope_vars = ();   # Array of scope strings
    my array @scope_counts = (); # Parallel array of counts
    $cg{"scope_vars"} = \@scope_vars;
    $cg{"scope_counts"} = \@scope_counts;
    $cg{"scope_depth"} = 0;
    $cg{"cleanup_enabled"} = 1;  # Enable scope-based memory cleanup
    $cg{"returns_struct"} = 0;   # Track if current function returns struct
    $cg{"try_depth"} = 0;        # Track nesting depth in try blocks (for proper cleanup on return)
    return \%cg;
}

# Push a new scope onto the scope stack
func scope_push(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my int $depth = $cg->{"scope_depth"};
    push($vars, "");  # Empty scope
    push($counts, 0);
    $cg->{"scope_depth"} = $depth + 1;
}

# Track a variable in the current scope
func scope_track_var(scalar $cg, str $name) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    if ($depth == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my str $current = $vars->[$depth - 1];
    my int $count = $counts->[$depth - 1];
    if ($count == 0) {
        $vars->[$depth - 1] = $name;
    } else {
        $vars->[$depth - 1] = $current . "," . $name;
    }
    $counts->[$depth - 1] = $count + 1;
}

# Emit cleanup for current scope and pop it
func scope_pop(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    if ($depth == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my str $scope_str = $vars->[$depth - 1];
    my int $count = $counts->[$depth - 1];

    emit_scope_decref($cg, $scope_str, $count);

    pop($vars);
    pop($counts);
    $cg->{"scope_depth"} = $depth - 1;
}

# Check if a variable name is in a comma-separated string
func is_var_in_list(str $var, str $list) int {
    if (length($list) == 0) { return 0; }
    my int $pos = 0;
    my int $len = length($list);
    my str $cur = "";
    while ($pos <= $len) {
        if ($pos == $len) {
            if ($cur eq $var) { return 1; }
            $pos = $pos + 1;
        } else {
            my str $ch = substr($list, $pos, 1);
            if ($ch eq ",") {
                if ($cur eq $var) { return 1; }
                $cur = "";
            } else {
                $cur = $cur . $ch;
            }
            $pos = $pos + 1;
        }
    }
    return 0;
}

# Helper to emit decref for all vars in a scope string
func emit_scope_decref(scalar $cg, str $scope_str, int $count) void {
    if ($count == 0 || length($scope_str) == 0) {
        return;
    }
    # Get capture list to skip captured variables in closures
    my int $in_anon = $cg->{"in_anon_func"};
    my str $capture_str = $cg->{"anon_capture_str"};

    my int $pos = 0;
    my int $len = length($scope_str);
    my str $var_name = "";
    while ($pos <= $len) {
        if ($pos == $len) {
            if (length($var_name) > 0) {
                # Skip captured variables - they're accessed via __captures, not local vars
                if ($in_anon == 0 || is_var_in_list($var_name, $capture_str) == 0) {
                    emit_indent($cg);
                    emit($cg, "strada_decref(" . $var_name . ");\n");
                }
            }
            $pos = $pos + 1;
        } else {
            my str $ch = substr($scope_str, $pos, 1);
            if ($ch eq ",") {
                if (length($var_name) > 0) {
                    # Skip captured variables
                    if ($in_anon == 0 || is_var_in_list($var_name, $capture_str) == 0) {
                        emit_indent($cg);
                        emit($cg, "strada_decref(" . $var_name . ");\n");
                    }
                }
                $var_name = "";
            } else {
                $var_name = $var_name . $ch;
            }
            $pos = $pos + 1;
        }
    }
}

# Emit cleanup for current scope without popping (for early returns)
func scope_emit_cleanup(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    if ($depth == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my str $scope_str = $vars->[$depth - 1];
    my int $count = $counts->[$depth - 1];
    emit_scope_decref($cg, $scope_str, $count);
}

# Emit cleanup for all scopes (for return statements)
func scope_emit_all_cleanup(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};

    # Emit cleanup from innermost to outermost scope
    my int $d = $depth;
    while ($d > 0) {
        my str $scope_str = $vars->[$d - 1];
        my int $count = $counts->[$d - 1];
        emit_scope_decref($cg, $scope_str, $count);
        $d = $d - 1;
    }
}

# Emit STRADA_TRY_POP() for each active try block (for early returns in try blocks)
func emit_try_cleanup(scalar $cg) void {
    my int $try_depth = $cg->{"try_depth"};
    while ($try_depth > 0) {
        emit_indent($cg);
        emit($cg, "STRADA_TRY_POP();\n");
        $try_depth = $try_depth - 1;
    }
}

# Register a function with its parameters for default arg handling
func codegen_register_function(scalar $cg, scalar $fn) void {
    my str $name = sanitize_name($fn->{"name"});
    my hash %info = ();
    $info{"param_count"} = $fn->{"param_count"};
    $info{"params"} = $fn->{"params"};
    $info{"return_type"} = $fn->{"return_type"};
    $cg->{"functions"}->{$name} = \%info;
}

# Helper to get arg from packed args array
func gen_oop_helper_decl() str {
    my str $code = "";
    $code = $code . "/* OOP method dispatch helper */\n";
    $code = $code . "static StradaValue* __strada_get_arg(StradaValue* args, int idx) {\n";
    $code = $code . "    if (!args || args->type != STRADA_ARRAY) return NULL;\n";
    $code = $code . "    if ((size_t)idx >= args->value.av->size) return NULL;\n";
    $code = $code . "    return args->value.av->elements[idx];\n";
    $code = $code . "}\n\n";
    return $code;
}

# Track a method for OOP registration (per-package)
func codegen_track_method(scalar $cg, scalar $fn, str $pkg) void {
    my str $name = sanitize_name($fn->{"name"});

    # Skip main, extern functions, and functions starting with underscore
    if ($name eq "main") { return; }
    if ($fn->{"type"} == NODE_EXTERN_FUNC()) { return; }
    if (substr($name, 0, 1) eq "_") { return; }

    # Methods must have at least one parameter (self)
    # Functions with 0 params are class init functions, not methods
    my int $param_count = $fn->{"param_count"};
    if ($param_count == 0) { return; }

    # Check if function name starts with package prefix (e.g., Cannoli_)
    my str $prefix = $pkg . "_";
    my int $prefix_len = length($prefix);
    if (length($name) <= $prefix_len) { return; }
    if (substr($name, 0, $prefix_len) ne $prefix) { return; }

    # Get method name without prefix
    my str $method = substr($name, $prefix_len, length($name) - $prefix_len);

    # Track method info
    my hash %minfo = ();
    $minfo{"func_name"} = $name;
    $minfo{"method_name"} = $method;
    $minfo{"param_count"} = $fn->{"param_count"};
    $minfo{"params"} = $fn->{"params"};
    $minfo{"return_type"} = $fn->{"return_type"};
    $minfo{"package"} = $pkg;

    # Get or create the methods info for this package
    # Use string index check instead of exists() for bootstrap compatibility
    my str $pkg_marker = "|" . $pkg . "|";
    my str $seen = $cg->{"pkg_seen"};
    my int $found_idx = index($seen, $pkg_marker);
    if ($found_idx < 0) {
        # New package - initialize it
        my hash %pkg_info = ();
        my array @new_arr = ();
        $pkg_info{"methods"} = \@new_arr;
        $pkg_info{"count"} = 0;
        my scalar $pkg_methods = $cg->{"pkg_methods"};
        $pkg_methods->{$pkg} = \%pkg_info;
        # Also track package name in the list
        my int $pkg_idx = $cg->{"pkg_count"};
        $cg->{"pkg_list"}->[$pkg_idx] = $pkg;
        $cg->{"pkg_count"} = $pkg_idx + 1;
        # Mark as seen
        $cg->{"pkg_seen"} = $seen . $pkg . "|";
    }
    my scalar $pkg_methods = $cg->{"pkg_methods"};
    my scalar $pkg_info = $pkg_methods->{$pkg};
    my int $idx = $pkg_info->{"count"};
    $pkg_info->{"methods"}->[$idx] = \%minfo;
    $pkg_info->{"count"} = $idx + 1;
}

# Generate method wrapper functions for a single package
# $pkg_info is a hash with "methods" array and "count" int
func gen_method_wrappers_for_pkg(str $pkg, scalar $pkg_info) str {
    my str $code = "";
    my int $method_count = $pkg_info->{"count"};
    my scalar $methods = $pkg_info->{"methods"};
    if ($method_count == 0) { return ""; }

    $code = $code . "/* OOP method wrappers for package " . $pkg . " */\n";

    my int $i = 0;
    while ($i < $method_count) {
        my scalar $m = $methods->[$i];
        my str $func_name = $m->{"func_name"};
        my int $param_count = $m->{"param_count"};
        my int $ret_type = $m->{"return_type"};
        my int $is_void = $ret_type == TYPE_VOID();

        # Generate wrapper: __wrap_FuncName(self, args) { ... }
        $code = $code . "static StradaValue* __wrap_" . $func_name . "(StradaValue* self, StradaValue* args) {\n";

        if ($param_count <= 1) {
            # 0 or 1 param (just self)
            $code = $code . "    (void)args;\n";
            if ($is_void == 1) {
                $code = $code . "    " . $func_name . "(self);\n";
                $code = $code . "    return strada_new_undef();\n";
            } else {
                $code = $code . "    return " . $func_name . "(self);\n";
            }
        } else {
            # Multiple params - unpack from args
            if ($is_void == 1) {
                $code = $code . "    " . $func_name . "(self";
            } else {
                $code = $code . "    return " . $func_name . "(self";
            }
            my int $j = 1;  # Skip self
            while ($j < $param_count) {
                my int $arg_idx = $j - 1;
                $code = $code . ", __strada_get_arg(args, " . $arg_idx . ")";
                $j = $j + 1;
            }
            $code = $code . ");\n";
            if ($is_void == 1) {
                $code = $code . "    return strada_new_undef();\n";
            }
        }

        $code = $code . "}\n\n";
        $i = $i + 1;
    }

    # Generate initialization function for this package
    $code = $code . "/* OOP method registration initializer */\n";
    $code = $code . "static int __" . $pkg . "_oop_initialized = 0;\n";
    $code = $code . "void __" . $pkg . "_oop_init(void) {\n";
    $code = $code . "    if (__" . $pkg . "_oop_initialized) return;\n";
    $code = $code . "    __" . $pkg . "_oop_initialized = 1;\n\n";

    $i = 0;
    while ($i < $method_count) {
        my scalar $m = $methods->[$i];
        my str $func_name = $m->{"func_name"};
        my str $method_name = $m->{"method_name"};

        $code = $code . "    strada_method_register(\"" . $pkg . "\", \"" . $method_name . "\", __wrap_" . $func_name . ");\n";
        $i = $i + 1;
    }

    $code = $code . "}\n\n";

    return $code;
}

# Generate method wrappers for ALL packages
func gen_all_method_wrappers(scalar $cg) str {
    my str $code = "";
    my int $num_pkgs = get_oop_pkg_count($cg);
    if ($num_pkgs == 0) { return ""; }

    my scalar $pkg_methods = $cg->{"pkg_methods"};
    my scalar $pkg_list = get_oop_packages($cg);

    # Add the helper function once
    $code = $code . gen_oop_helper_decl();

    # Generate wrappers for each package
    my int $i = 0;
    while ($i < $num_pkgs) {
        my str $pkg = $pkg_list->[$i];
        my scalar $pkg_info = $pkg_methods->{$pkg};
        $code = $code . gen_method_wrappers_for_pkg($pkg, $pkg_info);
        $i = $i + 1;
    }

    return $code;
}

# Get all packages that have registered methods
# Returns the pkg_list array reference (not a copy)
func get_oop_packages(scalar $cg) scalar {
    return $cg->{"pkg_list"};
}

# Get count of packages
func get_oop_pkg_count(scalar $cg) int {
    return $cg->{"pkg_count"};
}

# Check if an expression is clearly a scalar value (not an array or function call)
# Used to determine if we need to wrap it when assigning to an array variable
func is_scalar_expr(scalar $expr) int {
    my int $type = $expr->{"type"};

    # Scalar variables ($x)
    if ($type == NODE_VARIABLE()) {
        my str $sigil = $expr->{"sigil"};
        if ($sigil eq "$") {
            return 1;
        }
        return 0;
    }

    # Literal values
    if ($type == NODE_INT_LITERAL() || $type == NODE_NUM_LITERAL() || $type == NODE_STR_LITERAL()) {
        return 1;
    }

    # Unary operators on scalars
    if ($type == NODE_UNARY_OP()) {
        return 1;
    }

    # Binary operators produce scalars (arithmetic, comparison, etc.)
    if ($type == NODE_BINARY_OP()) {
        return 1;
    }

    # Ternary produces a scalar
    if ($type == NODE_TERNARY()) {
        return 1;
    }

    # Array/hash subscript returns a scalar
    if ($type == NODE_SUBSCRIPT() || $type == NODE_HASH_ACCESS()) {
        return 1;
    }

    # Field access returns a scalar
    if ($type == NODE_FIELD_ACCESS()) {
        return 1;
    }

    # Everything else (function calls, deref, etc.) - assume not scalar
    return 0;
}

func emit(scalar $cg, str $text) void {
    # O(1) amortized append using StringBuilder
    sb_append($cg->{"output_sb"}, $text);
}

# Emit #line directive for source-level debugging
# Format: #line <line_number> "<filename>"
func emit_line_directive(scalar $cg, int $line) void {
    if ($cg->{"debug_info"} == 0) {
        return;
    }
    if ($line <= 0) {
        return;
    }
    # Avoid emitting duplicate line directives
    if ($line == $cg->{"last_line"}) {
        return;
    }
    $cg->{"last_line"} = $line;

    my str $filename = $cg->{"filename"};
    emit($cg, "#line " . $line . " \"" . $filename . "\"\n");
}

# Emit #line directive before a statement (with indent)
func emit_line_for_stmt(scalar $cg, scalar $stmt) void {
    if ($cg->{"debug_info"} == 0) {
        return;
    }
    # stmt should always be defined when called from gen_statement
    my int $line = $stmt->{"line"};
    if ($line > 0) {
        emit_line_directive($cg, $line);
    }
}

# Get accumulated output as a single string
func get_output(scalar $cg) str {
    # Get the current output from StringBuilder
    my str $final = sb_to_string($cg->{"output_sb"});

    # Check if we used multi-phase generation
    my str $preamble = $cg->{"preamble_content"};
    if (length($preamble) > 0) {
        my str $funcs = $cg->{"funcs_content"};
        my str $anon_decls = $cg->{"anon_func_decls"};
        my str $oop_decls = $cg->{"oop_fwd_decls"};

        # Build result: preamble + oop_decls + anon_decls + funcs + final
        my str $result = $preamble;
        if (length($oop_decls) > 0) {
            $result = $result . $oop_decls;
        }
        if (length($anon_decls) > 0) {
            $result = $result . "/* Anonymous function forward declarations */\n";
            $result = $result . $anon_decls;
            $result = $result . "\n";
        }
        $result = $result . $funcs;
        $result = $result . $final;
        return $result;
    }

    return $final;
}

# Set output - for save/restore pattern in anonymous functions
func set_output(scalar $cg, str $text) void {
    sb_clear($cg->{"output_sb"});
    sb_append($cg->{"output_sb"}, $text);
}

func emit_line(scalar $cg, str $text) void {
    emit_indent($cg);
    emit($cg, $text . "\n");
}

func emit_indent(scalar $cg) void {
    my int $i = 0;
    while ($i < $cg->{"indent"}) {
        emit($cg, "    ");
        $i = $i + 1;
    }
}

func indent(scalar $cg) void {
    $cg->{"indent"} = $cg->{"indent"} + 1;
}

func dedent(scalar $cg) void {
    $cg->{"indent"} = $cg->{"indent"} - 1;
}

# Check if name is in comma-separated string (workaround for bootstrap limitation)
func str_contains_name(str $list, str $name) int {
    my str $search = "," . $name . ",";
    my str $padded = "," . $list . ",";
    my int $pos = index($padded, $search);
    if ($pos >= 0) { return 1; }
    return 0;
}

# Get index of name in comma-separated capture string
func get_capture_index(str $list, str $name) int {
    if ($list eq "") { return -1; }
    my int $idx = 0;
    my int $start = 0;
    my int $len = length($list);
    my int $i = 0;
    while ($i <= $len) {
        my str $ch = "";
        if ($i < $len) { $ch = substr($list, $i, 1); }
        if ($ch eq "," || $i == $len) {
            my str $part = substr($list, $start, $i - $start);
            if ($part eq $name) { return $idx; }
            $idx = $idx + 1;
            $start = $i + 1;
        }
        $i = $i + 1;
    }
    return -1;
}

# Generate code for regex pattern with variable interpolation
# Pattern like "$foo" or "^$pattern$" gets converted to runtime string building
func gen_regex_interpolated_pattern(scalar $cg, str $pattern) void {
    # Parse pattern into parts (literals and variables)
    # We manually track the count since bootstrap doesn't support scalar(@array)
    my array @parts = ();
    my int $num_parts = 0;
    my int $len = length($pattern);
    my int $i = 0;
    my str $literal = "";

    while ($i < $len) {
        my str $ch = substr($pattern, $i, 1);

        if ($ch eq "$") {
            # Save any accumulated literal
            if (length($literal) > 0) {
                my hash %part = ();
                $part{"type"} = "lit";
                $part{"value"} = $literal;
                push(@parts, \%part);
                $num_parts = $num_parts + 1;
                $literal = "";
            }

            # Parse variable name
            $i = $i + 1;
            my str $varname = "";
            while ($i < $len) {
                my str $vch = substr($pattern, $i, 1);
                if ($vch eq "_" || ($vch ge "a" && $vch le "z") || ($vch ge "A" && $vch le "Z") || ($vch ge "0" && $vch le "9")) {
                    $varname = $varname . $vch;
                    $i = $i + 1;
                } else {
                    last;
                }
            }

            if (length($varname) > 0) {
                my hash %part = ();
                $part{"type"} = "var";
                $part{"value"} = $varname;
                push(@parts, \%part);
                $num_parts = $num_parts + 1;
            }
        } else {
            $literal = $literal . $ch;
            $i = $i + 1;
        }
    }

    # Save any remaining literal
    if (length($literal) > 0) {
        my hash %part = ();
        $part{"type"} = "lit";
        $part{"value"} = $literal;
        push(@parts, \%part);
        $num_parts = $num_parts + 1;
    }

    # Generate concatenation code
    if ($num_parts == 0) {
        emit($cg, "strada_new_str(\"\")");
        return;
    }
    if ($num_parts == 1) {
        my scalar $p = @parts[0];
        if ($p->{"type"} eq "var") {
            emit($cg, $p->{"value"});
        } else {
            emit($cg, "strada_new_str(\"");
            emit_escaped_string($cg, $p->{"value"});
            emit($cg, "\")");
        }
        return;
    }

    # Multiple parts - build with strada_concat_sv chain (fast, no copies)
    # strada_concat_sv(a, strada_concat_sv(b, c))
    my int $pi = 0;
    while ($pi < $num_parts - 1) {
        emit($cg, "strada_concat_sv(");
        $pi = $pi + 1;
    }

    # Emit first part
    my scalar $first_p = @parts[0];
    if ($first_p->{"type"} eq "var") {
        emit($cg, $first_p->{"value"});
    } else {
        emit($cg, "strada_new_str(\"");
        emit_escaped_string($cg, $first_p->{"value"});
        emit($cg, "\")");
    }
    emit($cg, ", ");

    # Emit remaining parts
    $pi = 1;
    while ($pi < $num_parts) {
        my scalar $p = @parts[$pi];
        if ($p->{"type"} eq "var") {
            emit($cg, $p->{"value"});
        } else {
            emit($cg, "strada_new_str(\"");
            emit_escaped_string($cg, $p->{"value"});
            emit($cg, "\")");
        }
        emit($cg, ")");
        if ($pi < $num_parts - 1) {
            emit($cg, ", ");
        }
        $pi = $pi + 1;
    }
}

# Helper to emit an escaped C string
func emit_escaped_string(scalar $cg, str $s) void {
    my int $i = 0;
    my int $len = length($s);
    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        if ($ch eq "\\") {
            emit($cg, "\\\\");
        } elsif ($ch eq "\"") {
            emit($cg, "\\\"");
        } elsif ($ch eq "\n") {
            emit($cg, "\\n");
        } elsif ($ch eq "\t") {
            emit($cg, "\\t");
        } else {
            emit($cg, $ch);
        }
        $i = $i + 1;
    }
}

# ============================================================
# Type Conversion
# ============================================================

func type_to_c(int $type) str {
    if ($type == TYPE_INT()) { return "StradaValue*"; }
    if ($type == TYPE_NUM()) { return "StradaValue*"; }
    if ($type == TYPE_STR()) { return "StradaValue*"; }
    if ($type == TYPE_ARRAY()) { return "StradaValue*"; }
    if ($type == TYPE_HASH()) { return "StradaValue*"; }
    if ($type == TYPE_SCALAR()) { return "StradaValue*"; }
    if ($type == TYPE_VOID()) { return "void"; }
    if ($type == TYPE_STRUCT()) { return "void*"; }  # Struct pointer
    if ($type == TYPE_FUNCPTR()) { return "void*"; }  # Function pointer
    return "StradaValue*";
}

# ============================================================
# Expression Code Generation
# ============================================================

# Helper: emit a numeric operand efficiently
# For literals, emit the value directly; otherwise use strada_to_num()
func emit_num_operand(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    if ($type == NODE_INT_LITERAL()) {
        my str $val = $expr->{"value"};
        # Check if it's a hex, octal, or binary literal
        # Also check for leading zeros (octal in C)
        my str $first = substr($val, 0, 1);
        my str $second = "";
        if (length($val) > 1) {
            $second = substr($val, 1, 1);
        }
        if (substr($val, 0, 2) eq "0x" || substr($val, 0, 2) eq "0X" ||
            substr($val, 0, 2) eq "0o" || substr($val, 0, 2) eq "0O" ||
            substr($val, 0, 2) eq "0b" || substr($val, 0, 2) eq "0B") {
            # Cast hex/octal/binary to double
            emit($cg, "(double)(" . $val . ")");
        } elsif ($first eq "0" && length($val) > 1 && $second ne ".") {
            # Leading zero means octal in C - must cast to preserve value
            emit($cg, "(double)(" . $val . ")");
        } else {
            emit($cg, $val . ".0");
        }
    } elsif ($type == NODE_NUM_LITERAL()) {
        emit($cg, $expr->{"value"});
    } else {
        emit($cg, "strada_to_num(");
        gen_expression($cg, $expr);
        emit($cg, ")");
    }
}

# Helper: emit an integer operand efficiently
# For literals, emit the value directly; otherwise use strada_to_int()
func emit_int_operand(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    if ($type == NODE_INT_LITERAL()) {
        emit($cg, $expr->{"value"});
    } elsif ($type == NODE_NUM_LITERAL()) {
        emit($cg, "(int64_t)" . $expr->{"value"});
    } else {
        emit($cg, "strada_to_int(");
        gen_expression($cg, $expr);
        emit($cg, ")");
    }
}

# Helper: emit a bool operand efficiently
# For literals, emit the value directly; otherwise use strada_to_bool()
func emit_bool_operand(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    if ($type == NODE_INT_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
    } elsif ($type == NODE_NUM_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0" || $val eq "0.0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
    } else {
        emit($cg, "strada_to_bool(");
        gen_expression($cg, $expr);
        emit($cg, ")");
    }
}

# Helper: emit a condition as raw C boolean (avoids strada_new_int allocation)
# Used for while/for/if conditions to prevent memory leaks
func emit_condition(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};

    # Literals: emit 0 or 1 directly
    if ($type == NODE_INT_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
        return;
    }
    if ($type == NODE_NUM_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0" || $val eq "0.0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
        return;
    }

    # Binary operators: handle comparisons and logical ops without allocation
    if ($type == NODE_BINARY_OP()) {
        my str $op = $expr->{"op"};

        # Comparison operators: emit raw C comparison
        if ($op eq "==" || $op eq "!=" || $op eq "<" || $op eq ">" || $op eq "<=" || $op eq ">=") {
            emit($cg, "(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " " . $op . " ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
            return;
        }

        # Logical AND: recurse on both sides
        if ($op eq "&&") {
            emit($cg, "(");
            emit_condition($cg, $expr->{"left"});
            emit($cg, " && ");
            emit_condition($cg, $expr->{"right"});
            emit($cg, ")");
            return;
        }

        # Logical OR: recurse on both sides
        if ($op eq "||") {
            emit($cg, "(");
            emit_condition($cg, $expr->{"left"});
            emit($cg, " || ");
            emit_condition($cg, $expr->{"right"});
            emit($cg, ")");
            return;
        }
    }

    # Unary NOT: recurse
    if ($type == NODE_UNARY_OP()) {
        my str $op = $expr->{"op"};
        if ($op eq "!") {
            emit($cg, "!(");
            emit_condition($cg, $expr->{"operand"});
            emit($cg, ")");
            return;
        }
    }

    # Fallback: use strada_to_bool on the expression
    emit($cg, "strada_to_bool(");
    gen_expression($cg, $expr);
    emit($cg, ")");
}

# Helper: check if expression is a simple variable (doesn't need cleanup)
func is_variable_expr(scalar $expr) int {
    my int $type = $expr->{"type"};
    if ($type == NODE_VARIABLE()) {
        return 1;
    }
    return 0;
}

# Helper: check if expression produces an owned StradaValue* that needs cleanup
# Returns 1 for expressions we KNOW produce owned pointers (literals, concat, arithmetic)
# Returns 0 for unknown types (function calls, etc.) to be safe
func needs_temp_cleanup(scalar $expr) int {
    my int $type = $expr->{"type"};

    # Literals always create owned StradaValue*
    if ($type == NODE_INT_LITERAL() || $type == NODE_NUM_LITERAL() || $type == NODE_STR_LITERAL()) {
        return 1;
    }

    # Binary ops that produce StradaValue*
    if ($type == NODE_BINARY_OP()) {
        my str $op = $expr->{"op"};
        # These ops produce owned StradaValue*
        if ($op eq "." || $op eq "+" || $op eq "-" || $op eq "*" || $op eq "/" ||
            $op eq "%" || $op eq "**" || $op eq "==" || $op eq "!=" ||
            $op eq "<" || $op eq ">" || $op eq "<=" || $op eq ">=" ||
            $op eq "&&" || $op eq "||" || $op eq "&" || $op eq "|" ||
            $op eq "^" || $op eq "<<" || $op eq ">>") {
            return 1;
        }
    }

    # Unary ops that produce StradaValue*
    if ($type == NODE_UNARY_OP()) {
        my str $op = $expr->{"op"};
        if ($op eq "!" || $op eq "-") {
            return 1;
        }
    }

    # Array/hash constructors
    if ($type == NODE_ANON_ARRAY() || $type == NODE_ANON_HASH()) {
        return 1;
    }

    # Reference expressions (\$var, \@arr, \%hash) create owned refs
    if ($type == NODE_REF()) {
        return 1;
    }

    # Ternary produces owned StradaValue* (from either branch)
    if ($type == NODE_TERNARY()) {
        return 1;
    }

    # Variables don't need cleanup (already tracked)
    if ($type == NODE_VARIABLE()) {
        return 0;
    }

    # Function calls: be conservative, don't assume needs cleanup
    # (some functions return const char*, not StradaValue*)
    if ($type == NODE_CALL()) {
        return 0;
    }

    # Default: don't cleanup (be conservative)
    return 0;
}

# Helper: check if return value needs incref before returning
# Returns 1 for variables and borrowed references (need incref to survive scope cleanup)
# Returns 0 for new/owned values (already have correct refcount)
func return_needs_incref(scalar $expr) int {
    my int $type = $expr->{"type"};

    # Variables need incref because scope cleanup will decref them
    if ($type == NODE_VARIABLE()) {
        return 1;
    }

    # Hash and array access return borrowed references - need incref
    if ($type == NODE_HASH_ACCESS() || $type == NODE_SUBSCRIPT()) {
        return 1;
    }

    # Deref expressions returning borrowed refs
    if ($type == NODE_DEREF_HASH() || $type == NODE_DEREF_ARRAY()) {
        return 1;
    }

    # Method calls return owned values
    if ($type == NODE_METHOD_CALL()) {
        return 0;
    }

    # Function calls - most return owned values, but bless() returns its argument
    if ($type == NODE_CALL()) {
        my str $name = $expr->{"name"};
        # bless() returns its first argument, so check if THAT needs incref
        if ($name eq "bless") {
            my scalar $args = $expr->{"args"};
            if ($args && $expr->{"arg_count"} > 0) {
                return return_needs_incref($args->[0]);
            }
            return 0;
        }
        return 0;
    }

    # Literals create owned values
    if ($type == NODE_INT_LITERAL() || $type == NODE_NUM_LITERAL() || $type == NODE_STR_LITERAL()) {
        return 0;
    }

    # Binary ops create owned values
    if ($type == NODE_BINARY_OP()) {
        return 0;
    }

    # Unary ops create owned values
    if ($type == NODE_UNARY_OP()) {
        return 0;
    }

    # Reference/anon constructors create owned values
    if ($type == NODE_REF() || $type == NODE_ANON_ARRAY() || $type == NODE_ANON_HASH()) {
        return 0;
    }

    # Ternary - check both branches (if either needs incref, do incref to be safe)
    if ($type == NODE_TERNARY()) {
        my int $true_needs = return_needs_incref($expr->{"true_expr"});
        my int $false_needs = return_needs_incref($expr->{"false_expr"});
        if ($true_needs == 1 || $false_needs == 1) {
            return 1;
        }
        return 0;
    }

    # Default: incref to be safe (conservative)
    return 1;
}

# Helper: generate a function call with temporary argument cleanup
# c_func_name: the C function to call (e.g., "strada_glob")
# args: array of argument expressions
# arg_count: number of arguments
# Returns nothing, emits code directly
func gen_call_with_arg_cleanup(scalar $cg, str $c_func_name, scalar $args, int $arg_count) void {
    if ($cg->{"cleanup_enabled"} == 0 || $arg_count == 0) {
        # No cleanup needed - emit simple call
        emit($cg, $c_func_name . "(");
        my int $i = 0;
        while ($i < $arg_count) {
            if ($i > 0) {
                emit($cg, ", ");
            }
            gen_expression($cg, $args->[$i]);
            $i = $i + 1;
        }
        emit($cg, ")");
        return;
    }

    # Check which arguments are temporaries (up to 8 args supported)
    my int $temp0 = 0;
    my int $temp1 = 0;
    my int $temp2 = 0;
    my int $temp3 = 0;
    my int $has_temps = 0;

    if ($arg_count > 0 && needs_temp_cleanup($args->[0]) == 1) {
        $temp0 = 1;
        $has_temps = 1;
    }
    if ($arg_count > 1 && needs_temp_cleanup($args->[1]) == 1) {
        $temp1 = 1;
        $has_temps = 1;
    }
    if ($arg_count > 2 && needs_temp_cleanup($args->[2]) == 1) {
        $temp2 = 1;
        $has_temps = 1;
    }
    if ($arg_count > 3 && needs_temp_cleanup($args->[3]) == 1) {
        $temp3 = 1;
        $has_temps = 1;
    }

    if ($has_temps == 0) {
        # No temporaries - emit simple call
        emit($cg, $c_func_name . "(");
        my int $i = 0;
        while ($i < $arg_count) {
            if ($i > 0) {
                emit($cg, ", ");
            }
            gen_expression($cg, $args->[$i]);
            $i = $i + 1;
        }
        emit($cg, ")");
        return;
    }

    # Has temporaries - wrap with cleanup
    emit($cg, "({ ");

    # Declare temp variables for each temporary argument
    if ($temp0 == 1) {
        emit($cg, "StradaValue *__call_arg0 = ");
        gen_expression($cg, $args->[0]);
        emit($cg, "; ");
    }
    if ($temp1 == 1) {
        emit($cg, "StradaValue *__call_arg1 = ");
        gen_expression($cg, $args->[1]);
        emit($cg, "; ");
    }
    if ($temp2 == 1) {
        emit($cg, "StradaValue *__call_arg2 = ");
        gen_expression($cg, $args->[2]);
        emit($cg, "; ");
    }
    if ($temp3 == 1) {
        emit($cg, "StradaValue *__call_arg3 = ");
        gen_expression($cg, $args->[3]);
        emit($cg, "; ");
    }

    # Emit the call with result capture
    emit($cg, "StradaValue *__call_result = " . $c_func_name . "(");
    my int $i = 0;
    while ($i < $arg_count) {
        if ($i > 0) {
            emit($cg, ", ");
        }
        if ($i == 0 && $temp0 == 1) {
            emit($cg, "__call_arg0");
        } elsif ($i == 1 && $temp1 == 1) {
            emit($cg, "__call_arg1");
        } elsif ($i == 2 && $temp2 == 1) {
            emit($cg, "__call_arg2");
        } elsif ($i == 3 && $temp3 == 1) {
            emit($cg, "__call_arg3");
        } else {
            gen_expression($cg, $args->[$i]);
        }
        $i = $i + 1;
    }
    emit($cg, "); ");

    # Decref all temp arguments
    if ($temp0 == 1) {
        emit($cg, "strada_decref(__call_arg0); ");
    }
    if ($temp1 == 1) {
        emit($cg, "strada_decref(__call_arg1); ");
    }
    if ($temp2 == 1) {
        emit($cg, "strada_decref(__call_arg2); ");
    }
    if ($temp3 == 1) {
        emit($cg, "strada_decref(__call_arg3); ");
    }

    # Return the result
    emit($cg, "__call_result; })");
}

func gen_expression(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    my int $in_extern = $cg->{"in_extern"};

    # Integer literal
    if ($type == NODE_INT_LITERAL()) {
        if ($in_extern) {
            emit($cg, $expr->{"value"});
        } else {
            emit($cg, "strada_new_int(" . $expr->{"value"} . ")");
        }
        return;
    }

    # Number literal
    if ($type == NODE_NUM_LITERAL()) {
        if ($in_extern) {
            emit($cg, $expr->{"value"});
        } else {
            emit($cg, "strada_new_num(" . $expr->{"value"} . ")");
        }
        return;
    }
    
    # String literal - use byte-level operations for proper UTF-8 handling
    if ($type == NODE_STR_LITERAL()) {
        emit($cg, "strada_new_str(\"");
        my str $val = $expr->{"value"};
        my int $i = 0;
        my int $len = bytes($val);
        while ($i < $len) {
            my int $code = char_at($val, $i);
            if ($code == 10) {
                emit($cg, "\\n");
            } elsif ($code == 9) {
                emit($cg, "\\t");
            } elsif ($code == 13) {
                emit($cg, "\\r");
            } elsif ($code == 0) {
                emit($cg, "\\0");
            } elsif ($code == 7) {
                emit($cg, "\\a");
            } elsif ($code == 8) {
                emit($cg, "\\b");
            } elsif ($code == 12) {
                emit($cg, "\\f");
            } elsif ($code == 11) {
                emit($cg, "\\v");
            } elsif ($code == 27) {
                emit($cg, "\\033");
            } elsif ($code == 34) {
                emit($cg, "\\\"");
            } elsif ($code == 92) {
                emit($cg, "\\\\");
            } elsif ($code >= 32 && $code <= 126) {
                # Printable ASCII - output as-is
                emit($cg, chr($code));
            } else {
                # Non-printable/high bytes - output raw byte directly
                # The C source file is UTF-8, so raw UTF-8 bytes are valid
                emit($cg, substr_bytes($val, $i, 1));
            }
            $i = $i + 1;
        }
        emit($cg, "\")");
        return;
    }

    # Undef literal
    if ($type == NODE_UNDEF()) {
        emit($cg, "strada_new_undef()");
        return;
    }

    # Variable
    if ($type == NODE_VARIABLE()) {
        my str $var_name = $expr->{"name"};
        # Handle magic variables for map/sort/grep blocks (only when in those contexts)
        if ($var_name eq "_" && ($cg->{"in_map_block"} || $cg->{"in_grep_block"})) {
            emit($cg, "__elem_");
        } elsif ($var_name eq "a" && $cg->{"in_sort_block"}) {
            emit($cg, "__sort_a_");
        } elsif ($var_name eq "b" && $cg->{"in_sort_block"}) {
            emit($cg, "__sort_b_");
        } elsif ($cg->{"in_anon_func"}) {
            # Inside anonymous function - check if it's a param, local, or capture
            my str $param_str = $cg->{"anon_param_str"};
            my str $local_str = $cg->{"anon_local_str"};
            my str $capture_str = $cg->{"anon_capture_str"};
            if (str_contains_name($param_str, $var_name)) {
                # It's a parameter - use directly
                emit($cg, $var_name);
            } elsif (str_contains_name($local_str, $var_name)) {
                # It's a local variable - use directly
                emit($cg, $var_name);
            } else {
                # It's a capture - get or add index
                my int $idx = get_capture_index($capture_str, $var_name);
                if ($idx < 0) {
                    # New capture - add it
                    if ($capture_str eq "") {
                        $cg->{"anon_capture_str"} = $var_name;
                    } else {
                        $cg->{"anon_capture_str"} = $capture_str . "," . $var_name;
                    }
                    $idx = $cg->{"anon_capture_count"};
                    $cg->{"anon_capture_count"} = $idx + 1;
                }
                # Use double pointer dereference for capture-by-reference
                emit($cg, "(*__captures[" . $idx . "])");
            }
        } else {
            emit($cg, $var_name);
        }
        return;
    }
    
    # Binary operation
    if ($type == NODE_BINARY_OP()) {
        my str $op = $expr->{"op"};

        # For extern functions, generate raw C arithmetic
        if ($in_extern) {
            if ($op eq "+" || $op eq "-" || $op eq "*" || $op eq "/" || $op eq "%") {
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } elsif ($op eq "**") {
                # Exponentiation in extern - use pow()
                emit($cg, "pow(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, ", ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } elsif ($op eq "==" || $op eq "!=" || $op eq "<" || $op eq ">" || $op eq "<=" || $op eq ">=") {
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } elsif ($op eq "&&" || $op eq "||" || $op eq "&" || $op eq "|" || $op eq "^" || $op eq "<<" || $op eq ">>") {
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } else {
                # Fallback for other ops
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            }
            return;
        }

        if ($op eq "+") {
            emit($cg, "strada_new_num(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " + ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "-") {
            emit($cg, "strada_new_num(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " - ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "*") {
            emit($cg, "strada_new_num(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " * ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "/") {
            emit($cg, "strada_new_num(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " / ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "**") {
            # Exponentiation - use pow() from math.h
            emit($cg, "strada_new_num(pow(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, ", ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, "))");
        } elsif ($op eq "%") {
            # Modulo - use fmod for floating point, cast to int for integer result
            emit($cg, "strada_new_int((int64_t)");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " % (int64_t)");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq ".") {
            # Fast concat directly on StradaValues - no intermediate copies
            # When cleanup enabled, properly handle temporary arguments
            my scalar $left = $expr->{"left"};
            my scalar $right = $expr->{"right"};
            my int $left_is_temp = 0;
            my int $right_is_temp = 0;
            if ($cg->{"cleanup_enabled"} == 1) {
                if (needs_temp_cleanup($left) == 1) {
                    $left_is_temp = 1;
                }
                if (needs_temp_cleanup($right) == 1) {
                    $right_is_temp = 1;
                }
            }

            if ($left_is_temp == 1 || $right_is_temp == 1) {
                emit($cg, "({ ");
                if ($left_is_temp == 1) {
                    emit($cg, "StradaValue *__concat_l = ");
                    gen_expression($cg, $left);
                    emit($cg, "; ");
                }
                if ($right_is_temp == 1) {
                    emit($cg, "StradaValue *__concat_r = ");
                    gen_expression($cg, $right);
                    emit($cg, "; ");
                }
                emit($cg, "StradaValue *__concat_res = strada_concat_sv(");
                if ($left_is_temp == 1) {
                    emit($cg, "__concat_l");
                } else {
                    gen_expression($cg, $left);
                }
                emit($cg, ", ");
                if ($right_is_temp == 1) {
                    emit($cg, "__concat_r");
                } else {
                    gen_expression($cg, $right);
                }
                emit($cg, "); ");
                if ($left_is_temp == 1) {
                    emit($cg, "strada_decref(__concat_l); ");
                }
                if ($right_is_temp == 1) {
                    emit($cg, "strada_decref(__concat_r); ");
                }
                emit($cg, "__concat_res; })");
            } else {
                emit($cg, "strada_concat_sv(");
                gen_expression($cg, $left);
                emit($cg, ", ");
                gen_expression($cg, $right);
                emit($cg, ")");
            }
        } elsif ($op eq "==") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " == ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "!=") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " != ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "<") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " < ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq ">") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " > ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "<=") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " <= ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq ">=") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " >= ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "&&") {
            emit($cg, "strada_new_int(");
            emit_bool_operand($cg, $expr->{"left"});
            emit($cg, " && ");
            emit_bool_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "||") {
            emit($cg, "strada_new_int(");
            emit_bool_operand($cg, $expr->{"left"});
            emit($cg, " || ");
            emit_bool_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "&") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " & ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "|") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " | ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "^") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " ^ ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "<<") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " << ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq ">>") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " >> ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "eq") {
            emit($cg, "strada_new_int(strcmp(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, ")) == 0)");
        } elsif ($op eq "ne") {
            emit($cg, "strada_new_int(strcmp(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, ")) != 0)");
        } elsif ($op eq "lt") {
            emit($cg, "strada_new_int(strcmp(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, ")) < 0)");
        } elsif ($op eq "gt") {
            emit($cg, "strada_new_int(strcmp(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, ")) > 0)");
        } elsif ($op eq "le") {
            emit($cg, "strada_new_int(strcmp(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, ")) <= 0)");
        } elsif ($op eq "ge") {
            emit($cg, "strada_new_int(strcmp(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, ")) >= 0)");
        } elsif ($op eq "<=>") {
            # Spaceship operator: returns -1, 0, or 1
            emit($cg, "strada_new_int(({ double __l = strada_to_num(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "); double __r = strada_to_num(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, "); (__l < __r) ? -1 : ((__l > __r) ? 1 : 0); }))");
        } elsif ($op eq "=~") {
            # Regex match with string pattern (no flags)
            emit($cg, "strada_new_int(strada_regex_match_with_capture(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, "), NULL))");
        } elsif ($op eq "!~") {
            # Negated regex match with string pattern (no flags)
            emit($cg, "strada_new_int(!strada_regex_match_with_capture(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, "), NULL))");
        }
        return;
    }

    # Regex match: $str =~ /pattern/flags or $str !~ /pattern/flags
    if ($type == NODE_REGEX_MATCH()) {
        my str $op = $expr->{"op"};
        my str $pattern = $expr->{"pattern"};
        my str $flags = $expr->{"flags"};

        if ($op eq "=~") {
            emit($cg, "strada_new_int(strada_regex_match_with_capture(strada_to_str(");
        } else {
            emit($cg, "strada_new_int(!strada_regex_match_with_capture(strada_to_str(");
        }
        gen_expression($cg, $expr->{"target"});
        emit($cg, "), ");

        # Check if pattern contains variable interpolation ($)
        my int $has_interp = 0;
        my int $check_i = 0;
        my int $pat_len = length($pattern);
        while ($check_i < $pat_len) {
            my str $ch = substr($pattern, $check_i, 1);
            if ($ch eq "$") {
                $has_interp = 1;
                last;
            }
            $check_i = $check_i + 1;
        }

        if ($has_interp == 1) {
            # Pattern has variable interpolation - build at runtime
            # Parse and generate concatenation expression
            emit($cg, "strada_to_str(");
            gen_regex_interpolated_pattern($cg, $pattern);
            emit($cg, ")");
        } else {
            # Static pattern - emit as literal string
            emit($cg, "\"");
            my int $i = 0;
            my int $len = length($pattern);
            while ($i < $len) {
                my str $ch = substr($pattern, $i, 1);
                if ($ch eq "\\") {
                    emit($cg, "\\\\");
                } elsif ($ch eq "\"") {
                    emit($cg, "\\\"");
                } elsif ($ch eq "\n") {
                    emit($cg, "\\n");
                } elsif ($ch eq "\t") {
                    emit($cg, "\\t");
                } else {
                    emit($cg, $ch);
                }
                $i = $i + 1;
            }
            emit($cg, "\"");
        }
        emit($cg, ", ");
        # Pass flags (or NULL if empty)
        if (length($flags) > 0) {
            emit($cg, "\"" . $flags . "\"");
        } else {
            emit($cg, "NULL");
        }
        emit($cg, "))");
        return;
    }

    # Regex substitution: $str =~ s/pattern/replacement/flags
    if ($type == NODE_REGEX_SUBST()) {
        my str $pattern = $expr->{"pattern"};
        my str $replacement = $expr->{"replacement"};
        my str $flags = $expr->{"flags"};

        # Check for global flag
        my int $global = 0;
        if (index($flags, "g") >= 0) {
            $global = 1;
        }

        # Generate: target = strada_new_str(strada_regex_replace[_all](strada_to_str(target), pattern, replacement, flags))
        gen_expression($cg, $expr->{"target"});
        emit($cg, " = ");

        if ($global == 1) {
            emit($cg, "strada_new_str(strada_regex_replace_all(strada_to_str(");
        } else {
            emit($cg, "strada_new_str(strada_regex_replace(strada_to_str(");
        }
        gen_expression($cg, $expr->{"target"});
        emit($cg, "), \"");
        # Escape pattern
        my int $i = 0;
        my int $len = length($pattern);
        while ($i < $len) {
            my str $ch = substr($pattern, $i, 1);
            if ($ch eq "\\") {
                emit($cg, "\\\\");
            } elsif ($ch eq "\"") {
                emit($cg, "\\\"");
            } elsif ($ch eq "\n") {
                emit($cg, "\\n");
            } elsif ($ch eq "\t") {
                emit($cg, "\\t");
            } elsif ($ch eq "\r") {
                emit($cg, "\\r");
            } else {
                emit($cg, $ch);
            }
            $i = $i + 1;
        }
        emit($cg, "\", \"");
        # Escape replacement
        $i = 0;
        $len = length($replacement);
        while ($i < $len) {
            my str $ch = substr($replacement, $i, 1);
            if ($ch eq "\\") {
                emit($cg, "\\\\");
            } elsif ($ch eq "\"") {
                emit($cg, "\\\"");
            } elsif ($ch eq "\n") {
                emit($cg, "\\n");
            } elsif ($ch eq "\t") {
                emit($cg, "\\t");
            } elsif ($ch eq "\r") {
                emit($cg, "\\r");
            } else {
                emit($cg, $ch);
            }
            $i = $i + 1;
        }
        emit($cg, "\", ");
        # Pass flags (or NULL if empty)
        if (length($flags) > 0) {
            emit($cg, "\"" . $flags . "\"");
        } else {
            emit($cg, "NULL");
        }
        emit($cg, "))");
        return;
    }

    # Unary operation
    if ($type == NODE_UNARY_OP()) {
        my str $op = $expr->{"op"};
        if ($op eq "-") {
            emit($cg, "strada_new_num(-strada_to_num(");
            gen_expression($cg, $expr->{"operand"});
            emit($cg, "))");
        } elsif ($op eq "!") {
            emit($cg, "strada_new_int(!strada_to_bool(");
            gen_expression($cg, $expr->{"operand"});
            emit($cg, "))");
        } elsif ($op eq "~") {
            emit($cg, "strada_new_int(~strada_to_int(");
            gen_expression($cg, $expr->{"operand"});
            emit($cg, "))");
        }
        return;
    }

    # Increment/decrement (++ and --)
    if ($type == NODE_INCREMENT()) {
        my str $op = $expr->{"op"};
        my int $is_prefix = $expr->{"is_prefix"};
        my scalar $operand = $expr->{"operand"};
        my int $operand_type = $operand->{"type"};

        # For simple variables, use address-of
        if ($operand_type == NODE_VARIABLE()) {
            if ($is_prefix == 1) {
                if ($op eq "++") {
                    emit($cg, "strada_preincr(&");
                } else {
                    emit($cg, "strada_predecr(&");
                }
            } else {
                if ($op eq "++") {
                    emit($cg, "strada_postincr(&");
                } else {
                    emit($cg, "strada_postdecr(&");
                }
            }
            gen_expression($cg, $operand);
            emit($cg, ")");
        } else {
            # For complex expressions, fall back to inline increment
            # This works for statement context but returns wrong value for postfix
            emit($cg, "(");
            gen_expression($cg, $operand);
            emit($cg, " = strada_new_num(strada_to_num(");
            gen_expression($cg, $operand);
            if ($op eq "++") {
                emit($cg, ") + 1))");
            } else {
                emit($cg, ") - 1))");
            }
        }
        return;
    }

    # Function call
    if ($type == NODE_CALL()) {
        my str $name = $expr->{"name"};
        
        # Built-in functions
        if ($name eq "say") {
            if ($expr->{"arg_count"} > 0) {
                my scalar $args = $expr->{"args"};
                my scalar $arg = $args->[0];
                # If cleanup enabled and arg is a temporary, wrap to decref after
                if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($arg) == 1) {
                    emit($cg, "({ StradaValue *__say_tmp = ");
                    gen_expression($cg, $arg);
                    emit($cg, "; strada_say(__say_tmp); strada_decref(__say_tmp); })");
                } else {
                    emit($cg, "strada_say(");
                    gen_expression($cg, $arg);
                    emit($cg, ")");
                }
            } else {
                emit($cg, "strada_say(strada_new_str(\"\"))");
            }
            return;
        }

        if ($name eq "print") {
            if ($expr->{"arg_count"} > 0) {
                my scalar $args = $expr->{"args"};
                my scalar $arg = $args->[0];
                # If cleanup enabled and arg is a temporary, wrap to decref after
                if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($arg) == 1) {
                    emit($cg, "({ StradaValue *__print_tmp = ");
                    gen_expression($cg, $arg);
                    emit($cg, "; strada_print(__print_tmp); strada_decref(__print_tmp); })");
                } else {
                    emit($cg, "strada_print(");
                    gen_expression($cg, $arg);
                    emit($cg, ")");
                }
            } else {
                emit($cg, "strada_print(strada_new_str(\"\"))");
            }
            return;
        }
        
        if ($name eq "length") {
            # Binary-safe length using struct_size
            emit($cg, "strada_new_int(strada_length_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "bytes") {
            emit($cg, "strada_new_int(strada_bytes(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }

        if ($name eq "char_at") {
            emit($cg, "strada_char_at(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "substr_bytes") {
            emit($cg, "strada_substr_bytes(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), ");
            if ($expr->{"arg_count"} > 2) {
                emit($cg, "strada_to_int(");
                gen_expression($cg, $args->[2]);
                emit($cg, ")");
            } else {
                emit($cg, "-1");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "substr") {
            emit($cg, "strada_substr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), ");
            if ($expr->{"arg_count"} > 2) {
                emit($cg, "strada_to_int(");
                gen_expression($cg, $args->[2]);
                emit($cg, ")");
            } else {
                emit($cg, "-1");
            }
            emit($cg, ")");
            return;
        }
        
        if ($name eq "push") {
            emit($cg, "(strada_array_push(strada_deref_array(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), ");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_new_undef())");
            return;
        }

        # reserve - pre-allocate array capacity
        if ($name eq "reserve") {
            emit($cg, "(strada_reserve_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")), strada_new_undef())");
            return;
        }

        if ($name eq "size") {
            emit($cg, "strada_new_int(strada_size(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "pop") {
            emit($cg, "strada_array_pop(strada_deref_array(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "shift") {
            emit($cg, "strada_array_shift(strada_deref_array(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "unshift") {
            emit($cg, "(strada_array_unshift(strada_deref_array(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), ");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_new_undef())");
            return;
        }

        if ($name eq "sort") {
            emit($cg, "strada_sort(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "nsort") {
            emit($cg, "strada_nsort(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "split") {
            # split(pattern, string) - like Perl
            # strada_regex_split(str, pattern) - runtime signature
            emit($cg, "(({ StradaValue *__sv = strada_new_array(); ");
            emit($cg, "__sv->value.av = strada_regex_split(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[1]);  # string comes first in runtime
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[0]);  # pattern comes second in runtime
            emit($cg, ")); __sv; }))");
            return;
        }
        
        if ($name eq "join") {
            emit($cg, "strada_new_str(strada_join(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_deref_array(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }
        
        if ($name eq "keys") {
            emit($cg, "strada_new_array_from_av(strada_hash_keys(strada_deref_hash(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        if ($name eq "values") {
            emit($cg, "strada_new_array_from_av(strada_hash_values(strada_deref_hash(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        if ($name eq "exists") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            
            # Check if single arg is a hash access node
            if ($expr->{"arg_count"} == 1 && $arg0->{"type"} == NODE_HASH_ACCESS()) {
                emit($cg, "strada_new_int(strada_hash_exists(strada_deref_hash(");
                gen_expression($cg, $arg0->{"hash"});
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $arg0->{"key"});
                emit($cg, ")))");
            } else {
                # Two arg form: exists(hash, key)
                emit($cg, "strada_new_int(strada_hash_exists(strada_deref_hash(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, ")))");
            }
            return;
        }
        
        if ($name eq "delete") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            
            # Check if single arg is a hash access node
            if ($expr->{"arg_count"} == 1 && $arg0->{"type"} == NODE_HASH_ACCESS()) {
                emit($cg, "strada_hash_delete(strada_deref_hash(");
                gen_expression($cg, $arg0->{"hash"});
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $arg0->{"key"});
                emit($cg, "))");
            } else {
                emit($cg, "strada_hash_delete(strada_deref_hash(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, "))");
            }
            return;
        }
        
        if ($name eq "hash_new") {
            emit($cg, "strada_new_hash()");
            return;
        }
        
        if ($name eq "hash_get") {
            emit($cg, "strada_hash_get(strada_deref_hash(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "hash_set") {
            emit($cg, "strada_hash_set(strada_deref_hash(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }
        
        if ($name eq "array_new") {
            emit($cg, "strada_new_array()");
            return;
        }
        
        if ($name eq "sys::cstruct_new") {
            emit($cg, "strada_new_hash()");
            return;
        }
        
        if ($name eq "defined") {
            emit($cg, "strada_defined(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        if ($name eq "ref") {
            emit($cg, "strada_new_str(strada_reftype(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "dumper") {
            emit($cg, "strada_dumper(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "dumper_str") {
            emit($cg, "strada_dumper_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "exit") {
            emit($cg, "exit(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # Process control functions
        if ($name eq "sys::sleep") {
            emit($cg, "strada_sleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::usleep") {
            emit($cg, "strada_usleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fork") {
            emit($cg, "strada_fork()");
            return;
        }

        if ($name eq "sys::wait") {
            emit($cg, "strada_wait()");
            return;
        }

        if ($name eq "sys::waitpid") {
            emit($cg, "strada_waitpid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "strada_new_int(0)");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpid") {
            emit($cg, "strada_getpid()");
            return;
        }

        if ($name eq "sys::getppid") {
            emit($cg, "strada_getppid()");
            return;
        }

        # Pipe and IPC functions
        if ($name eq "sys::pipe") {
            emit($cg, "strada_pipe()");
            return;
        }

        if ($name eq "sys::dup2") {
            emit($cg, "strada_dup2(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::close_fd") {
            emit($cg, "strada_close_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::exec") {
            emit($cg, "strada_exec(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "exec_argv") {
            emit($cg, "strada_exec_argv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::system") {
            emit($cg, "strada_system(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::system_argv") {
            emit($cg, "strada_system_argv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setprocname") {
            emit($cg, "strada_setprocname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getprocname") {
            emit($cg, "strada_getprocname()");
            return;
        }

        if ($name eq "sys::setproctitle") {
            emit($cg, "strada_setproctitle(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getproctitle") {
            emit($cg, "strada_getproctitle()");
            return;
        }

        if ($name eq "sys::read_fd") {
            emit($cg, "strada_read_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::write_fd") {
            emit($cg, "strada_write_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::read_all_fd") {
            emit($cg, "strada_read_all_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "fdopen_read") {
            emit($cg, "strada_fdopen_read(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "fdopen_write") {
            emit($cg, "strada_fdopen_write(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # POSIX functions
        if ($name eq "sys::getenv") {
            emit($cg, "strada_getenv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setenv") {
            emit($cg, "strada_setenv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::unsetenv") {
            emit($cg, "strada_unsetenv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # sys::array_default_capacity - get or set default array capacity
        if ($name eq "sys::array_default_capacity") {
            my scalar $args = $expr->{"args"};
            my int $nargs = size($args);
            if ($nargs == 0) {
                # Get current default capacity
                emit($cg, "strada_new_int(strada_get_array_default_capacity())");
            } else {
                # Set new default capacity and return it
                emit($cg, "(strada_set_array_default_capacity(strada_to_int(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")), strada_new_int(strada_get_array_default_capacity()))");
            }
            return;
        }

        # sys::hash_default_capacity - get or set default hash bucket count
        if ($name eq "sys::hash_default_capacity") {
            my scalar $args = $expr->{"args"};
            my int $nargs = size($args);
            if ($nargs == 0) {
                # Get current default capacity
                emit($cg, "strada_new_int(strada_get_hash_default_capacity())");
            } else {
                # Set new default capacity and return it
                emit($cg, "(strada_set_hash_default_capacity(strada_to_int(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")), strada_new_int(strada_get_hash_default_capacity()))");
            }
            return;
        }

        if ($name eq "sys::getcwd") {
            emit($cg, "strada_getcwd()");
            return;
        }

        if ($name eq "sys::chdir") {
            emit($cg, "strada_chdir(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mkdir") {
            emit($cg, "strada_mkdir(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "strada_new_int(0755)");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::rmdir") {
            emit($cg, "strada_rmdir(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::unlink") {
            emit($cg, "strada_unlink(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::link") {
            emit($cg, "strada_link(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::symlink") {
            emit($cg, "strada_symlink(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::readlink") {
            emit($cg, "strada_readlink(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::rename") {
            emit($cg, "strada_rename(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::chmod") {
            emit($cg, "strada_chmod(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::access") {
            emit($cg, "strada_access(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::umask") {
            emit($cg, "strada_umask(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getuid") {
            emit($cg, "strada_getuid()");
            return;
        }

        if ($name eq "sys::geteuid") {
            emit($cg, "strada_geteuid()");
            return;
        }

        if ($name eq "sys::getgid") {
            emit($cg, "strada_getgid()");
            return;
        }

        if ($name eq "sys::getegid") {
            emit($cg, "strada_getegid()");
            return;
        }

        if ($name eq "sys::kill") {
            emit($cg, "strada_kill(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::signal") {
            emit($cg, "strada_signal(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::alarm") {
            emit($cg, "strada_alarm(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::stat") {
            emit($cg, "strada_stat(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::lstat") {
            emit($cg, "strada_lstat(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::isatty") {
            emit($cg, "strada_isatty(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::strerror") {
            emit($cg, "strada_strerror(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::errno") {
            emit($cg, "strada_errno()");
            return;
        }

        if ($name eq "sys::time") {
            emit($cg, "strada_time()");
            return;
        }

        if ($name eq "sys::localtime") {
            emit($cg, "strada_localtime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::gmtime") {
            emit($cg, "strada_gmtime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mktime") {
            emit($cg, "strada_mktime(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::strftime") {
            emit($cg, "strada_strftime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($arg_count > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ctime") {
            emit($cg, "strada_ctime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::sleep") {
            emit($cg, "strada_sleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::usleep") {
            emit($cg, "strada_usleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::gettimeofday") {
            emit($cg, "strada_gettimeofday()");
            return;
        }

        if ($name eq "sys::hires_time") {
            emit($cg, "strada_hires_time()");
            return;
        }

        # Memory profiler functions
        if ($name eq "sys::memprof_enable") {
            emit($cg, "(strada_memprof_enable(), strada_new_undef())");
            return;
        }
        if ($name eq "sys::memprof_disable") {
            emit($cg, "(strada_memprof_disable(), strada_new_undef())");
            return;
        }
        if ($name eq "sys::memprof_report") {
            emit($cg, "(strada_memprof_report(), strada_new_undef())");
            return;
        }
        if ($name eq "sys::memprof_reset") {
            emit($cg, "(strada_memprof_reset(), strada_new_undef())");
            return;
        }

        if ($name eq "sys::tv_interval") {
            emit($cg, "strada_tv_interval(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($arg_count > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::nanosleep") {
            emit($cg, "strada_nanosleep_ns(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clock_gettime") {
            emit($cg, "strada_clock_gettime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clock_getres") {
            emit($cg, "strada_clock_getres(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_open") {
            emit($cg, "strada_dl_open(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "strada_dl_open_raw") {
            emit($cg, "strada_dl_open_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_sym") {
            emit($cg, "strada_dl_sym(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_close") {
            emit($cg, "strada_dl_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_error") {
            emit($cg, "strada_dl_error()");
            return;
        }

        if ($name eq "sys::dl_call_int") {
            emit($cg, "strada_dl_call_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_num") {
            emit($cg, "strada_dl_call_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_str") {
            emit($cg, "strada_dl_call_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_void") {
            emit($cg, "strada_dl_call_void(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_int_sv") {
            emit($cg, "strada_dl_call_int_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_str_sv") {
            emit($cg, "strada_dl_call_str_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_void_sv") {
            emit($cg, "strada_dl_call_void_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_sv") {
            emit($cg, "strada_dl_call_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_export_info") {
            emit($cg, "strada_dl_call_export_info(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_version") {
            emit($cg, "strada_dl_call_version(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Pointer access for FFI
        if ($name eq "sys::int_ptr") {
            emit($cg, "strada_int_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::num_ptr") {
            emit($cg, "strada_num_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::str_ptr") {
            emit($cg, "strada_str_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_int") {
            emit($cg, "strada_ptr_deref_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_num") {
            emit($cg, "strada_ptr_deref_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_str") {
            emit($cg, "strada_ptr_deref_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_int") {
            emit($cg, "strada_ptr_set_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_num") {
            emit($cg, "strada_ptr_set_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::rand") {
            emit($cg, "strada_rand()");
            return;
        }

        if ($name eq "sys::exit_status") {
            emit($cg, "strada_exit_status(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Thread functions
        if ($name eq "thread::create") {
            emit($cg, "strada_thread_create(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::join") {
            emit($cg, "strada_thread_join(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::detach") {
            emit($cg, "strada_thread_detach(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::self") {
            emit($cg, "strada_thread_self()");
            return;
        }

        if ($name eq "thread::mutex_new") {
            emit($cg, "strada_mutex_new()");
            return;
        }

        if ($name eq "thread::mutex_lock") {
            emit($cg, "strada_mutex_lock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::mutex_trylock") {
            emit($cg, "strada_mutex_trylock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::mutex_unlock") {
            emit($cg, "strada_mutex_unlock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::mutex_destroy") {
            emit($cg, "strada_mutex_destroy(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_new") {
            emit($cg, "strada_cond_new()");
            return;
        }

        if ($name eq "thread::cond_wait") {
            emit($cg, "strada_cond_wait(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_signal") {
            emit($cg, "strada_cond_signal(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_broadcast") {
            emit($cg, "strada_cond_broadcast(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_destroy") {
            emit($cg, "strada_cond_destroy(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Directory functions
        if ($name eq "sys::readdir") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_readdir", $args, 1);
            return;
        }

        if ($name eq "sys::readdir_full") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_readdir_full", $args, 1);
            return;
        }

        if ($name eq "sys::is_dir") {
            emit($cg, "strada_is_dir(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::is_file") {
            emit($cg, "strada_is_file(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::file_size") {
            emit($cg, "strada_file_size(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Math functions
        if ($name eq "math::sin") {
            emit($cg, "strada_sin(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::cos") {
            emit($cg, "strada_cos(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::tan") {
            emit($cg, "strada_tan(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::asin") {
            emit($cg, "strada_asin(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::acos") {
            emit($cg, "strada_acos(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::atan") {
            emit($cg, "strada_atan(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::atan2") {
            emit($cg, "strada_atan2(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::log") {
            emit($cg, "strada_log(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::log10") {
            emit($cg, "strada_log10(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::exp") {
            emit($cg, "strada_exp(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::pow") {
            emit($cg, "strada_pow(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::floor") {
            emit($cg, "strada_floor(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::ceil") {
            emit($cg, "strada_ceil(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::round") {
            emit($cg, "strada_round(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::fabs") {
            emit($cg, "strada_fabs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::fmod") {
            emit($cg, "strada_fmod(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::sinh") {
            emit($cg, "strada_sinh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::cosh") {
            emit($cg, "strada_cosh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::tanh") {
            emit($cg, "strada_tanh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # File seek functions
        if ($name eq "sys::seek") {
            emit($cg, "strada_seek(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 2) {
                gen_expression($cg, $args->[2]);
            } else {
                emit($cg, "strada_new_int(0)");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::tell") {
            emit($cg, "strada_tell(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::rewind") {
            emit($cg, "strada_rewind(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::eof") {
            emit($cg, "strada_eof(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::flush") {
            emit($cg, "strada_flush(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::readline") {
            emit($cg, "strada_read_line(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # DNS/Hostname functions
        if ($name eq "sys::gethostbyname") {
            emit($cg, "strada_gethostbyname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::gethostbyname_all") {
            emit($cg, "strada_gethostbyname_all(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::gethostname") {
            emit($cg, "strada_gethostname()");
            return;
        }

        if ($name eq "sys::getaddrinfo") {
            emit($cg, "strada_getaddrinfo_first(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "strada_new_str(\"\")");
            }
            emit($cg, ")");
            return;
        }

        # Path functions
        if ($name eq "sys::realpath") {
            emit($cg, "strada_realpath(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dirname") {
            emit($cg, "strada_dirname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::basename") {
            emit($cg, "strada_basename(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::glob") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_glob", $args, 1);
            return;
        }

        if ($name eq "sys::fnmatch") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_fnmatch", $args, 2);
            return;
        }

        if ($name eq "sys::file_ext") {
            emit($cg, "strada_file_ext(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::path_join") {
            emit($cg, "strada_path_join(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "int") {
            emit($cg, "strada_new_int(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "chr") {
            # Use strada_chr_sv for binary-safe chr that handles NUL bytes
            emit($cg, "strada_chr_sv(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "ord") {
            emit($cg, "strada_new_int(strada_ord(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }

        # ord_byte - binary-safe ord that returns raw byte value 0-255
        if ($name eq "sys::ord_byte") {
            emit($cg, "strada_new_int(strada_ord_byte(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "uc" || $name eq "upper") {
            emit($cg, "strada_new_str(strada_uc(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        if ($name eq "lc" || $name eq "lower") {
            emit($cg, "strada_new_str(strada_lc(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        if ($name eq "index") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count == 3) {
                # 3-argument form: index(string, substring, offset)
                emit($cg, "strada_new_int(strada_index_offset(strada_to_str(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, "), strada_to_int(");
                gen_expression($cg, $args->[2]);
                emit($cg, ")))");
            } else {
                # 2-argument form: index(string, substring)
                emit($cg, "strada_new_int(strada_index(strada_to_str(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, ")))");
            }
            return;
        }
        
        if ($name eq "sprintf") {
            emit($cg, "strada_sprintf(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            my int $i = 1;
            while ($i < $expr->{"arg_count"}) {
                emit($cg, ", strada_to_str(");
                gen_expression($cg, $args->[$i]);
                emit($cg, ")");
                $i = $i + 1;
            }
            emit($cg, ")");
            return;
        }
        
        if ($name eq "printf") {
            emit($cg, "strada_printf(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            my int $i = 1;
            while ($i < $expr->{"arg_count"}) {
                emit($cg, ", strada_to_str(");
                gen_expression($cg, $args->[$i]);
                emit($cg, ")");
                $i = $i + 1;
            }
            emit($cg, ")");
            return;
        }
        
        if ($name eq "warn") {
            emit($cg, "strada_warn(\"%s\", strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "sys::slurp" || $name eq "slurp") {
            emit($cg, "strada_slurp(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "sys::slurp_fh") {
            emit($cg, "strada_slurp_fh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::slurp_fd") {
            emit($cg, "strada_slurp_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::spew" || $name eq "spew") {
            emit($cg, "strada_spew(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        if ($name eq "sys::spew_fh") {
            emit($cg, "strada_spew_fh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::spew_fd") {
            emit($cg, "strada_spew_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # StringBuilder functions for O(1) amortized append
        if ($name eq "sb_new") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                emit($cg, "strada_sb_new_cap(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            } else {
                emit($cg, "strada_sb_new()");
            }
            return;
        }

        if ($name eq "sb_append") {
            emit($cg, "(strada_sb_append(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_new_undef())");
            return;
        }

        if ($name eq "sb_to_string") {
            emit($cg, "strada_sb_to_string(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sb_length") {
            emit($cg, "strada_sb_length(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sb_clear") {
            emit($cg, "(strada_sb_clear(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_new_undef())");
            return;
        }

        if ($name eq "sb_free") {
            emit($cg, "(strada_sb_free(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_new_undef())");
            return;
        }

        # open(filename, mode) - open file for reading/writing/appending
        if ($name eq "sys::open") {
            emit($cg, "strada_open(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        if ($name eq "sys::open_fd") {
            emit($cg, "strada_open_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # close(fh) - close file handle
        if ($name eq "sys::close") {
            emit($cg, "strada_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # write_fd(fd, str) - write to file descriptor
        if ($name eq "write_fd" || $name eq "sys::write_fd") {
            emit($cg, "strada_write_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # close_fd(fd) - close file descriptor
        if ($name eq "close_fd" || $name eq "sys::close_fd") {
            emit($cg, "strada_close_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # getpid() - get process ID
        if ($name eq "getpid" || $name eq "sys::getpid") {
            emit($cg, "strada_new_int(getpid())");
            return;
        }

        # unlink(path) - delete file
        if ($name eq "unlink" || $name eq "sys::unlink") {
            emit($cg, "strada_unlink(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # fwrite(fh, content) - write to file handle
        if ($name eq "sys::fwrite") {
            emit($cg, "strada_write_file(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # fread(fh) - read entire file from handle
        if ($name eq "sys::fread") {
            emit($cg, "strada_read_file(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "die") {
            emit($cg, "strada_die(\"%s\", strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "throw") {
            emit($cg, "strada_throw_value(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # scalar() - get array length as int
        if ($name eq "scalar") {
            emit($cg, "strada_new_int(strada_array_length(strada_deref_array(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # is_ref / is_refto - check if value is a reference
        if ($name eq "is_ref" || $name eq "is_refto") {
            emit($cg, "strada_new_int(strada_is_ref(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # reftype - get reference type string
        if ($name eq "reftype") {
            emit($cg, "strada_new_str(strada_reftype(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # refto - create a reference
        if ($name eq "refto") {
            emit($cg, "strada_new_ref(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", '$')");
            return;
        }
        
        # derefto - dereference
        if ($name eq "derefto" || $name eq "deref") {
            emit($cg, "strada_deref(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # deref_array - dereference to array (returns StradaValue*)
        if ($name eq "deref_array") {
            emit($cg, "strada_deref_array_value(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # deref_hash - dereference to hash (returns StradaValue*)
        if ($name eq "deref_hash") {
            emit($cg, "strada_deref_hash_value(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # deref_set - set value through a scalar reference
        if ($name eq "deref_set") {
            emit($cg, "strada_deref_set(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # clone - deep copy a value
        if ($name eq "clone") {
            emit($cg, "strada_clone(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # typeof - get type name string
        if ($name eq "typeof") {
            emit($cg, "strada_typeof(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # abs - absolute value
        if ($name eq "math::abs") {
            emit($cg, "strada_abs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # sqrt - square root
        if ($name eq "math::sqrt") {
            emit($cg, "strada_sqrt(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # rand - random number
        if ($name eq "math::rand") {
            emit($cg, "strada_rand()");
            return;
        }
        
        # time - current timestamp
        if ($name eq "sys::time") {
            emit($cg, "strada_time()");
            return;
        }

        # localtime - convert timestamp to local time hash
        if ($name eq "sys::localtime") {
            emit($cg, "strada_localtime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # gmtime - convert timestamp to UTC time hash
        if ($name eq "sys::gmtime") {
            emit($cg, "strada_gmtime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # mktime - convert time hash to timestamp
        if ($name eq "sys::mktime") {
            emit($cg, "strada_mktime(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # strftime - format time
        if ($name eq "sys::strftime") {
            emit($cg, "strada_strftime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($arg_count > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # ctime - convert timestamp to string
        if ($name eq "sys::ctime") {
            emit($cg, "strada_ctime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # sleep - sleep for seconds
        if ($name eq "sys::sleep") {
            emit($cg, "strada_sleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # usleep - sleep for microseconds
        if ($name eq "sys::usleep") {
            emit($cg, "strada_usleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # gettimeofday - high-res time
        if ($name eq "sys::gettimeofday") {
            emit($cg, "strada_gettimeofday()");
            return;
        }

        # hires_time - floating point seconds
        if ($name eq "sys::hires_time") {
            emit($cg, "strada_hires_time()");
            return;
        }

        # Memory profiler functions
        if ($name eq "sys::memprof_enable") {
            emit($cg, "(strada_memprof_enable(), strada_new_undef())");
            return;
        }
        if ($name eq "sys::memprof_disable") {
            emit($cg, "(strada_memprof_disable(), strada_new_undef())");
            return;
        }
        if ($name eq "sys::memprof_report") {
            emit($cg, "(strada_memprof_report(), strada_new_undef())");
            return;
        }
        if ($name eq "sys::memprof_reset") {
            emit($cg, "(strada_memprof_reset(), strada_new_undef())");
            return;
        }

        # tv_interval - time interval
        if ($name eq "sys::tv_interval") {
            emit($cg, "strada_tv_interval(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($arg_count > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # nanosleep - sleep nanoseconds
        if ($name eq "sys::nanosleep") {
            emit($cg, "strada_nanosleep_ns(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # clock_gettime - get clock time
        if ($name eq "sys::clock_gettime") {
            emit($cg, "strada_clock_gettime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # clock_getres - get clock resolution
        if ($name eq "sys::clock_getres") {
            emit($cg, "strada_clock_getres(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # dl_open - open shared library
        if ($name eq "sys::dl_open") {
            emit($cg, "strada_dl_open(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # strada_dl_open_raw - internal raw library open
        if ($name eq "strada_dl_open_raw") {
            emit($cg, "strada_dl_open_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # strada_dl_sym_raw - internal raw symbol lookup
        if ($name eq "strada_dl_sym_raw") {
            emit($cg, "strada_dl_sym_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # strada_dl_close_raw - internal raw library close
        if ($name eq "strada_dl_close_raw") {
            emit($cg, "strada_dl_close_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # dl_sym - get symbol from library
        if ($name eq "sys::dl_sym") {
            emit($cg, "strada_dl_sym(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_close - close library
        if ($name eq "sys::dl_close") {
            emit($cg, "strada_dl_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # dl_error - get last error
        if ($name eq "sys::dl_error") {
            emit($cg, "strada_dl_error()");
            return;
        }

        # dl_call_int - call function returning int
        if ($name eq "sys::dl_call_int") {
            emit($cg, "strada_dl_call_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_num - call function returning num
        if ($name eq "sys::dl_call_num") {
            emit($cg, "strada_dl_call_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_str - call function returning string
        if ($name eq "sys::dl_call_str") {
            emit($cg, "strada_dl_call_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_void - call function with no return
        if ($name eq "sys::dl_call_void") {
            emit($cg, "strada_dl_call_void(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_int_sv - call function passing StradaValue* directly, returns int
        if ($name eq "sys::dl_call_int_sv") {
            emit($cg, "strada_dl_call_int_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_str_sv - call function passing StradaValue* directly, returns string
        if ($name eq "sys::dl_call_str_sv") {
            emit($cg, "strada_dl_call_str_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_void_sv - call function passing StradaValue* directly, no return
        if ($name eq "sys::dl_call_void_sv") {
            emit($cg, "strada_dl_call_void_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_sv") {
            emit($cg, "strada_dl_call_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_export_info") {
            emit($cg, "strada_dl_call_export_info(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_version") {
            emit($cg, "strada_dl_call_version(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Pointer access for FFI
        if ($name eq "sys::int_ptr") {
            emit($cg, "strada_int_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::num_ptr") {
            emit($cg, "strada_num_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::str_ptr") {
            emit($cg, "strada_str_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_int") {
            emit($cg, "strada_ptr_deref_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_num") {
            emit($cg, "strada_ptr_deref_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_str") {
            emit($cg, "strada_ptr_deref_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_int") {
            emit($cg, "strada_ptr_set_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_num") {
            emit($cg, "strada_ptr_set_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # readline - read line from stdin or file handle
        if ($name eq "readline") {
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                # readline(fh) - read from file handle
                emit($cg, "strada_read_line(");
                my scalar $args = $expr->{"args"};
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            } else {
                # readline() - read from stdin
                emit($cg, "strada_readline()");
            }
            return;
        }
        
        # refcount - get reference count
        if ($name eq "refcount") {
            emit($cg, "strada_new_int(strada_refcount(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # free - explicitly decrement refcount and free if zero
        if ($name eq "sys::free") {
            emit($cg, "(strada_free(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_new_undef())");
            return;
        }

        # release - free value and set variable to undef (safe free)
        # release(\$var) -> frees $var's value and sets $var = undef
        if ($name eq "sys::release") {
            my scalar $args = $expr->{"args"};
            my scalar $ref_arg = $args->[0];

            # Check if argument is a reference expression like \$var
            if ($ref_arg->{"type"} == NODE_REF() && $ref_arg->{"target"}->{"type"} == NODE_VARIABLE()) {
                my str $varname = $ref_arg->{"target"}->{"name"};
                # Generate: (strada_free(varname), varname = strada_new_undef())
                emit($cg, "(strada_free(" . $varname . "), " . $varname . " = strada_new_undef())");
            } else {
                # Fallback: just call the runtime function
                emit($cg, "strada_release(");
                gen_expression($cg, $ref_arg);
                emit($cg, ")");
            }
            return;
        }

        # ucfirst - uppercase first letter
        if ($name eq "ucfirst") {
            emit($cg, "strada_new_str(strada_ucfirst(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # lcfirst - lowercase first letter
        if ($name eq "lcfirst") {
            emit($cg, "strada_new_str(strada_lcfirst(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # match - regex match
        if ($name eq "match") {
            emit($cg, "strada_new_int(strada_regex_match(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }
        
        # capture - regex capture
        if ($name eq "capture") {
            emit($cg, "strada_new_array_from_av(strada_regex_capture(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # captures - get captures from last =~ match
        if ($name eq "captures") {
            emit($cg, "strada_captures()");
            return;
        }

        # replace - regex replace (no flags for function-based API)
        if ($name eq "replace") {
            emit($cg, "strada_new_str(strada_regex_replace(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), NULL))");
            return;
        }
        
        # cstruct_set_int
        if ($name eq "sys::cstruct_set_int") {
            emit($cg, "strada_cstruct_set_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_set_string
        if ($name eq "sys::cstruct_set_string") {
            emit($cg, "strada_cstruct_set_string(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_set_double
        if ($name eq "sys::cstruct_set_double") {
            emit($cg, "strada_cstruct_set_double(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_num(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_get_int
        if ($name eq "sys::cstruct_get_int") {
            emit($cg, "strada_new_int(strada_cstruct_get_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_get_string
        if ($name eq "sys::cstruct_get_string") {
            emit($cg, "strada_new_str(strada_cstruct_get_string(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_get_double
        if ($name eq "sys::cstruct_get_double") {
            emit($cg, "strada_new_num(strada_cstruct_get_double(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_new
        if ($name eq "sys::cstruct_new") {
            emit($cg, "strada_cstruct_new(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_ptr
        if ($name eq "sys::cstruct_ptr") {
            emit($cg, "strada_cstruct_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # socket_client
        if ($name eq "sys::socket_client") {
            emit($cg, "strada_socket_client(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }
        
        # socket_server
        if ($name eq "sys::socket_server") {
            emit($cg, "strada_socket_server(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # socket_server_backlog
        if ($name eq "sys::socket_server_backlog") {
            emit($cg, "strada_socket_server_backlog(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # socket_accept
        if ($name eq "sys::socket_accept") {
            emit($cg, "strada_socket_accept(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # socket_recv
        if ($name eq "sys::socket_recv") {
            emit($cg, "strada_socket_recv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }
        
        # socket_send - use binary-safe version that handles NUL bytes
        if ($name eq "sys::socket_send") {
            emit($cg, "strada_socket_send_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }
        
        # socket_close
        if ($name eq "sys::socket_close") {
            emit($cg, "strada_socket_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # socket_select - wait for sockets to be ready for reading
        if ($name eq "sys::socket_select") {
            emit($cg, "strada_socket_select(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # socket_fd - get file descriptor from socket
        if ($name eq "sys::socket_fd") {
            emit($cg, "strada_new_int(strada_socket_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # select_fds - wait for file descriptors to be ready for reading
        if ($name eq "sys::select_fds") {
            emit($cg, "strada_select_fds(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # UDP socket functions

        # udp_socket - create a UDP socket
        if ($name eq "sys::udp_socket") {
            emit($cg, "strada_udp_socket()");
            return;
        }

        # udp_bind - bind UDP socket to a port
        if ($name eq "sys::udp_bind") {
            emit($cg, "strada_new_int(strada_udp_bind(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # udp_server - create UDP server bound to a port
        if ($name eq "sys::udp_server") {
            emit($cg, "strada_udp_server(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # udp_recvfrom - receive UDP packet with sender info
        if ($name eq "sys::udp_recvfrom") {
            emit($cg, "strada_udp_recvfrom(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # udp_sendto - send UDP packet to host:port
        if ($name eq "sys::udp_sendto") {
            emit($cg, "strada_new_int(strada_udp_sendto_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[3]);
            emit($cg, ")))");
            return;
        }

        # stacktrace
        if ($name eq "stacktrace") {
            emit($cg, "strada_new_str(\"[stacktrace not available]\")");
            return;
        }
        
        # caller
        if ($name eq "caller") {
            emit($cg, "strada_new_str(\"main\")");
            return;
        }
        
        # trim - trim whitespace
        if ($name eq "trim") {
            emit($cg, "strada_new_str(strada_trim(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # ltrim - trim left whitespace
        if ($name eq "ltrim") {
            emit($cg, "strada_new_str(strada_ltrim(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # rtrim - trim right whitespace
        if ($name eq "rtrim") {
            emit($cg, "strada_new_str(strada_rtrim(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_new - create new C struct
        if ($name eq "sys::cstruct_new") {
            emit($cg, "strada_cstruct_new(\"struct\", ");
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_to_int(");
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_set_int - set int field in C struct
        if ($name eq "sys::cstruct_set_int") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_cstruct_set_int(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_get_int - get int field from C struct
        if ($name eq "sys::cstruct_get_int") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_int(strada_cstruct_get_int(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # reverse - reverse a string or array
        if ($name eq "reverse") {
            emit($cg, "strada_reverse_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # repeat - repeat a string
        if ($name eq "repeat") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_str(strada_repeat(strada_to_str(");
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }
        
        # replace_all - replace all occurrences
        if ($name eq "replace_all") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_str(strada_replace_all(strada_to_str(");
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # chomp - remove trailing newline
        if ($name eq "chomp") {
            emit($cg, "strada_new_str(strada_chomp(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # chop - remove last character
        if ($name eq "chop") {
            emit($cg, "strada_new_str(strada_chop(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_set_string - set string field in C struct
        if ($name eq "sys::cstruct_set_string") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_cstruct_set_string(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_set_double - set double field in C struct
        if ($name eq "sys::cstruct_set_double") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_cstruct_set_double(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_num(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cast_int - cast value to int
        if ($name eq "cast_int") {
            emit($cg, "strada_new_int(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # cast_num - cast value to num
        if ($name eq "cast_num") {
            emit($cg, "strada_new_num(strada_to_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # cast_str - cast value to str
        if ($name eq "cast_str") {
            emit($cg, "strada_new_str(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_get_string - get string field from C struct
        if ($name eq "sys::cstruct_get_string") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_str(strada_cstruct_get_string(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_get_double - get double field from C struct
        if ($name eq "sys::cstruct_get_double") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_num(strada_cstruct_get_double(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_ptr - get raw pointer from C struct
        if ($name eq "sys::cstruct_ptr") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_cstruct_ptr(");
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # OOP - bless($ref, "Package") - bless a reference into a package
        if ($name eq "bless") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_bless(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # OOP - blessed($ref) - get package name or undef
        if ($name eq "blessed") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_blessed(");
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # OOP - set_package("Name") - set current package context
        if ($name eq "set_package") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_set_package(strada_to_str(");
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # OOP - inherit("Parent") or inherit("Child", "Parent") - set up inheritance
        if ($name eq "inherit") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count == 1) {
                # Single arg: inherit from parent using current package
                emit($cg, "strada_inherit_from(strada_to_str(");
                gen_expression($cg, $args->[0]);
                emit($cg, "))");
            } else {
                # Two args: inherit(child, parent)
                emit($cg, "strada_inherit(strada_to_str(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, "))");
            }
            return;
        }

        # OOP - isa($obj, "Package") - check if object is of a type
        if ($name eq "isa") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_int(strada_isa(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # OOP - can($obj, "method") - check if object can do a method
        if ($name eq "can") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_int(strada_can(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # OOP - UNIVERSAL::isa($obj, "Package") - Perl-style type check
        if ($name eq "UNIVERSAL::isa") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_int(strada_isa(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # OOP - UNIVERSAL::can($obj, "method") - Perl-style method check
        if ($name eq "UNIVERSAL::can") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_int(strada_can(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # ============================================================
        # NEW LIBC FUNCTIONS
        # ============================================================

        # Additional File I/O
        if ($name eq "sys::fgetc") {
            emit($cg, "strada_fgetc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fputc") {
            emit($cg, "strada_fputc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fgets") {
            emit($cg, "strada_fgets(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fputs") {
            emit($cg, "strada_fputs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ferror") {
            emit($cg, "strada_ferror(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fileno") {
            emit($cg, "strada_fileno(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clearerr") {
            emit($cg, "strada_clearerr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Temporary files
        if ($name eq "sys::tmpfile") {
            emit($cg, "strada_tmpfile()");
            return;
        }

        if ($name eq "sys::mkstemp") {
            emit($cg, "strada_mkstemp(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mkdtemp") {
            emit($cg, "strada_mkdtemp(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Command execution (popen)
        if ($name eq "sys::popen") {
            emit($cg, "strada_popen(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::pclose") {
            emit($cg, "strada_pclose(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Additional file system
        if ($name eq "sys::truncate") {
            emit($cg, "strada_truncate(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ftruncate") {
            emit($cg, "strada_ftruncate(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::chown") {
            emit($cg, "strada_chown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::lchown") {
            emit($cg, "strada_lchown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fchmod") {
            emit($cg, "strada_fchmod(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fchown") {
            emit($cg, "strada_fchown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::utime") {
            emit($cg, "strada_utime(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::utimes") {
            emit($cg, "strada_utimes(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        # Session/process group control
        if ($name eq "sys::setsid") {
            emit($cg, "strada_setsid()");
            return;
        }

        if ($name eq "sys::getsid") {
            emit($cg, "strada_getsid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setpgid") {
            emit($cg, "strada_setpgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpgid") {
            emit($cg, "strada_getpgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpgrp") {
            emit($cg, "strada_getpgrp()");
            return;
        }

        if ($name eq "sys::setpgrp") {
            emit($cg, "strada_setpgrp()");
            return;
        }

        # User/group ID control
        if ($name eq "sys::setuid") {
            emit($cg, "strada_setuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setgid") {
            emit($cg, "strada_setgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::seteuid") {
            emit($cg, "strada_seteuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setegid") {
            emit($cg, "strada_setegid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setreuid") {
            emit($cg, "strada_setreuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setregid") {
            emit($cg, "strada_setregid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # Additional socket operations
        if ($name eq "sys::setsockopt") {
            emit($cg, "strada_setsockopt(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ", ");
            gen_expression($cg, $args->[3]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getsockopt") {
            emit($cg, "strada_getsockopt(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::shutdown") {
            emit($cg, "strada_shutdown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpeername") {
            emit($cg, "strada_getpeername(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getsockname") {
            emit($cg, "strada_getsockname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_pton") {
            emit($cg, "strada_inet_pton(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_ntop") {
            emit($cg, "strada_inet_ntop(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_addr") {
            emit($cg, "strada_inet_addr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_ntoa") {
            emit($cg, "strada_inet_ntoa(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::htons") {
            emit($cg, "strada_htons(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::htonl") {
            emit($cg, "strada_htonl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ntohs") {
            emit($cg, "strada_ntohs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ntohl") {
            emit($cg, "strada_ntohl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::poll") {
            emit($cg, "strada_poll(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # Random seeding
        if ($name eq "sys::srand") {
            emit($cg, "strada_srand(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::srandom") {
            emit($cg, "strada_srandom(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::rand") {
            emit($cg, "strada_libc_rand()");
            return;
        }

        if ($name eq "sys::random") {
            emit($cg, "strada_libc_random()");
            return;
        }

        # Advanced signals
        if ($name eq "sys::sigprocmask") {
            emit($cg, "strada_sigprocmask(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::raise") {
            emit($cg, "strada_raise(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::killpg") {
            emit($cg, "strada_killpg(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::pause") {
            emit($cg, "strada_pause()");
            return;
        }

        # User/Group database
        if ($name eq "sys::getpwnam") {
            emit($cg, "strada_getpwnam(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpwuid") {
            emit($cg, "strada_getpwuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getgrnam") {
            emit($cg, "strada_getgrnam(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getgrgid") {
            emit($cg, "strada_getgrgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getlogin") {
            emit($cg, "strada_getlogin()");
            return;
        }

        if ($name eq "sys::getgroups") {
            emit($cg, "strada_getgroups()");
            return;
        }

        # Resource/Priority
        if ($name eq "sys::nice") {
            emit($cg, "strada_nice(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpriority") {
            emit($cg, "strada_getpriority(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setpriority") {
            emit($cg, "strada_setpriority(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getrusage") {
            emit($cg, "strada_getrusage(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getrlimit") {
            emit($cg, "strada_getrlimit(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setrlimit") {
            emit($cg, "strada_setrlimit(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # Additional time functions
        if ($name eq "sys::difftime") {
            emit($cg, "strada_difftime(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clock") {
            emit($cg, "strada_clock()");
            return;
        }

        if ($name eq "sys::times") {
            emit($cg, "strada_times()");
            return;
        }

        # Additional memory functions
        if ($name eq "sys::calloc") {
            emit($cg, "strada_calloc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::realloc") {
            emit($cg, "strada_realloc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mmap") {
            emit($cg, "strada_mmap(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ", ");
            gen_expression($cg, $args->[3]);
            emit($cg, ", ");
            gen_expression($cg, $args->[4]);
            emit($cg, ", ");
            gen_expression($cg, $args->[5]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::munmap") {
            emit($cg, "strada_munmap(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mlock") {
            emit($cg, "strada_mlock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::munlock") {
            emit($cg, "strada_munlock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # String conversion
        if ($name eq "sys::strtol") {
            emit($cg, "strada_strtol(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::strtod") {
            emit($cg, "strada_strtod(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::atoi") {
            emit($cg, "strada_atoi(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::atof") {
            emit($cg, "strada_atof(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Terminal/TTY
        if ($name eq "sys::ttyname") {
            emit($cg, "strada_ttyname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::tcgetattr") {
            emit($cg, "strada_tcgetattr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::tcsetattr") {
            emit($cg, "strada_tcsetattr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfgetospeed") {
            emit($cg, "strada_cfgetospeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfsetospeed") {
            emit($cg, "strada_cfsetospeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfgetispeed") {
            emit($cg, "strada_cfgetispeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfsetispeed") {
            emit($cg, "strada_cfsetispeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # serial_open - high-level serial port open
        if ($name eq "sys::serial_open") {
            emit($cg, "strada_serial_open(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), ");
            if ($expr->{"arg_count"} > 2) {
                emit($cg, "strada_to_str(");
                gen_expression($cg, $args->[2]);
                emit($cg, ")");
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # tcflush - flush input/output queues
        if ($name eq "sys::tcflush") {
            emit($cg, "strada_tcflush(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # tcdrain - wait for output to be transmitted
        if ($name eq "sys::tcdrain") {
            emit($cg, "strada_tcdrain(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Baud rate constants
        if ($name eq "sys::B0") { emit($cg, "strada_new_int(B0)"); return; }
        if ($name eq "sys::B50") { emit($cg, "strada_new_int(B50)"); return; }
        if ($name eq "sys::B75") { emit($cg, "strada_new_int(B75)"); return; }
        if ($name eq "sys::B110") { emit($cg, "strada_new_int(B110)"); return; }
        if ($name eq "sys::B134") { emit($cg, "strada_new_int(B134)"); return; }
        if ($name eq "sys::B150") { emit($cg, "strada_new_int(B150)"); return; }
        if ($name eq "sys::B200") { emit($cg, "strada_new_int(B200)"); return; }
        if ($name eq "sys::B300") { emit($cg, "strada_new_int(B300)"); return; }
        if ($name eq "sys::B600") { emit($cg, "strada_new_int(B600)"); return; }
        if ($name eq "sys::B1200") { emit($cg, "strada_new_int(B1200)"); return; }
        if ($name eq "sys::B1800") { emit($cg, "strada_new_int(B1800)"); return; }
        if ($name eq "sys::B2400") { emit($cg, "strada_new_int(B2400)"); return; }
        if ($name eq "sys::B4800") { emit($cg, "strada_new_int(B4800)"); return; }
        if ($name eq "sys::B9600") { emit($cg, "strada_new_int(B9600)"); return; }
        if ($name eq "sys::B19200") { emit($cg, "strada_new_int(B19200)"); return; }
        if ($name eq "sys::B38400") { emit($cg, "strada_new_int(B38400)"); return; }
        if ($name eq "sys::B57600") { emit($cg, "strada_new_int(B57600)"); return; }
        if ($name eq "sys::B115200") { emit($cg, "strada_new_int(B115200)"); return; }
        if ($name eq "sys::B230400") { emit($cg, "strada_new_int(B230400)"); return; }
        if ($name eq "sys::B460800") { emit($cg, "strada_new_int(B460800)"); return; }
        if ($name eq "sys::B500000") { emit($cg, "strada_new_int(B500000)"); return; }
        if ($name eq "sys::B576000") { emit($cg, "strada_new_int(B576000)"); return; }
        if ($name eq "sys::B921600") { emit($cg, "strada_new_int(B921600)"); return; }
        if ($name eq "sys::B1000000") { emit($cg, "strada_new_int(B1000000)"); return; }
        if ($name eq "sys::B1152000") { emit($cg, "strada_new_int(B1152000)"); return; }
        if ($name eq "sys::B1500000") { emit($cg, "strada_new_int(B1500000)"); return; }
        if ($name eq "sys::B2000000") { emit($cg, "strada_new_int(B2000000)"); return; }

        # Termios control mode flags (c_cflag)
        if ($name eq "sys::CSIZE") { emit($cg, "strada_new_int(CSIZE)"); return; }
        if ($name eq "sys::CS5") { emit($cg, "strada_new_int(CS5)"); return; }
        if ($name eq "sys::CS6") { emit($cg, "strada_new_int(CS6)"); return; }
        if ($name eq "sys::CS7") { emit($cg, "strada_new_int(CS7)"); return; }
        if ($name eq "sys::CS8") { emit($cg, "strada_new_int(CS8)"); return; }
        if ($name eq "sys::CSTOPB") { emit($cg, "strada_new_int(CSTOPB)"); return; }
        if ($name eq "sys::CREAD") { emit($cg, "strada_new_int(CREAD)"); return; }
        if ($name eq "sys::PARENB") { emit($cg, "strada_new_int(PARENB)"); return; }
        if ($name eq "sys::PARODD") { emit($cg, "strada_new_int(PARODD)"); return; }
        if ($name eq "sys::HUPCL") { emit($cg, "strada_new_int(HUPCL)"); return; }
        if ($name eq "sys::CLOCAL") { emit($cg, "strada_new_int(CLOCAL)"); return; }
        if ($name eq "sys::CRTSCTS") { emit($cg, "strada_new_int(CRTSCTS)"); return; }

        # Termios input mode flags (c_iflag)
        if ($name eq "sys::IGNBRK") { emit($cg, "strada_new_int(IGNBRK)"); return; }
        if ($name eq "sys::BRKINT") { emit($cg, "strada_new_int(BRKINT)"); return; }
        if ($name eq "sys::IGNPAR") { emit($cg, "strada_new_int(IGNPAR)"); return; }
        if ($name eq "sys::PARMRK") { emit($cg, "strada_new_int(PARMRK)"); return; }
        if ($name eq "sys::INPCK") { emit($cg, "strada_new_int(INPCK)"); return; }
        if ($name eq "sys::ISTRIP") { emit($cg, "strada_new_int(ISTRIP)"); return; }
        if ($name eq "sys::INLCR") { emit($cg, "strada_new_int(INLCR)"); return; }
        if ($name eq "sys::IGNCR") { emit($cg, "strada_new_int(IGNCR)"); return; }
        if ($name eq "sys::ICRNL") { emit($cg, "strada_new_int(ICRNL)"); return; }
        if ($name eq "sys::IXON") { emit($cg, "strada_new_int(IXON)"); return; }
        if ($name eq "sys::IXOFF") { emit($cg, "strada_new_int(IXOFF)"); return; }
        if ($name eq "sys::IXANY") { emit($cg, "strada_new_int(IXANY)"); return; }

        # Termios output mode flags (c_oflag)
        if ($name eq "sys::OPOST") { emit($cg, "strada_new_int(OPOST)"); return; }
        if ($name eq "sys::ONLCR") { emit($cg, "strada_new_int(ONLCR)"); return; }
        if ($name eq "sys::OCRNL") { emit($cg, "strada_new_int(OCRNL)"); return; }

        # Termios local mode flags (c_lflag)
        if ($name eq "sys::ISIG") { emit($cg, "strada_new_int(ISIG)"); return; }
        if ($name eq "sys::ICANON") { emit($cg, "strada_new_int(ICANON)"); return; }
        if ($name eq "sys::ECHO") { emit($cg, "strada_new_int(ECHO)"); return; }
        if ($name eq "sys::ECHOE") { emit($cg, "strada_new_int(ECHOE)"); return; }
        if ($name eq "sys::ECHOK") { emit($cg, "strada_new_int(ECHOK)"); return; }
        if ($name eq "sys::ECHONL") { emit($cg, "strada_new_int(ECHONL)"); return; }
        if ($name eq "sys::NOFLSH") { emit($cg, "strada_new_int(NOFLSH)"); return; }
        if ($name eq "sys::TOSTOP") { emit($cg, "strada_new_int(TOSTOP)"); return; }
        if ($name eq "sys::IEXTEN") { emit($cg, "strada_new_int(IEXTEN)"); return; }

        # tcsetattr when values
        if ($name eq "sys::TCSANOW") { emit($cg, "strada_new_int(TCSANOW)"); return; }
        if ($name eq "sys::TCSADRAIN") { emit($cg, "strada_new_int(TCSADRAIN)"); return; }
        if ($name eq "sys::TCSAFLUSH") { emit($cg, "strada_new_int(TCSAFLUSH)"); return; }

        # tcflush queue selectors
        if ($name eq "sys::TCIFLUSH") { emit($cg, "strada_new_int(TCIFLUSH)"); return; }
        if ($name eq "sys::TCOFLUSH") { emit($cg, "strada_new_int(TCOFLUSH)"); return; }
        if ($name eq "sys::TCIOFLUSH") { emit($cg, "strada_new_int(TCIOFLUSH)"); return; }

        # File open flags (for low-level open)
        if ($name eq "sys::O_RDONLY") { emit($cg, "strada_new_int(O_RDONLY)"); return; }
        if ($name eq "sys::O_WRONLY") { emit($cg, "strada_new_int(O_WRONLY)"); return; }
        if ($name eq "sys::O_RDWR") { emit($cg, "strada_new_int(O_RDWR)"); return; }
        if ($name eq "sys::O_CREAT") { emit($cg, "strada_new_int(O_CREAT)"); return; }
        if ($name eq "sys::O_EXCL") { emit($cg, "strada_new_int(O_EXCL)"); return; }
        if ($name eq "sys::O_NOCTTY") { emit($cg, "strada_new_int(O_NOCTTY)"); return; }
        if ($name eq "sys::O_TRUNC") { emit($cg, "strada_new_int(O_TRUNC)"); return; }
        if ($name eq "sys::O_APPEND") { emit($cg, "strada_new_int(O_APPEND)"); return; }
        if ($name eq "sys::O_NONBLOCK") { emit($cg, "strada_new_int(O_NONBLOCK)"); return; }
        if ($name eq "sys::O_SYNC") { emit($cg, "strada_new_int(O_SYNC)"); return; }

        # Advanced file operations
        if ($name eq "sys::fcntl") {
            emit($cg, "strada_fcntl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 2) {
                gen_expression($cg, $args->[2]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::flock") {
            emit($cg, "strada_flock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ioctl") {
            emit($cg, "strada_ioctl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 2) {
                gen_expression($cg, $args->[2]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::statvfs") {
            emit($cg, "strada_statvfs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fstatvfs") {
            emit($cg, "strada_fstatvfs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dup") {
            emit($cg, "strada_dup(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Additional math functions
        if ($name eq "math::hypot") {
            emit($cg, "strada_hypot(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::cbrt") {
            emit($cg, "strada_cbrt(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::isnan") {
            emit($cg, "strada_isnan(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::isinf") {
            emit($cg, "strada_isinf(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::isfinite") {
            emit($cg, "strada_isfinite(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::fmax") {
            emit($cg, "strada_fmax(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::fmin") {
            emit($cg, "strada_fmin(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::copysign") {
            emit($cg, "strada_copysign(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::remainder") {
            emit($cg, "strada_remainder(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::trunc") {
            emit($cg, "strada_trunc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::ldexp") {
            emit($cg, "strada_ldexp(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::frexp") {
            emit($cg, "strada_frexp(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::modf") {
            emit($cg, "strada_modf(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::scalbn") {
            emit($cg, "strada_scalbn(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # User-defined function - check for default parameters
        my str $c_name = sanitize_name($name);
        my scalar $func_info = $cg->{"functions"}->{$c_name};
        my scalar $args = $expr->{"args"};
        my int $arg_count = $expr->{"arg_count"};

        # Check if any arguments need temp cleanup (anonymous values)
        my int $needs_temps = 0;
        my int $check_i = 0;
        while ($check_i < $arg_count) {
            if (needs_temp_cleanup($args->[$check_i]) == 1) {
                $needs_temps = 1;
            }
            $check_i = $check_i + 1;
        }

        if ($needs_temps == 1) {
            # Check if function returns void
            # Default to non-void when we don't have func_info (safer - allows use in expression context)
            my int $returns_void = 0;
            if ($func_info) {
                my int $ret_type = $func_info->{"return_type"};
                if ($ret_type == TYPE_VOID()) {
                    $returns_void = 1;
                }
            }

            # Generate block with temp variables for cleanup
            emit($cg, "({ ");
            # Declare temps for args that need cleanup
            my int $t = 0;
            while ($t < $arg_count) {
                if (needs_temp_cleanup($args->[$t]) == 1) {
                    emit($cg, "StradaValue *__arg" . $t . " = ");
                    gen_expression($cg, $args->[$t]);
                    emit($cg, "; ");
                }
                $t = $t + 1;
            }
            # Emit the function call, storing result if not void
            if ($returns_void == 0) {
                emit($cg, "StradaValue *__call_result = ");
            }
            emit($cg, $c_name . "(");
            if ($func_info) {
                my int $param_count = $func_info->{"param_count"};
                my scalar $params = $func_info->{"params"};
                my int $i = 0;
                while ($i < $param_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    if ($i < $arg_count) {
                        if (needs_temp_cleanup($args->[$i]) == 1) {
                            emit($cg, "__arg" . $i);
                        } else {
                            gen_expression($cg, $args->[$i]);
                        }
                    } else {
                        my scalar $param = $params->[$i];
                        if ($param->{"has_default"} == 1) {
                            gen_expression($cg, $param->{"default"});
                        } else {
                            emit($cg, "strada_new_undef()");
                        }
                    }
                    $i = $i + 1;
                }
            } else {
                my int $i = 0;
                while ($i < $arg_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    if (needs_temp_cleanup($args->[$i]) == 1) {
                        emit($cg, "__arg" . $i);
                    } else {
                        gen_expression($cg, $args->[$i]);
                    }
                    $i = $i + 1;
                }
            }
            emit($cg, "); ");
            # Decref temps
            my int $d = 0;
            while ($d < $arg_count) {
                if (needs_temp_cleanup($args->[$d]) == 1) {
                    emit($cg, "strada_decref(__arg" . $d . "); ");
                }
                $d = $d + 1;
            }
            # Return result if not void
            if ($returns_void == 0) {
                emit($cg, "__call_result; })");
            } else {
                emit($cg, "})");
            }
        } else {
            # No temps needed, simple call
            emit($cg, $c_name . "(");
            if ($func_info) {
                my int $param_count = $func_info->{"param_count"};
                my scalar $params = $func_info->{"params"};
                my int $i = 0;
                while ($i < $param_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    if ($i < $arg_count) {
                        gen_expression($cg, $args->[$i]);
                    } else {
                        my scalar $param = $params->[$i];
                        if ($param->{"has_default"} == 1) {
                            gen_expression($cg, $param->{"default"});
                        } else {
                            emit($cg, "strada_new_undef()");
                        }
                    }
                    $i = $i + 1;
                }
            } else {
                my int $i = 0;
                while ($i < $arg_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    gen_expression($cg, $args->[$i]);
                    $i = $i + 1;
                }
            }
            emit($cg, ")");
        }
        return;
    }
    
    # Assignment
    if ($type == NODE_ASSIGN()) {
        my str $op = $expr->{"op"};
        my scalar $target = $expr->{"target"};
        my int $target_type = $target->{"type"};
        
        if ($op eq "=") {
            # Special case: hash assignment %hash{key} = value
            # strada_hash_set handles incref internally for shared ownership
            # For anonymous values, we need to decref after hash_set takes ownership
            if ($target_type == NODE_HASH_ACCESS()) {
                my scalar $val = $expr->{"value"};
                my int $val_type = $val->{"type"};
                # Check if value is anonymous (needs decref after storing)
                my int $is_anonymous = 0;
                if ($val_type == NODE_ANON_ARRAY() || $val_type == NODE_ANON_HASH() ||
                    $val_type == NODE_INT_LITERAL() || $val_type == NODE_NUM_LITERAL() ||
                    $val_type == NODE_STR_LITERAL() || $val_type == NODE_CALL() ||
                    $val_type == NODE_REF() || $val_type == NODE_METHOD_CALL()) {
                    $is_anonymous = 1;
                }
                if ($is_anonymous == 1) {
                    # Anonymous value: store in temp, hash_set takes shared ownership, then release our copy
                    emit($cg, "({ StradaValue *__hset_v = ");
                    # Handle empty () which parser returns as anon_hash
                    if ($val_type == NODE_ANON_HASH() && $val->{"pair_count"} == 0) {
                        emit($cg, "strada_new_hash()");
                    } else {
                        gen_expression($cg, $val);
                    }
                    emit($cg, "; strada_hash_set(strada_deref_hash(");
                    gen_expression($cg, $target->{"hash"});
                    emit($cg, "), strada_to_str(");
                    gen_expression($cg, $target->{"key"});
                    emit($cg, "), __hset_v); strada_decref(__hset_v); })");
                } else {
                    # Borrowed value: just pass to hash_set which handles incref
                    emit($cg, "strada_hash_set(strada_deref_hash(");
                    gen_expression($cg, $target->{"hash"});
                    emit($cg, "), strada_to_str(");
                    gen_expression($cg, $target->{"key"});
                    emit($cg, "), ");
                    gen_expression($cg, $val);
                    emit($cg, ")");
                }
                return;
            }
            # Special case: hash deref assignment $ref->{key} = value
            # strada_hash_set handles incref internally for shared ownership
            # For anonymous values, we need to decref after hash_set takes ownership
            if ($target_type == NODE_DEREF_HASH()) {
                my scalar $val = $expr->{"value"};
                my int $val_type = $val->{"type"};
                # Check if value is anonymous (needs decref after storing)
                my int $is_anonymous = 0;
                if ($val_type == NODE_ANON_ARRAY() || $val_type == NODE_ANON_HASH() ||
                    $val_type == NODE_INT_LITERAL() || $val_type == NODE_NUM_LITERAL() ||
                    $val_type == NODE_STR_LITERAL() || $val_type == NODE_CALL() ||
                    $val_type == NODE_REF() || $val_type == NODE_METHOD_CALL()) {
                    $is_anonymous = 1;
                }
                if ($is_anonymous == 1) {
                    # Anonymous value: store in temp, hash_set takes shared ownership, then release our copy
                    emit($cg, "({ StradaValue *__hset_v = ");
                    gen_expression($cg, $val);
                    emit($cg, "; strada_hash_set(strada_deref_hash(");
                    gen_expression($cg, $target->{"ref"});
                    emit($cg, "), strada_to_str(");
                    gen_expression($cg, $target->{"key"});
                    emit($cg, "), __hset_v); strada_decref(__hset_v); })");
                } else {
                    # Borrowed value: just pass to hash_set which handles incref
                    emit($cg, "strada_hash_set(strada_deref_hash(");
                    gen_expression($cg, $target->{"ref"});
                    emit($cg, "), strada_to_str(");
                    gen_expression($cg, $target->{"key"});
                    emit($cg, "), ");
                    gen_expression($cg, $val);
                    emit($cg, ")");
                }
                return;
            }
            # Special case: array subscript assignment @arr[idx] = value
            if ($target_type == NODE_SUBSCRIPT()) {
                emit($cg, "strada_array_set(strada_deref_array(");
                gen_expression($cg, $target->{"array"});
                emit($cg, "), strada_to_int(");
                gen_expression($cg, $target->{"index"});
                emit($cg, "), ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")");
                return;
            }
            # Special case: array deref assignment $ref->[idx] = value
            if ($target_type == NODE_DEREF_ARRAY()) {
                emit($cg, "strada_array_set(strada_deref_array(");
                gen_expression($cg, $target->{"ref"});
                emit($cg, "), strada_to_int(");
                gen_expression($cg, $target->{"index"});
                emit($cg, "), ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")");
                return;
            }
            # Special case: scalar deref assignment $$ref = value
            if ($target_type == NODE_DEREF_SCALAR()) {
                emit($cg, "strada_deref_set(");
                gen_expression($cg, $target->{"ref"});
                emit($cg, ", ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")");
                return;
            }
            # Special case: assigning scalar to array variable @arr = ($x)
            if ($target_type == NODE_VARIABLE() && $target->{"sigil"} eq "@") {
                my scalar $val = $expr->{"value"};
                my int $val_type = $val->{"type"};
                if ($val_type == NODE_ANON_HASH() && $val->{"pair_count"} == 0) {
                    # Empty () - clear and reset array
                    gen_expression($cg, $target);
                    emit($cg, " = strada_new_array()");
                } elsif ($val_type == NODE_ANON_ARRAY()) {
                    # Array literal [1, 2, 3] - assign directly
                    gen_expression($cg, $target);
                    emit($cg, " = ");
                    gen_expression($cg, $val);
                } elsif (is_scalar_expr($val)) {
                    # Single scalar - wrap in array
                    gen_expression($cg, $target);
                    emit($cg, " = strada_new_array(); strada_array_push(");
                    gen_expression($cg, $target);
                    emit($cg, "->value.av, ");
                    gen_expression($cg, $val);
                    emit($cg, ")");
                } else {
                    # Assume value returns an array
                    gen_expression($cg, $target);
                    emit($cg, " = ");
                    gen_expression($cg, $val);
                }
                return;
            }
            # Normal assignment with reference counting
            # Runtime returns owned references, so we just decref the old value
            # For variable-to-variable copy, need to incref since we're sharing
            my scalar $rhs = $expr->{"value"};
            my int $rhs_type = $rhs->{"type"};
            my int $rhs_is_var = 0;
            if ($rhs_type == NODE_VARIABLE()) {
                $rhs_is_var = 1;
            }
            if ($target_type == NODE_VARIABLE() && $cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__old = ");
                gen_expression($cg, $target);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = ");
                gen_expression($cg, $rhs);
                emit($cg, "; ");
                # Incref only for variable-to-variable copy
                if ($rhs_is_var == 1) {
                    emit($cg, "strada_incref(");
                    gen_expression($cg, $target);
                    emit($cg, "); ");
                }
                emit($cg, "strada_decref(__old); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = ");
                gen_expression($cg, $rhs);
            }
        } elsif ($op eq "+=") {
            if ($target_type == NODE_VARIABLE() && $cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__old = ");
                gen_expression($cg, $target);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(__old) + strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")); strada_decref(__old); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(");
                gen_expression($cg, $target);
                emit($cg, ") + strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, "))");
            }
        } elsif ($op eq "-=") {
            if ($target_type == NODE_VARIABLE() && $cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__old = ");
                gen_expression($cg, $target);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(__old) - strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")); strada_decref(__old); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(");
                gen_expression($cg, $target);
                emit($cg, ") - strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, "))");
            }
        } elsif ($op eq ".=") {
            if ($target_type == NODE_VARIABLE() && $cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__old = ");
                gen_expression($cg, $target);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = strada_concat_sv(__old, ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, "); strada_decref(__old); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = strada_concat_sv(");
                gen_expression($cg, $target);
                emit($cg, ", ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")");
            }
        }
        return;
    }
    
    # Array subscript - use strada_deref_array to handle both direct arrays and refs
    if ($type == NODE_SUBSCRIPT()) {
        emit($cg, "strada_array_get(strada_deref_array(");
        gen_expression($cg, $expr->{"array"});
        emit($cg, "), strada_to_int(");
        gen_expression($cg, $expr->{"index"});
        emit($cg, "))");
        return;
    }
    
    # Hash access - use strada_deref_hash to handle both direct hashes and refs
    if ($type == NODE_HASH_ACCESS()) {
        emit($cg, "strada_hash_get(strada_deref_hash(");
        gen_expression($cg, $expr->{"hash"});
        emit($cg, "), strada_to_str(");
        gen_expression($cg, $expr->{"key"});
        emit($cg, "))");
        return;
    }
    
    # Reference
    if ($type == NODE_REF()) {
        my str $ref_type = $expr->{"ref_type"};
        if ($ref_type eq "&") {
            # Function reference - use strada_cpointer_new
            emit($cg, "strada_cpointer_new((void*)");
            gen_expression($cg, $expr->{"target"});
            emit($cg, ")");
        } else {
            emit($cg, "strada_new_ref(");
            gen_expression($cg, $expr->{"target"});
            emit($cg, ", '");
            emit($cg, $ref_type);
            emit($cg, "')");
        }
        return;
    }
    
    # Hash dereference
    if ($type == NODE_DEREF_HASH()) {
        emit($cg, "strada_hash_get(strada_deref_hash(");
        gen_expression($cg, $expr->{"ref"});
        emit($cg, "), strada_to_str(");
        gen_expression($cg, $expr->{"key"});
        emit($cg, "))");
        return;
    }
    
    # Array dereference
    if ($type == NODE_DEREF_ARRAY()) {
        emit($cg, "strada_array_get(strada_deref_array(");
        gen_expression($cg, $expr->{"ref"});
        emit($cg, "), strada_to_int(");
        gen_expression($cg, $expr->{"index"});
        emit($cg, "))");
        return;
    }
    
    # Scalar/Array/Hash dereference (@{}, %{}, $$)
    if ($type == NODE_DEREF_SCALAR()) {
        my str $sigil = $expr->{"sigil"};
        if ($sigil eq "@") {
            emit($cg, "strada_deref_array_value(");
        } elsif ($sigil eq "%") {
            emit($cg, "strada_deref_hash_value(");
        } else {
            emit($cg, "strada_deref(");
        }
        gen_expression($cg, $expr->{"ref"});
        emit($cg, ")");
        return;
    }
    
    # Field access (obj->field)
    if ($type == NODE_FIELD_ACCESS()) {
        gen_expression($cg, $expr->{"object"});
        emit($cg, "->" . $expr->{"field"});
        return;
    }
    
    # Function reference (&func_name)
    if ($type == NODE_FUNC_REF()) {
        emit($cg, "&" . $expr->{"name"});
        return;
    }
    
    # Method call ($obj->method(args)) - Perl-style blessed reference method dispatch
    # OR struct function pointer call ($struct->funcptr(args))
    if ($type == NODE_METHOD_CALL()) {
        my int $arg_count = $expr->{"arg_count"};
        my str $method = $expr->{"method"};
        my scalar $obj = $expr->{"object"};

        # Check if this is a struct function pointer call
        # The object will be a FIELD_ACCESS node (e.g., $calc->operation)
        # whose object is a VAR_REF to a struct variable
        my int $is_funcptr_call = 0;
        if ($obj->{"type"} == NODE_FIELD_ACCESS()) {
            my scalar $struct_obj = $obj->{"object"};
            if ($struct_obj->{"type"} == NODE_VARIABLE()) {
                my str $var_name = $struct_obj->{"name"};
                my scalar $struct_vars = $cg->{"struct_vars"};
                if ($struct_vars->{$var_name}) {
                    my str $struct_type = $struct_vars->{$var_name};
                    my scalar $struct_defs = $cg->{"struct_defs"};
                    if ($struct_defs->{$struct_type}) {
                        my scalar $struct_info = $struct_defs->{$struct_type};
                        my scalar $field_info = $struct_info->{"fields"}->{$method};
                        if ($field_info && $field_info->{"is_funcptr"}) {
                            $is_funcptr_call = 1;
                        }
                    }
                }
            }
        }

        if ($is_funcptr_call) {
            # Generate direct function pointer call with proper cast
            # ((StradaValue*(*)(StradaValue*, ...))ptr)(arg1, arg2, ...)
            emit($cg, "((StradaValue*(*)(");
            if ($arg_count == 0) {
                emit($cg, "void");
            } else {
                my int $p = 0;
                while ($p < $arg_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    emit($cg, "StradaValue*");
                    $p = $p + 1;
                }
            }
            emit($cg, "))");
            gen_expression($cg, $obj);
            emit($cg, ")(");
            my scalar $args = $expr->{"args"};
            my int $i = 0;
            while ($i < $arg_count) {
                if ($i > 0) {
                    emit($cg, ", ");
                }
                gen_expression($cg, $args->[$i]);
                $i = $i + 1;
            }
            emit($cg, ")");
        } else {
            # OOP method call - use base_object (the original object, not field access)
            # Generate: strada_method_call(obj, "method", strada_pack_args(count, arg1, arg2, ...))
            emit($cg, "strada_method_call(");
            # Use base_object if available (set by parser for ->method() calls)
            my scalar $base_obj = $expr->{"base_object"};
            if ($base_obj) {
                gen_expression($cg, $base_obj);
            } else {
                gen_expression($cg, $obj);
            }
            emit($cg, ", \"" . $method . "\", strada_pack_args(" . $arg_count);

            my scalar $args = $expr->{"args"};
            my int $i = 0;
            while ($i < $arg_count) {
                emit($cg, ", ");
                gen_expression($cg, $args->[$i]);
                $i = $i + 1;
            }
            emit($cg, "))");
        }
        return;
    }

    # SUPER::method($self, args...) - calls parent method
    if ($type == NODE_SUPER_CALL()) {
        my int $arg_count = $expr->{"arg_count"};
        my str $method = $expr->{"method"};
        my scalar $args = $expr->{"args"};

        # SUPER::method requires at least one argument (the object/self)
        if ($arg_count < 1) {
            emit($cg, "strada_new_undef() /* SUPER call requires self argument */");
            return;
        }

        # Generate: strada_super_call(self, __PACKAGE__, "method", strada_pack_args(remaining...))
        emit($cg, "strada_super_call(");

        # First argument is self/object
        gen_expression($cg, $args->[0]);

        # Use compile-time package for SUPER resolution (not runtime strada_current_package())
        my str $fn_pkg = $cg->{"current_fn_package"};
        emit($cg, ", \"" . $fn_pkg . "\", \"" . $method . "\", strada_pack_args(");

        # Remaining arguments (skip first which is $self)
        my int $remaining = $arg_count - 1;
        emit($cg, "" . $remaining);

        my int $i = 1;
        while ($i < $arg_count) {
            emit($cg, ", ");
            gen_expression($cg, $args->[$i]);
            $i = $i + 1;
        }
        emit($cg, "))");
        return;
    }

    # __PACKAGE__ - returns current package name
    if ($type == NODE_DUNDER_PACKAGE()) {
        emit($cg, "strada_new_str(strada_current_package() ? strada_current_package() : \"\")");
        return;
    }

    # __FILE__ - returns current file name
    if ($type == NODE_DUNDER_FILE()) {
        my str $filename = $cg->{"filename"};
        emit($cg, "strada_new_str(\"" . $filename . "\")");
        return;
    }

    # __LINE__ - returns current line number
    if ($type == NODE_DUNDER_LINE()) {
        my int $line = $expr->{"line_value"};
        emit($cg, "strada_new_int(" . $line . ")");
        return;
    }

    # Anonymous hash
    if ($type == NODE_ANON_HASH()) {
        emit($cg, "strada_anon_hash(" . $expr->{"pair_count"});
        my scalar $keys = $expr->{"keys"};
        my scalar $values = $expr->{"values"};
        my int $i = 0;
        while ($i < $expr->{"pair_count"}) {
            emit($cg, ", \"" . $keys->[$i] . "\", ");
            gen_expression($cg, $values->[$i]);
            $i = $i + 1;
        }
        emit($cg, ")");
        return;
    }
    
    # Anonymous array
    if ($type == NODE_ANON_ARRAY()) {
        emit($cg, "strada_anon_array(" . $expr->{"element_count"});
        my scalar $elems = $expr->{"elements"};
        my int $i = 0;
        while ($i < $expr->{"element_count"}) {
            emit($cg, ", ");
            gen_expression($cg, $elems->[$i]);
            $i = $i + 1;
        }
        emit($cg, ")");
        return;
    }

    # Map expression: map { block } @array
    if ($type == NODE_MAP()) {
        my scalar $block = $expr->{"block"};
        my scalar $array_expr = $expr->{"array"};
        my int $map_id = $cg->{"map_counter"};
        $cg->{"map_counter"} = $map_id + 1;

        emit($cg, "({ ");
        emit($cg, "StradaArray *__map_input_" . $map_id . " = strada_deref_array(");
        gen_expression($cg, $array_expr);
        emit($cg, "); ");
        emit($cg, "StradaValue *__map_result_" . $map_id . " = strada_new_array(); ");
        emit($cg, "int __map_len_" . $map_id . " = strada_array_length(__map_input_" . $map_id . "); ");
        emit($cg, "for (int __map_i_" . $map_id . " = 0; __map_i_" . $map_id . " < __map_len_" . $map_id . "; __map_i_" . $map_id . "++) { ");
        emit($cg, "StradaValue *__elem_ = strada_array_get(__map_input_" . $map_id . ", __map_i_" . $map_id . "); ");

        # Set flag to enable $_ magic variable
        $cg->{"in_map_block"} = 1;

        # Generate block - the last statement's expression is the result
        my scalar $stmts = $block->{"statements"};
        my int $stmt_count = $block->{"statement_count"};
        if ($stmt_count > 0) {
            # Handle all but last statement normally
            my int $i = 0;
            while ($i < $stmt_count - 1) {
                gen_statement($cg, $stmts->[$i]);
                $i = $i + 1;
            }
            # Last statement - extract its expression for the result
            my scalar $last_stmt = $stmts->[$stmt_count - 1];
            if ($last_stmt->{"type"} == NODE_EXPR_STMT()) {
                emit($cg, "strada_array_push(strada_deref_array(__map_result_" . $map_id . "), ");
                gen_expression($cg, $last_stmt->{"expr"});
                emit($cg, "); ");
            }
        }

        # Reset flag
        $cg->{"in_map_block"} = 0;

        emit($cg, "} ");
        emit($cg, "__map_result_" . $map_id . "; })");
        return;
    }

    # Sort expression: sort { $a <=> $b } @array
    if ($type == NODE_SORT()) {
        my scalar $block = $expr->{"block"};
        my scalar $array_expr = $expr->{"array"};

        # Default sort (no block)
        if (!$block) {
            emit($cg, "strada_sort(");
            gen_expression($cg, $array_expr);
            emit($cg, ")");
            return;
        }

        # Custom sort with comparator block
        my int $sort_id = $cg->{"sort_counter"};
        $cg->{"sort_counter"} = $sort_id + 1;

        emit($cg, "({ ");
        emit($cg, "StradaArray *__sort_input_" . $sort_id . " = strada_deref_array(");
        gen_expression($cg, $array_expr);
        emit($cg, "); ");
        emit($cg, "int __sort_len_" . $sort_id . " = strada_array_length(__sort_input_" . $sort_id . "); ");
        emit($cg, "StradaValue *__sort_result_" . $sort_id . " = strada_new_array(); ");
        # Copy elements to result
        emit($cg, "for (int __si_" . $sort_id . " = 0; __si_" . $sort_id . " < __sort_len_" . $sort_id . "; __si_" . $sort_id . "++) { ");
        emit($cg, "strada_array_push(strada_deref_array(__sort_result_" . $sort_id . "), strada_array_get(__sort_input_" . $sort_id . ", __si_" . $sort_id . ")); } ");
        # Bubble sort with custom comparator (simple implementation)
        emit($cg, "for (int __i_" . $sort_id . " = 0; __i_" . $sort_id . " < __sort_len_" . $sort_id . " - 1; __i_" . $sort_id . "++) { ");
        emit($cg, "for (int __j_" . $sort_id . " = 0; __j_" . $sort_id . " < __sort_len_" . $sort_id . " - __i_" . $sort_id . " - 1; __j_" . $sort_id . "++) { ");
        emit($cg, "StradaValue *__sort_a_ = strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . "); ");
        emit($cg, "StradaValue *__sort_b_ = strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . " + 1); ");
        emit($cg, "int __cmp_" . $sort_id . " = strada_to_int(");

        # Set flag to enable $a/$b magic variables
        $cg->{"in_sort_block"} = 1;

        # Generate comparator block - extract the comparison expression
        my scalar $stmts = $block->{"statements"};
        my int $stmt_count = $block->{"statement_count"};
        if ($stmt_count > 0) {
            my scalar $last_stmt = $stmts->[$stmt_count - 1];
            if ($last_stmt->{"type"} == NODE_EXPR_STMT()) {
                gen_expression($cg, $last_stmt->{"expr"});
            }
        }

        # Reset flag
        $cg->{"in_sort_block"} = 0;

        emit($cg, "); ");
        emit($cg, "if (__cmp_" . $sort_id . " > 0) { ");
        emit($cg, "StradaValue *__tmp_" . $sort_id . " = strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . "); ");
        emit($cg, "strada_array_set(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . ", strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . " + 1)); ");
        emit($cg, "strada_array_set(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . " + 1, __tmp_" . $sort_id . "); ");
        emit($cg, "} } } ");
        emit($cg, "__sort_result_" . $sort_id . "; })");
        return;
    }

    # Grep expression: grep { block } @array
    if ($type == NODE_GREP()) {
        my scalar $block = $expr->{"block"};
        my scalar $array_expr = $expr->{"array"};
        my int $grep_id = $cg->{"grep_counter"};
        $cg->{"grep_counter"} = $grep_id + 1;

        emit($cg, "({ ");
        emit($cg, "StradaArray *__grep_input_" . $grep_id . " = strada_deref_array(");
        gen_expression($cg, $array_expr);
        emit($cg, "); ");
        emit($cg, "StradaValue *__grep_result_" . $grep_id . " = strada_new_array(); ");
        emit($cg, "int __grep_len_" . $grep_id . " = strada_array_length(__grep_input_" . $grep_id . "); ");
        emit($cg, "for (int __grep_i_" . $grep_id . " = 0; __grep_i_" . $grep_id . " < __grep_len_" . $grep_id . "; __grep_i_" . $grep_id . "++) { ");
        emit($cg, "StradaValue *__elem_ = strada_array_get(__grep_input_" . $grep_id . ", __grep_i_" . $grep_id . "); ");
        emit($cg, "if (strada_to_bool(");

        # Set flag to enable $_ magic variable
        $cg->{"in_grep_block"} = 1;

        # Generate block - evaluate to boolean
        my scalar $stmts = $block->{"statements"};
        my int $stmt_count = $block->{"statement_count"};
        if ($stmt_count > 0) {
            my scalar $last_stmt = $stmts->[$stmt_count - 1];
            if ($last_stmt->{"type"} == NODE_EXPR_STMT()) {
                gen_expression($cg, $last_stmt->{"expr"});
            }
        }

        # Reset flag
        $cg->{"in_grep_block"} = 0;

        emit($cg, ")) { ");
        emit($cg, "strada_array_push(strada_deref_array(__grep_result_" . $grep_id . "), __elem_); } ");
        emit($cg, "} ");
        emit($cg, "__grep_result_" . $grep_id . "; })");
        return;
    }

    # Anonymous function
    if ($type == NODE_ANON_FUNC()) {
        my int $id = $cg->{"anon_func_counter"};
        $cg->{"anon_func_counter"} = $id + 1;
        my str $func_name = "__anon_func_" . $id;

        my scalar $params = $expr->{"params"};
        my int $param_count = $expr->{"param_count"};

        # Save current capture state (for nested closures)
        my int $saved_in_anon = $cg->{"in_anon_func"};
        my str $saved_param_str = $cg->{"anon_param_str"};
        my str $saved_local_str = $cg->{"anon_local_str"};
        my str $saved_capture_str = $cg->{"anon_capture_str"};
        my int $saved_capture_count = $cg->{"anon_capture_count"};

        # Set up capture context for this closure
        $cg->{"in_anon_func"} = 1;
        $cg->{"anon_local_str"} = "";
        $cg->{"anon_capture_str"} = "";
        $cg->{"anon_capture_count"} = 0;

        # Build param string from parameters
        my str $param_str = "";
        my int $i = 0;
        while ($i < $param_count) {
            my scalar $p = $params->[$i];
            if ($param_str eq "") {
                $param_str = $p->{"name"};
            } else {
                $param_str = $param_str . "," . $p->{"name"};
            }
            $i = $i + 1;
        }
        $cg->{"anon_param_str"} = $param_str;

        # Generate forward declaration (triple pointer for capture-by-reference)
        my str $decl = "StradaValue* " . $func_name . "(StradaValue ***__captures";
        $i = 0;
        while ($i < $param_count) {
            my scalar $p = $params->[$i];
            $decl = $decl . ", StradaValue *" . $p->{"name"};
            $i = $i + 1;
        }
        $decl = $decl . ")";
        $cg->{"anon_func_decls"} = $cg->{"anon_func_decls"} . $decl . ";\n";

        my str $def = $decl . " {\n";

        # Save current output (using StringBuilder)
        my str $saved_output = sb_to_string($cg->{"output_sb"});
        my int $saved_indent = $cg->{"indent"};
        my int $saved_in_main = $cg->{"in_main"};

        # Save scope state (closures are separate functions with their own scope)
        my scalar $saved_scope_vars = $cg->{"scope_vars"};
        my scalar $saved_scope_counts = $cg->{"scope_counts"};
        my int $saved_scope_depth = $cg->{"scope_depth"};

        # Start fresh for function body (closures are NOT main)
        sb_clear($cg->{"output_sb"});
        $cg->{"indent"} = 1;
        $cg->{"in_main"} = 0;

        # Reset scope for closure (it's a new function)
        my array @new_scope_vars = ();
        my array @new_scope_counts = ();
        $cg->{"scope_vars"} = \@new_scope_vars;
        $cg->{"scope_counts"} = \@new_scope_counts;
        $cg->{"scope_depth"} = 0;

        # Generate body (this will populate capture_str as variables are accessed)
        my scalar $body = $expr->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $stmt_count = $body->{"statement_count"};
        $i = 0;
        while ($i < $stmt_count) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Get body content
        my str $body_content = sb_to_string($cg->{"output_sb"});
        $def = $def . $body_content;
        $def = $def . "}\n\n";

        # Capture the capture info before restoring state
        my str $capture_str = $cg->{"anon_capture_str"};
        my int $capture_count = $cg->{"anon_capture_count"};

        # Restore output (using StringBuilder)
        sb_clear($cg->{"output_sb"});
        sb_append($cg->{"output_sb"}, $saved_output);
        $cg->{"indent"} = $saved_indent;
        $cg->{"in_main"} = $saved_in_main;

        # Restore scope state
        $cg->{"scope_vars"} = $saved_scope_vars;
        $cg->{"scope_counts"} = $saved_scope_counts;
        $cg->{"scope_depth"} = $saved_scope_depth;

        # Restore capture state
        $cg->{"in_anon_func"} = $saved_in_anon;
        $cg->{"anon_param_str"} = $saved_param_str;
        $cg->{"anon_local_str"} = $saved_local_str;
        $cg->{"anon_capture_str"} = $saved_capture_str;
        $cg->{"anon_capture_count"} = $saved_capture_count;

        $cg->{"anon_func_defs"} = $cg->{"anon_func_defs"} . $def;

        # Emit closure creation with captures (using double pointers for capture-by-reference)
        if ($capture_count == 0) {
            emit($cg, "strada_closure_new((void*)&" . $func_name . ", " . $param_count . ", 0, NULL)");
        } else {
            # Build capture array inline with addresses for capture-by-reference
            emit($cg, "strada_closure_new((void*)&" . $func_name . ", " . $param_count . ", " . $capture_count . ", ");
            emit($cg, "(StradaValue**[]){");
            # Parse capture_str to emit address of each captured variable
            my int $cap_idx = 0;
            my int $start = 0;
            my int $len = length($capture_str);
            $i = 0;
            while ($i <= $len) {
                my str $ch = "";
                if ($i < $len) { $ch = substr($capture_str, $i, 1); }
                if ($ch eq "," || $i == $len) {
                    if ($cap_idx > 0) { emit($cg, ", "); }
                    my str $cap_name = substr($capture_str, $start, $i - $start);
                    emit($cg, "&" . $cap_name);
                    $cap_idx = $cap_idx + 1;
                    $start = $i + 1;
                }
                $i = $i + 1;
            }
            emit($cg, "})");
        }
        return;
    }

    # Closure call
    if ($type == NODE_CLOSURE_CALL()) {
        emit($cg, "strada_closure_call(");
        gen_expression($cg, $expr->{"closure"});
        my scalar $args = $expr->{"args"};
        my int $arg_count = $expr->{"arg_count"};
        emit($cg, ", " . $arg_count);
        my int $i = 0;
        while ($i < $arg_count) {
            emit($cg, ", ");
            gen_expression($cg, $args->[$i]);
            $i = $i + 1;
        }
        emit($cg, ")");
        return;
    }

    # Ternary expression: cond ? true_expr : false_expr
    if ($type == NODE_TERNARY()) {
        emit($cg, "(");
        emit_condition($cg, $expr->{"condition"});
        emit($cg, " ? ");
        gen_expression($cg, $expr->{"true_expr"});
        emit($cg, " : ");
        gen_expression($cg, $expr->{"false_expr"});
        emit($cg, ")");
        return;
    }

    # Range expression: start..end
    if ($type == NODE_RANGE()) {
        emit($cg, "strada_range(");
        gen_expression($cg, $expr->{"start"});
        emit($cg, ", ");
        gen_expression($cg, $expr->{"end"});
        emit($cg, ")");
        return;
    }
}

# ============================================================
# Statement Code Generation
# ============================================================

func gen_block(scalar $cg, scalar $block) void {
    emit($cg, "{\n");
    indent($cg);
    scope_push($cg);

    my scalar $stmts = $block->{"statements"};
    my int $i = 0;
    while ($i < $block->{"statement_count"}) {
        gen_statement($cg, $stmts->[$i]);
        $i = $i + 1;
    }

    scope_pop($cg);
    dedent($cg);
    emit_indent($cg);
    emit($cg, "}");
}

func gen_statement(scalar $cg, scalar $stmt) void {
    # Emit #line directive for source-level debugging
    emit_line_for_stmt($cg, $stmt);

    my int $type = $stmt->{"type"};

    # Variable declaration
    if ($type == NODE_VAR_DECL()) {
        emit_indent($cg);

        # Track local variables when inside anonymous function
        if ($cg->{"in_anon_func"}) {
            my str $var_name = $stmt->{"name"};
            my str $local_str = $cg->{"anon_local_str"};
            if ($local_str eq "") {
                $cg->{"anon_local_str"} = $var_name;
            } else {
                $cg->{"anon_local_str"} = $local_str . "," . $var_name;
            }
        }

        my str $sigil = $stmt->{"sigil"};
        my int $var_type = $stmt->{"var_type"};
        
        # Struct type
        if ($var_type == TYPE_STRUCT()) {
            my str $type_name = $stmt->{"type_name"};
            # Register this variable as a struct type for function pointer detection
            $cg->{"struct_vars"}->{$stmt->{"name"}} = $type_name;
            emit($cg, $type_name . " *" . $stmt->{"name"});
            if ($stmt->{"init"}) {
                my scalar $init = $stmt->{"init"};
                # Handle clone() for structs specially
                if ($init->{"type"} == NODE_CALL() && $init->{"name"} eq "clone") {
                    emit($cg, " = malloc(sizeof(" . $type_name . ")); memcpy(" . $stmt->{"name"} . ", ");
                    my scalar $args = $init->{"args"};
                    gen_expression($cg, $args->[0]);
                    emit($cg, ", sizeof(" . $type_name . "))");
                } else {
                    emit($cg, " = ");
                    gen_expression($cg, $init);
                }
            } else {
                emit($cg, " = malloc(sizeof(" . $type_name . "))");
            }
        } elsif ($sigil eq "%" || $var_type == TYPE_HASH()) {
            emit($cg, "StradaValue *" . $stmt->{"name"});
            if ($stmt->{"init"}) {
                emit($cg, " = ");
                # Handle empty () which parser returns as anon_hash
                my scalar $init = $stmt->{"init"};
                if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                    emit($cg, "strada_new_hash()");
                } else {
                    gen_expression($cg, $init);
                    # If initializing from a variable or deref, incref to share ownership properly
                    my int $init_type = $init->{"type"};
                    if ($init_type == NODE_VARIABLE()) {
                        emit($cg, "; strada_incref(" . $stmt->{"name"} . ")");
                    } elsif ($init_type == NODE_DEREF_SCALAR() && $init->{"sigil"} eq "%") {
                        # Hash deref like %{$ref} returns borrowed reference - need to incref
                        emit($cg, "; strada_incref(" . $stmt->{"name"} . ")");
                    }
                }
            } else {
                emit($cg, " = strada_new_hash()");
            }
            # Handle initial capacity: my hash %name{size};
            if ($stmt->{"initial_capacity"}) {
                emit($cg, "; strada_hash_reserve_sv(" . $stmt->{"name"} . ", strada_to_int(");
                gen_expression($cg, $stmt->{"initial_capacity"});
                emit($cg, "))");
            }
        } elsif ($sigil eq "@" || $var_type == TYPE_ARRAY()) {
            emit($cg, "StradaValue *" . $stmt->{"name"});
            if ($stmt->{"init"}) {
                emit($cg, " = ");
                # Handle empty () which parser returns as anon_hash
                my scalar $init = $stmt->{"init"};
                my int $init_type = $init->{"type"};
                if ($init_type == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                    emit($cg, "strada_new_array()");
                } elsif ($init_type == NODE_ANON_ARRAY()) {
                    # Array literal like [1, 2, 3] - generate directly
                    gen_expression($cg, $init);
                } elsif (is_scalar_expr($init)) {
                    # Single scalar expression like ($x) - wrap in array
                    # Create array and push the element
                    emit($cg, "strada_new_array(); strada_array_push(" . $stmt->{"name"} . "->value.av, ");
                    gen_expression($cg, $init);
                    emit($cg, ")");
                } else {
                    # Could be array/hash/function returning array - assign directly
                    gen_expression($cg, $init);
                    # If initializing from a variable or deref, incref to share ownership properly
                    # This is needed because the local variable will be decref'd at end of scope
                    if ($init_type == NODE_VARIABLE()) {
                        emit($cg, "; strada_incref(" . $stmt->{"name"} . ")");
                    } elsif ($init_type == NODE_DEREF_SCALAR() && $init->{"sigil"} eq "@") {
                        # Array deref like @{$ref} returns borrowed reference - need to incref
                        emit($cg, "; strada_incref(" . $stmt->{"name"} . ")");
                    }
                }
            } else {
                emit($cg, " = strada_new_array()");
            }
            # Handle initial capacity: my array @name[size];
            if ($stmt->{"initial_capacity"}) {
                emit($cg, "; strada_reserve_sv(" . $stmt->{"name"} . ", strada_to_int(");
                gen_expression($cg, $stmt->{"initial_capacity"});
                emit($cg, "))");
            }
        } else {
            emit($cg, "StradaValue *" . $stmt->{"name"});
            if ($stmt->{"init"}) {
                emit($cg, " = ");
                gen_expression($cg, $stmt->{"init"});
                # If initializing from borrowed reference, incref to share ownership properly
                # This prevents the original value from being freed when this one goes out of scope
                my scalar $init = $stmt->{"init"};
                my int $init_type = $init->{"type"};
                if ($init_type == NODE_VARIABLE()) {
                    emit($cg, "; strada_incref(" . $stmt->{"name"} . ")");
                } elsif ($init_type == NODE_HASH_ACCESS()) {
                    # Hash access returns borrowed reference - need to incref
                    emit($cg, "; strada_incref(" . $stmt->{"name"} . ")");
                } elsif ($init_type == NODE_SUBSCRIPT()) {
                    # Array subscript also returns borrowed reference
                    emit($cg, "; strada_incref(" . $stmt->{"name"} . ")");
                } elsif ($init_type == NODE_DEREF_ARRAY()) {
                    # Arrow array dereference $ref->[idx] returns borrowed reference
                    emit($cg, "; strada_incref(" . $stmt->{"name"} . ")");
                } elsif ($init_type == NODE_DEREF_HASH()) {
                    # Arrow hash dereference $ref->{key} returns borrowed reference
                    emit($cg, "; strada_incref(" . $stmt->{"name"} . ")");
                }
            } else {
                emit($cg, " = strada_new_undef()");
            }
        }
        emit($cg, ";\n");
        # Track variable for scope cleanup (only StradaValue*, not structs)
        if ($var_type != TYPE_STRUCT()) {
            scope_track_var($cg, $stmt->{"name"});
        }
        return;
    }
    
    # If statement
    if ($type == NODE_IF_STMT()) {
        emit_indent($cg);
        emit($cg, "if (");
        emit_condition($cg, $stmt->{"condition"});
        emit($cg, ") ");
        gen_block($cg, $stmt->{"then_block"});

        # Elsif clauses
        my scalar $elsif_conds = $stmt->{"elsif_conditions"};
        my scalar $elsif_blocks = $stmt->{"elsif_blocks"};
        my int $i = 0;
        while ($i < $stmt->{"elsif_count"}) {
            emit($cg, " else if (");
            emit_condition($cg, $elsif_conds->[$i]);
            emit($cg, ") ");
            gen_block($cg, $elsif_blocks->[$i]);
            $i = $i + 1;
        }
        
        # Else clause
        if ($stmt->{"else_block"}) {
            emit($cg, " else ");
            gen_block($cg, $stmt->{"else_block"});
        }
        
        emit($cg, "\n");
        return;
    }
    
    # While statement
    if ($type == NODE_WHILE_STMT()) {
        my str $label = $stmt->{"label"};
        emit_indent($cg);
        emit($cg, "while (");
        emit_condition($cg, $stmt->{"condition"});
        emit($cg, ") {\n");
        indent($cg);
        scope_push($cg);

        my scalar $body = $stmt->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Add continue label at end of loop body if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_continue: ;\n");
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Add break label after loop if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_break: ;\n");
        }
        return;
    }
    
    # For statement
    if ($type == NODE_FOR_STMT()) {
        my str $label = $stmt->{"label"};
        emit_indent($cg);
        emit($cg, "for (");

        if ($stmt->{"init"}) {
            my scalar $init = $stmt->{"init"};
            if ($init->{"type"} == NODE_VAR_DECL()) {
                emit($cg, "StradaValue *" . $init->{"name"} . " = ");
                if ($init->{"init"}) {
                    gen_expression($cg, $init->{"init"});
                } else {
                    emit($cg, "strada_new_undef()");
                }
            } else {
                gen_expression($cg, $init);
            }
        }
        emit($cg, "; ");

        if ($stmt->{"condition"}) {
            emit_condition($cg, $stmt->{"condition"});
        }
        emit($cg, "; ");

        if ($stmt->{"update"}) {
            gen_expression($cg, $stmt->{"update"});
        }

        emit($cg, ") {\n");
        indent($cg);
        scope_push($cg);

        my scalar $body = $stmt->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Add continue label at end of loop body if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_continue: ;\n");
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Add break label after loop if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_break: ;\n");
        }
        return;
    }

    # Foreach statement
    if ($type == NODE_FOREACH_STMT()) {
        my str $label = $stmt->{"label"};
        my scalar $var_decl = $stmt->{"var_decl"};
        my str $var_name = $stmt->{"var_name"};
        my scalar $array_expr = $stmt->{"array"};
        my scalar $body = $stmt->{"body"};

        my int $foreach_id = $cg->{"foreach_counter"};
        $cg->{"foreach_counter"} = $foreach_id + 1;

        # Open a block scope
        emit_indent($cg);
        emit($cg, "{\n");
        indent($cg);
        scope_push($cg);

        # Get the array and iterate
        emit_indent($cg);
        emit($cg, "StradaValue *__foreach_arr_" . $foreach_id . " = ");
        gen_expression($cg, $array_expr);
        emit($cg, ";\n");

        emit_indent($cg);
        emit($cg, "StradaArray *__foreach_av_" . $foreach_id . " = strada_deref_array(__foreach_arr_" . $foreach_id . ");\n");

        emit_indent($cg);
        emit($cg, "int __foreach_len_" . $foreach_id . " = strada_array_length(__foreach_av_" . $foreach_id . ");\n");

        emit_indent($cg);
        emit($cg, "for (int __foreach_i_" . $foreach_id . " = 0; __foreach_i_" . $foreach_id . " < __foreach_len_" . $foreach_id . "; __foreach_i_" . $foreach_id . "++) {\n");
        indent($cg);
        scope_push($cg);

        # Declare or assign the loop variable
        emit_indent($cg);
        if ($var_decl) {
            # New variable declaration
            emit($cg, "StradaValue *" . $var_name . " = strada_array_get(__foreach_av_" . $foreach_id . ", __foreach_i_" . $foreach_id . ");\n");
        } else {
            # Existing variable - assign to it
            emit($cg, $var_name . " = strada_array_get(__foreach_av_" . $foreach_id . ", __foreach_i_" . $foreach_id . ");\n");
        }

        # Generate body statements
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Add continue label at end of loop body if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_continue: ;\n");
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Close block scope
        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Add break label after loop if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_break: ;\n");
        }
        return;
    }

    # Return statement
    if ($type == NODE_RETURN_STMT()) {
        my int $in_main = $cg->{"in_main"};
        my int $returns_struct = $cg->{"returns_struct"};
        my int $cleanup_enabled = $cg->{"cleanup_enabled"};
        my int $profiling = $cg->{"enable_profiling"};
        my str $func_name = $cg->{"current_func_name"};

        # main() and struct-returning functions - evaluate return value, cleanup, then return
        if ($in_main == 1 || $returns_struct == 1) {
            if ($stmt->{"value"}) {
                # Evaluate return expression BEFORE cleanup to avoid use-after-free
                emit_indent($cg);
                if ($in_main == 1) {
                    if ($stmt->{"value"}->{"type"} == NODE_INT_LITERAL()) {
                        # Simple literal - can emit directly after cleanup
                        if ($cleanup_enabled == 1) {
                            scope_emit_all_cleanup($cg);
                        }
                        emit_try_cleanup($cg);
                        emit_indent($cg);
                        emit($cg, "return " . $stmt->{"value"}->{"value"} . ";\n");
                    } else {
                        # Complex expression - evaluate first, then cleanup
                        emit($cg, "{ int __main_ret = strada_to_int(");
                        gen_expression($cg, $stmt->{"value"});
                        emit($cg, ");\n");
                        indent($cg);
                        if ($cleanup_enabled == 1) {
                            scope_emit_all_cleanup($cg);
                        }
                        emit_try_cleanup($cg);
                        emit_indent($cg);
                        emit($cg, "return __main_ret; }\n");
                        dedent($cg);
                    }
                } else {
                    # Struct return - evaluate first
                    emit($cg, "{ ");
                    my str $ret_type = $cg->{"current_func_return_type_str"};
                    if (length($ret_type) == 0) {
                        $ret_type = "void*";
                    }
                    emit($cg, $ret_type . " __struct_ret = ");
                    gen_expression($cg, $stmt->{"value"});
                    emit($cg, ";\n");
                    indent($cg);
                    if ($cleanup_enabled == 1) {
                        scope_emit_all_cleanup($cg);
                    }
                    emit_try_cleanup($cg);
                    emit_indent($cg);
                    emit($cg, "return __struct_ret; }\n");
                    dedent($cg);
                }
            } else {
                # No return value - cleanup then return
                if ($cleanup_enabled == 1) {
                    scope_emit_all_cleanup($cg);
                }
                emit_try_cleanup($cg);
                emit_indent($cg);
                emit($cg, "return;\n");
            }
        } elsif ($cleanup_enabled == 0) {
            # Cleanup disabled - simple return
            # Still need to pop try blocks even if cleanup is disabled
            emit_try_cleanup($cg);
            # Add profiling exit if enabled (for non-main)
            if ($profiling == 1 && $in_main == 0 && length($func_name) > 0) {
                if ($stmt->{"value"}) {
                    # Save return value, call profile_exit, then return
                    emit_indent($cg);
                    emit($cg, "{ StradaValue *__retval = ");
                    gen_expression($cg, $stmt->{"value"});
                    emit($cg, "; strada_profile_exit(\"" . $func_name . "\"); return __retval; }\n");
                } else {
                    emit_indent($cg);
                    emit($cg, "strada_profile_exit(\"" . $func_name . "\");\n");
                    emit_indent($cg);
                    emit($cg, "return;\n");
                }
            } else {
                emit_indent($cg);
                emit($cg, "return");
                if ($stmt->{"value"}) {
                    emit($cg, " ");
                    gen_expression($cg, $stmt->{"value"});
                }
                emit($cg, ";\n");
            }
        } elsif ($stmt->{"value"}) {
            # Non-main function with return value - save, cleanup, return
            emit_indent($cg);
            emit($cg, "{ StradaValue *__retval = ");
            gen_expression($cg, $stmt->{"value"});
            emit($cg, ";\n");
            indent($cg);
            # Only incref if returning a variable/borrowed ref (not for new values)
            if (return_needs_incref($stmt->{"value"}) == 1) {
                emit_indent($cg);
                emit($cg, "strada_incref(__retval);\n");
            }
            scope_emit_all_cleanup($cg);
            # Pop any active try blocks before returning
            emit_try_cleanup($cg);
            # Add profiling exit if enabled
            if ($profiling == 1 && length($func_name) > 0) {
                emit_indent($cg);
                emit($cg, "strada_profile_exit(\"" . $func_name . "\");\n");
            }
            emit_indent($cg);
            emit($cg, "return __retval; }\n");
            dedent($cg);
        } else {
            # Void return - cleanup then return
            scope_emit_all_cleanup($cg);
            # Pop any active try blocks before returning
            emit_try_cleanup($cg);
            # Add profiling exit if enabled
            if ($profiling == 1 && length($func_name) > 0) {
                emit_indent($cg);
                emit($cg, "strada_profile_exit(\"" . $func_name . "\");\n");
            }
            emit_indent($cg);
            emit($cg, "return;\n");
        }
        return;
    }
    
    # Expression statement
    if ($type == NODE_EXPR_STMT()) {
        emit_indent($cg);
        gen_expression($cg, $stmt->{"expr"});
        emit($cg, ";\n");
        return;
    }
    
    # Last (break)
    if ($type == 100) {
        my str $label = $stmt->{"label"};
        emit_indent($cg);
        if (length($label) > 0) {
            emit($cg, "goto ");
            emit($cg, $label);
            emit($cg, "_break;\n");
        } else {
            emit($cg, "break;\n");
        }
        return;
    }

    # Next (continue)
    if ($type == 101) {
        my str $label = $stmt->{"label"};
        emit_indent($cg);
        if (length($label) > 0) {
            emit($cg, "goto ");
            emit($cg, $label);
            emit($cg, "_continue;\n");
        } else {
            emit($cg, "continue;\n");
        }
        return;
    }

    # Try/Catch statement
    if ($type == NODE_TRY_CATCH()) {
        my str $catch_var = $stmt->{"catch_var"};
        emit_indent($cg);
        emit($cg, "if (setjmp(*STRADA_TRY_PUSH()) == 0) {\n");
        indent($cg);
        scope_push($cg);

        # Track that we're inside a try block (for proper cleanup on return)
        my int $try_depth = $cg->{"try_depth"};
        $cg->{"try_depth"} = $try_depth + 1;

        # Generate try block
        my scalar $try_block = $stmt->{"try_block"};
        my scalar $stmts = $try_block->{"statements"};
        my int $i = 0;
        while ($i < $try_block->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Decrement try_depth before we emit the pop (return after this point doesn't need extra cleanup)
        $cg->{"try_depth"} = $try_depth;

        emit_indent($cg);
        emit($cg, "STRADA_TRY_POP();\n");
        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "} else {\n");
        indent($cg);
        scope_push($cg);
        emit_indent($cg);
        emit($cg, "STRADA_TRY_POP();\n");

        # Declare catch variable and get exception
        emit_indent($cg);
        emit($cg, "StradaValue *");
        emit($cg, $catch_var);
        emit($cg, " = strada_get_exception();\n");
        # Track catch variable for cleanup
        scope_track_var($cg, $catch_var);

        # Generate catch block
        my scalar $catch_block = $stmt->{"catch_block"};
        my scalar $catch_stmts = $catch_block->{"statements"};
        my int $j = 0;
        while ($j < $catch_block->{"statement_count"}) {
            gen_statement($cg, $catch_stmts->[$j]);
            $j = $j + 1;
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");
        return;
    }

    # Throw statement
    if ($type == NODE_THROW()) {
        emit_indent($cg);
        emit($cg, "strada_throw_value(");
        gen_expression($cg, $stmt->{"expr"});
        emit($cg, ");\n");
        return;
    }

    # Label statement
    if ($type == NODE_LABEL()) {
        emit($cg, $stmt->{"name"} . ":;\n");
        return;
    }

    # Goto statement
    if ($type == NODE_GOTO()) {
        emit_indent($cg);
        emit($cg, "goto " . $stmt->{"target"} . ";\n");
        return;
    }

    # Switch statement
    if ($type == NODE_SWITCH()) {
        # Generate a unique variable to hold the switch expression
        my int $switch_id = $cg->{"switch_counter"};
        $cg->{"switch_counter"} = $switch_id + 1;
        my str $switch_var = "_switch_val_" . $switch_id;

        emit_indent($cg);
        emit($cg, "{\n");
        indent($cg);

        # Evaluate switch expression once
        emit_indent($cg);
        emit($cg, "StradaValue *" . $switch_var . " = ");
        gen_expression($cg, $stmt->{"expr"});
        emit($cg, ";\n");

        my scalar $cases = $stmt->{"cases"};
        my scalar $blocks = $stmt->{"blocks"};
        my int $case_count = $stmt->{"case_count"};
        my int $i = 0;

        while ($i < $case_count) {
            emit_indent($cg);
            if ($i == 0) {
                emit($cg, "if (strcmp(strada_to_str(" . $switch_var . "), strada_to_str(");
            } else {
                emit($cg, "} else if (strcmp(strada_to_str(" . $switch_var . "), strada_to_str(");
            }
            gen_expression($cg, $cases->[$i]);
            emit($cg, ")) == 0) {\n");
            indent($cg);

            # Generate the block body (statements only, not the braces)
            my scalar $block = $blocks->[$i];
            my scalar $stmts = $block->{"statements"};
            my int $j = 0;
            while ($j < $block->{"statement_count"}) {
                gen_statement($cg, $stmts->[$j]);
                $j = $j + 1;
            }

            dedent($cg);
            $i = $i + 1;
        }

        # Default block
        my int $has_default = $stmt->{"has_default"};
        if ($has_default) {
            my scalar $default_block = $stmt->{"default_block"};
            emit_indent($cg);
            if ($case_count > 0) {
                emit($cg, "} else {\n");
            } else {
                emit($cg, "{\n");
            }
            indent($cg);

            my scalar $def_stmts = $default_block->{"statements"};
            my int $k = 0;
            while ($k < $default_block->{"statement_count"}) {
                gen_statement($cg, $def_stmts->[$k]);
                $k = $k + 1;
            }

            dedent($cg);
        }

        if ($case_count > 0 || $has_default) {
            emit_indent($cg);
            emit($cg, "}\n");
        }

        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");
        return;
    }
}

# ============================================================
# Function and Program Code Generation
# ============================================================

func gen_function(scalar $cg, scalar $fn) void {
    my str $ret_type = type_to_c($fn->{"return_type"});
    my str $name = sanitize_name($fn->{"name"});
    my int $ret_type_id = $fn->{"return_type"};

    # Track if function returns a struct (for return statement handling)
    if ($ret_type_id == TYPE_STRUCT()) {
        $cg->{"returns_struct"} = 1;
    } else {
        $cg->{"returns_struct"} = 0;
    }

    # Special case for main
    if ($name eq "main") {
        $cg->{"in_main"} = 1;
        emit($cg, "int main(int _argc, char **_argv) {\n");
        emit($cg, "    /* Initialize proctitle support */\n");
        emit($cg, "    strada_init_proctitle(_argc, _argv);\n\n");

        # Initialize profiling if enabled
        if ($cg->{"enable_profiling"} == 1) {
            emit($cg, "    /* Initialize function profiling */\n");
            emit($cg, "    strada_profile_init();\n");
            emit($cg, "    atexit(strada_profile_report);\n\n");
        }
        emit($cg, "    /* Populate global ARGV array */\n");
        emit($cg, "    ARGV = strada_new_array();\n");
        emit($cg, "    for (int i = 0; i < _argc; i++) {\n");
        emit($cg, "        strada_array_push(ARGV->value.av, strada_new_str(_argv[i]));\n");
        emit($cg, "    }\n");
        emit($cg, "    ARGC = strada_new_int(_argc);\n\n");

        # Set package if declared at file level
        my str $pkg = $cg->{"package"};
        if ($pkg ne "") {
            emit($cg, "    /* Set package from file-level declaration */\n");
            emit($cg, "    strada_set_package(\"" . $pkg . "\");\n\n");
        }

        # Set up inheritance from file-level declarations
        my scalar $inherits = $cg->{"inherits"};
        my int $inherit_count = $cg->{"inherit_count"};
        if ($inherit_count > 0) {
            emit($cg, "    /* Set up inheritance from file-level declarations */\n");
            my int $inh = 0;
            while ($inh < $inherit_count) {
                my str $parent = $inherits->[$inh];
                emit($cg, "    strada_inherit_from(\"" . $parent . "\");\n");
                $inh = $inh + 1;
            }
            emit($cg, "\n");
        }

        # Initialize OOP method registration for all packages that have methods
        my int $num_oop_pkgs = get_oop_pkg_count($cg);
        if ($num_oop_pkgs > 0) {
            my scalar $oop_pkgs = get_oop_packages($cg);
            emit($cg, "    /* Initialize OOP method registration */\n");
            my int $oop_i = 0;
            while ($oop_i < $num_oop_pkgs) {
                my str $oop_pkg = $oop_pkgs->[$oop_i];
                emit($cg, "    __" . $oop_pkg . "_oop_init();\n");
                $oop_i = $oop_i + 1;
            }
            emit($cg, "\n");
        }

        # If main has parameters, bind argc/argv to them
        my scalar $params = $fn->{"params"};
        my int $param_count = $fn->{"param_count"};
        if ($param_count >= 1) {
            # First parameter gets argc
            my scalar $p1 = $params->[0];
            emit($cg, "    StradaValue* " . $p1->{"name"} . " = ARGC;\n");
        }
        if ($param_count >= 2) {
            # Second parameter gets argv array
            my scalar $p2 = $params->[1];
            emit($cg, "    StradaValue* " . $p2->{"name"} . " = ARGV;\n");
        }
        if ($param_count > 0) {
            emit($cg, "\n");
        }

        # Initialize global variables
        my int $global_count = $cg->{"global_count"};
        if ($global_count > 0) {
            emit($cg, "    /* Initialize global variables */\n");
            my scalar $globals = $cg->{"globals"};
            my int $g = 0;
            while ($g < $global_count) {
                my scalar $gvar = $globals->[$g];
                my int $var_type = $gvar->{"var_type"};
                my str $sigil = $gvar->{"sigil"};
                my str $name = $gvar->{"name"};
                my scalar $init = $gvar->{"init"};

                emit($cg, "    " . $name . " = ");
                if ($var_type == TYPE_STRUCT()) {
                    my str $type_name = $gvar->{"type_name"};
                    if ($init) {
                        gen_expression($cg, $init);
                    } else {
                        emit($cg, "malloc(sizeof(" . $type_name . "))");
                    }
                } elsif ($sigil eq "%" || $var_type == TYPE_HASH()) {
                    if ($init) {
                        # Handle empty () which parser returns as anon_hash
                        if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                            emit($cg, "strada_new_hash()");
                        } else {
                            gen_expression($cg, $init);
                        }
                    } else {
                        emit($cg, "strada_new_hash()");
                    }
                } elsif ($sigil eq "@" || $var_type == TYPE_ARRAY()) {
                    if ($init) {
                        # Handle empty () which parser returns as anon_hash
                        if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                            emit($cg, "strada_new_array()");
                        } else {
                            gen_expression($cg, $init);
                        }
                    } else {
                        emit($cg, "strada_new_array()");
                    }
                } else {
                    if ($init) {
                        gen_expression($cg, $init);
                    } else {
                        emit($cg, "strada_new_undef()");
                    }
                }
                emit($cg, ";\n");
                $g = $g + 1;
            }
            emit($cg, "\n");
        }

        # Generate the body statements directly (without the outer braces)
        # Push scope for main's local variables
        scope_push($cg);
        my scalar $body = $fn->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }
        scope_pop($cg);
        emit($cg, "}\n\n");
        $cg->{"in_main"} = 0;
    } else {
        emit($cg, $ret_type . " " . $name . "(");
        
        my scalar $params = $fn->{"params"};
        my int $i = 0;
        while ($i < $fn->{"param_count"}) {
            if ($i > 0) {
                emit($cg, ", ");
            }
            my scalar $param = $params->[$i];
            my int $ptype = $param->{"param_type"};
            if ($ptype == TYPE_STRUCT()) {
                # Register struct-typed parameter for function pointer detection
                $cg->{"struct_vars"}->{$param->{"name"}} = $param->{"type_name"};
                emit($cg, $param->{"type_name"} . " *" . $param->{"name"});
            } else {
                emit($cg, type_to_c($ptype) . " " . $param->{"name"});
            }
            $i = $i + 1;
        }

        if ($fn->{"param_count"} == 0) {
            emit($cg, "void");
        }

        emit($cg, ") {\n");

        # Add profiling entry if enabled
        if ($cg->{"enable_profiling"} == 1) {
            emit($cg, "    strada_profile_enter(\"" . $name . "\");\n");
        }

        # Store current function name for profiling exit in return statements
        $cg->{"current_func_name"} = $name;

        # Store current function's package for SUPER:: calls
        $cg->{"current_fn_package"} = $fn->{"package"};

        # Generate the function body (without the outer braces, we handle them)
        scope_push($cg);
        my scalar $body = $fn->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $stmt_i = 0;
        while ($stmt_i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$stmt_i]);
            $stmt_i = $stmt_i + 1;
        }
        scope_pop($cg);

        # Add implicit profiling exit for void functions (no explicit return)
        if ($cg->{"enable_profiling"} == 1 && $ret_type_id == TYPE_VOID()) {
            emit($cg, "    strada_profile_exit(\"" . $name . "\");\n");
        }
        emit($cg, "}\n");

        $cg->{"current_func_name"} = "";
        $cg->{"current_fn_package"} = "";

        # Clear struct_vars for parameters (they go out of scope)
        $i = 0;
        while ($i < $fn->{"param_count"}) {
            my scalar $param = $params->[$i];
            if ($param->{"param_type"} == TYPE_STRUCT()) {
                $cg->{"struct_vars"}->{$param->{"name"}} = "";
            }
            $i = $i + 1;
        }
        emit($cg, "\n\n");
    }
}

func gen_program(scalar $cg, scalar $program) void {
    # First pass: register all functions for default parameter handling
    my scalar $funcs = $program->{"functions"};
    my int $i = 0;
    my int $reg = 0;
    while ($reg < $program->{"function_count"}) {
        codegen_register_function($cg, $funcs->[$reg]);
        $reg = $reg + 1;
    }
    
    # Store package name in codegen context for later use
    $cg->{"package"} = $program->{"package"};

    # Store inherits in codegen context for later use
    $cg->{"inherits"} = $program->{"inherits"};
    $cg->{"inherit_count"} = $program->{"inherit_count"};

    # Header
    emit($cg, "/* Generated by Strada Self-Hosting Compiler */\n");

    # Package name
    if ($program->{"package"} ne "") {
        emit($cg, "/* Package: " . $program->{"package"} . " */\n");
    }
    
    emit($cg, "#include \"strada_runtime.h\"\n");
    emit($cg, "#include <string.h>\n");
    emit($cg, "#include <stdint.h>\n");
    emit($cg, "#include <stdbool.h>\n");
    emit($cg, "#include <dlfcn.h>\n");
    emit($cg, "#include <math.h>\n\n");
    
    # Check if there's a main function
    my int $has_main = 0;
    $i = 0;
    while ($i < $program->{"function_count"}) {
        if ($funcs->[$i]->{"name"} eq "main") {
            $has_main = 1;
            last;
        }
        $i = $i + 1;
    }
    
    # Global ARGV and ARGC (only for files with main)
    if ($has_main == 1) {
        emit($cg, "/* Global command-line argument variables */\n");
        emit($cg, "StradaValue *ARGV = NULL;\n");
        emit($cg, "StradaValue *ARGC = NULL;\n\n");
    } else {
        emit($cg, "/* External globals from main module */\n");
        emit($cg, "extern StradaValue *ARGV;\n");
        emit($cg, "extern StradaValue *ARGC;\n\n");
    }

    # Emit global variable declarations
    my int $global_count = $program->{"global_count"};
    if ($global_count > 0) {
        my scalar $globals = $program->{"globals"};
        emit($cg, "/* Global variables */\n");
        my int $g = 0;
        while ($g < $global_count) {
            my scalar $gvar = $globals->[$g];
            my int $var_type = $gvar->{"var_type"};
            my str $name = $gvar->{"name"};

            if ($var_type == TYPE_STRUCT()) {
                my str $type_name = $gvar->{"type_name"};
                emit($cg, $type_name . " *" . $name . " = NULL;\n");
            } else {
                emit($cg, "StradaValue *" . $name . " = NULL;\n");
            }
            $g = $g + 1;
        }
        emit($cg, "\n");
    }

    # Store globals in codegen context for initialization in main
    $cg->{"globals"} = $program->{"globals"};
    $cg->{"global_count"} = $program->{"global_count"};

    # Build struct definitions map for later use (function pointer detection)
    my scalar $structs = $program->{"structs"};
    my int $s = 0;
    while ($s < $program->{"struct_count"}) {
        my scalar $st = $structs->[$s];
        my str $struct_name = $st->{"name"};
        my hash %struct_info = ();
        $struct_info{"fields"} = {};

        my scalar $fields = $st->{"fields"};
        my int $f = 0;
        while ($f < $st->{"field_count"}) {
            my scalar $field = $fields->[$f];
            my int $ftype = $field->{"field_type"};
            my hash %field_info = ();
            $field_info{"is_funcptr"} = $ftype == TYPE_FUNCPTR();
            $struct_info{"fields"}->{$field->{"name"}} = \%field_info;
            $f = $f + 1;
        }
        $cg->{"struct_defs"}->{$struct_name} = \%struct_info;
        $s = $s + 1;
    }

    # Generate struct definitions
    $s = 0;
    while ($s < $program->{"struct_count"}) {
        my scalar $st = $structs->[$s];
        emit($cg, "typedef struct {\n");

        my scalar $fields = $st->{"fields"};
        my int $f = 0;
        while ($f < $st->{"field_count"}) {
            my scalar $field = $fields->[$f];
            my int $ftype = $field->{"field_type"};

            if ($ftype == TYPE_FUNCPTR()) {
                # Function pointer field - generate as void pointer for now
                # In a full implementation, we'd track the exact signature
                emit($cg, "    void *" . $field->{"name"} . ";\n");
            } else {
                emit($cg, "    StradaValue *" . $field->{"name"} . ";\n");
            }
            $f = $f + 1;
        }

        emit($cg, "} " . $st->{"name"} . ";\n\n");
        $s = $s + 1;
    }
    
    # Generate extern declarations for imported functions
    my int $imp_count = $program->{"import_count"};
    if ($imp_count > 0) {
        emit($cg, "/* Imported function declarations */\n");
        my scalar $imports = $program->{"imports"};
        my int $imp = 0;
        while ($imp < $imp_count) {
            my str $imp_name = $imports->[$imp];
            # Generate generic extern declaration (assume StradaValue* return and variadic params)
            emit($cg, "extern StradaValue* " . $imp_name . "();\n");
            $imp = $imp + 1;
        }
        emit($cg, "\n");
    }
    
    # Generate extern declarations for qualified module function calls
    my int $use_count = $program->{"use_count"};
    if ($use_count > 0) {
        my scalar $uses = $program->{"uses"};
        my int $u = 0;
        while ($u < $use_count) {
            my str $mod_name = $uses->[$u];
            # Skip "lib" pseudo-module
            if ($mod_name ne "lib") {
                # Convert :: to __ for C identifier prefix
                my str $prefix = "";
                my int $p = 0;
                my int $plen = length($mod_name);
                while ($p < $plen) {
                    my str $ch = substr($mod_name, $p, 1);
                    if ($ch eq ":") {
                        $prefix = $prefix . "_";
                    } else {
                        $prefix = $prefix . $ch;
                    }
                    $p = $p + 1;
                }
                $prefix = $prefix . "__";
                
                # Generate extern declarations for imported funcs with qualified names
                emit($cg, "/* Qualified imports from " . $mod_name . " */\n");
                my scalar $imports = $program->{"imports"};
                my int $imp = 0;
                while ($imp < $program->{"import_count"}) {
                    my str $imp_name = $imports->[$imp];
                    emit($cg, "extern StradaValue* " . $prefix . $imp_name . "();\n");
                    $imp = $imp + 1;
                }
                emit($cg, "\n");
            }
            $u = $u + 1;
        }
    }

    # Generate import_lib wrapper infrastructure
    my int $import_lib_count = $program->{"import_lib_count"};
    if ($import_lib_count > 0) {
        my scalar $import_libs = $program->{"import_libs"};

        emit($cg, "/* import_lib: static library handles and function pointers */\n");

        my int $lib_idx = 0;
        while ($lib_idx < $import_lib_count) {
            my scalar $lib_info = $import_libs->[$lib_idx];
            my str $lib_name = $lib_info->{"lib_name"};
            my str $safe_lib = sanitize_name($lib_name);

            # Static handle for the library
            emit($cg, "static void *__import_lib_" . $safe_lib . "_handle = NULL;\n");

            # Static function pointers for each function
            my scalar $lib_funcs = $lib_info->{"functions"};
            my int $fn_idx = 0;
            my int $fn_count = $lib_info->{"function_count"};
            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $lib_funcs->[$fn_idx];
                my str $fn_name = sanitize_name($fn_info->{"name"});
                emit($cg, "static void *__import_lib_" . $safe_lib . "_fn_" . $fn_name . " = NULL;\n");
                $fn_idx = $fn_idx + 1;
            }

            $lib_idx = $lib_idx + 1;
        }
        emit($cg, "\n");

        # Forward declarations for wrapper functions
        emit($cg, "/* import_lib: wrapper function forward declarations */\n");
        $lib_idx = 0;
        while ($lib_idx < $import_lib_count) {
            my scalar $lib_info = $import_libs->[$lib_idx];
            my scalar $lib_funcs = $lib_info->{"functions"};
            my int $fn_idx = 0;
            my int $fn_count = $lib_info->{"function_count"};

            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $lib_funcs->[$fn_idx];
                my str $fn_name = sanitize_name($fn_info->{"name"});
                my int $ret_type = $fn_info->{"return_type"};
                my int $param_count = $fn_info->{"param_count"};
                my scalar $params = $fn_info->{"params"};

                emit($cg, type_to_c($ret_type) . " " . $fn_name . "(");

                my int $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$p];
                    my int $ptype = $param->{"param_type"};
                    emit($cg, type_to_c($ptype) . " " . $param->{"name"});
                    $p = $p + 1;
                }

                if ($param_count == 0) {
                    emit($cg, "void");
                }

                emit($cg, ");\n");
                $fn_idx = $fn_idx + 1;
            }

            $lib_idx = $lib_idx + 1;
        }
        emit($cg, "\n");
    }

    # Forward declarations
    $i = 0;
    while ($i < $program->{"function_count"}) {
        my scalar $fn = $funcs->[$i];
        my str $name = sanitize_name($fn->{"name"});
        my int $fn_type = $fn->{"type"};
        
        # Skip extern functions (they're declared elsewhere)
        if ($fn_type == NODE_EXTERN_FUNC()) {
            # Generate extern declaration
            emit($cg, "extern ");
            gen_extern_decl($cg, $fn);
            $i = $i + 1;
            next;
        }
        
        if ($name eq "main") {
            emit($cg, "int main(int _argc, char **_argv);\n");
        } else {
            emit($cg, type_to_c($fn->{"return_type"}) . " " . $name . "(");
            
            my scalar $params = $fn->{"params"};
            my int $j = 0;
            while ($j < $fn->{"param_count"}) {
                if ($j > 0) {
                    emit($cg, ", ");
                }
                my scalar $param = $params->[$j];
                my int $ptype = $param->{"param_type"};
                if ($ptype == TYPE_STRUCT()) {
                    emit($cg, $param->{"type_name"} . " *" . $param->{"name"});
                } else {
                    emit($cg, type_to_c($ptype) . " " . $param->{"name"});
                }
                $j = $j + 1;
            }
            
            if ($fn->{"param_count"} == 0) {
                emit($cg, "void");
            }
            
            emit($cg, ");\n");
        }
        $i = $i + 1;
    }

    # NOTE: OOP init forward declarations are generated after methods are tracked
    # and stored in oop_fwd_decls for insertion in get_output()

    emit($cg, "\n");

    # Save preamble content and start fresh for function definitions
    $cg->{"preamble_content"} = sb_to_string($cg->{"output_sb"});
    sb_clear($cg->{"output_sb"});

    # Function definitions (skip extern declarations without bodies)
    $i = 0;
    while ($i < $program->{"function_count"}) {
        my scalar $fn = $funcs->[$i];
        my int $fn_type = $fn->{"type"};

        if ($fn_type == NODE_EXTERN_FUNC()) {
            # Extern with body - generate the function
            if ($fn->{"has_body"} == 1) {
                gen_extern_function($cg, $fn);
            }
        } else {
            gen_function($cg, $fn);
        }

        # Track method for OOP registration using the function's stored package
        # (check package string directly - parser always sets it)
        my str $fn_pkg = $fn->{"package"};
        if (length($fn_pkg) > 0 && $fn_pkg ne "main") {
            codegen_track_method($cg, $fn, $fn_pkg);
        }

        $i = $i + 1;
    }

    # Generate OOP init forward declarations (now that methods are tracked)
    my int $num_fwd_pkgs = get_oop_pkg_count($cg);
    if ($num_fwd_pkgs > 0) {
        my scalar $fwd_pkgs = get_oop_packages($cg);
        my str $fwd_decls = "\n/* OOP method registration forward declarations */\n";
        my int $fwd_i = 0;
        while ($fwd_i < $num_fwd_pkgs) {
            my str $fwd_pkg = $fwd_pkgs->[$fwd_i];
            $fwd_decls = $fwd_decls . "void __" . $fwd_pkg . "_oop_init(void);\n";
            $fwd_i = $fwd_i + 1;
        }
        $cg->{"oop_fwd_decls"} = $fwd_decls;
    }

    # Emit anonymous function definitions
    my str $anon_defs = $cg->{"anon_func_defs"};
    if (length($anon_defs) > 0) {
        emit($cg, "\n/* Anonymous function definitions */\n");
        emit($cg, $anon_defs);
    }

    # Emit OOP method wrappers for all packages
    my str $wrappers = gen_all_method_wrappers($cg);
    if (length($wrappers) > 0) {
        emit($cg, "\n");
        emit($cg, $wrappers);
    }

    # Generate import_lib wrapper function implementations
    if ($import_lib_count > 0) {
        my scalar $import_libs = $program->{"import_libs"};
        emit($cg, "\n/* import_lib: wrapper function implementations */\n");

        my int $lib_idx = 0;
        while ($lib_idx < $import_lib_count) {
            my scalar $lib_info = $import_libs->[$lib_idx];
            my str $lib_name = $lib_info->{"lib_name"};
            my str $safe_lib = sanitize_name($lib_name);
            my str $so_path = $lib_info->{"so_path"};

            my scalar $lib_funcs = $lib_info->{"functions"};
            my int $fn_idx = 0;
            my int $fn_count = $lib_info->{"function_count"};

            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $lib_funcs->[$fn_idx];
                my str $fn_name = sanitize_name($fn_info->{"name"});
                my int $ret_type = $fn_info->{"return_type"};
                my int $param_count = $fn_info->{"param_count"};
                my scalar $params = $fn_info->{"params"};

                # Function signature
                emit($cg, type_to_c($ret_type) . " " . $fn_name . "(");

                my int $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$p];
                    my int $ptype = $param->{"param_type"};
                    emit($cg, type_to_c($ptype) . " " . $param->{"name"});
                    $p = $p + 1;
                }

                if ($param_count == 0) {
                    emit($cg, "void");
                }

                emit($cg, ") {\n");

                # Lazy load the library
                emit($cg, "    if (__import_lib_" . $safe_lib . "_handle == NULL) {\n");
                emit($cg, "        __import_lib_" . $safe_lib . "_handle = dlopen(\"" . $so_path . "\", RTLD_LAZY);\n");
                emit($cg, "        if (__import_lib_" . $safe_lib . "_handle == NULL) {\n");
                emit($cg, "            fprintf(stderr, \"import_lib: failed to load " . $so_path . ": %s\\n\", dlerror());\n");
                emit($cg, "            exit(1);\n");
                emit($cg, "        }\n");
                emit($cg, "    }\n");

                # Lazy lookup the function pointer
                emit($cg, "    if (__import_lib_" . $safe_lib . "_fn_" . $fn_name . " == NULL) {\n");
                emit($cg, "        __import_lib_" . $safe_lib . "_fn_" . $fn_name . " = dlsym(__import_lib_" . $safe_lib . "_handle, \"" . $fn_name . "\");\n");
                emit($cg, "        if (__import_lib_" . $safe_lib . "_fn_" . $fn_name . " == NULL) {\n");
                emit($cg, "            fprintf(stderr, \"import_lib: symbol not found: " . $fn_name . ": %s\\n\", dlerror());\n");
                emit($cg, "            exit(1);\n");
                emit($cg, "        }\n");
                emit($cg, "    }\n");

                # Generate typedef for the function pointer type
                emit($cg, "    typedef " . type_to_c($ret_type) . " (*__fn_type_" . $fn_name . ")(");
                $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    emit($cg, "StradaValue*");
                    $p = $p + 1;
                }
                if ($param_count == 0) {
                    emit($cg, "void");
                }
                emit($cg, ");\n");

                # Cast and call the function directly
                emit($cg, "    __fn_type_" . $fn_name . " __fn = (__fn_type_" . $fn_name . ")__import_lib_" . $safe_lib . "_fn_" . $fn_name . ";\n");
                if ($ret_type == TYPE_VOID()) {
                    emit($cg, "    __fn(");
                } else {
                    emit($cg, "    return __fn(");
                }
                $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$p];
                    emit($cg, $param->{"name"});
                    $p = $p + 1;
                }
                emit($cg, ");\n");

                emit($cg, "}\n\n");
                $fn_idx = $fn_idx + 1;
            }

            $lib_idx = $lib_idx + 1;
        }
    }

    # Save funcs content and start fresh for remaining code
    $cg->{"funcs_content"} = sb_to_string($cg->{"output_sb"});
    sb_clear($cg->{"output_sb"});

    # Generate qualified name aliases if package is declared
    my str $pkg_alias = $program->{"package"};
    if ($pkg_alias ne "") {
        # Convert :: to __ for C identifier
        my str $prefix = "";
        my int $p = 0;
        my int $plen = length($pkg_alias);
        while ($p < $plen) {
            my str $ch = substr($pkg_alias, $p, 1);
            if ($ch eq ":") {
                $prefix = $prefix . "_";
            } else {
                $prefix = $prefix . $ch;
            }
            $p = $p + 1;
        }
        $prefix = $prefix . "__";

        emit($cg, "/* Qualified name aliases for package " . $pkg_alias . " */\n");
        $i = 0;
        while ($i < $program->{"function_count"}) {
            my scalar $fn = $funcs->[$i];
            my int $fn_type = $fn->{"type"};
            my str $name = sanitize_name($fn->{"name"});

            # Skip main and extern functions
            if ($name ne "main" && $fn_type != NODE_EXTERN_FUNC()) {
                my str $ret = type_to_c($fn->{"return_type"});
                my str $qname = sanitize_name($prefix . $fn->{"name"});

                # Generate: RetType QualifiedName(params) { return UnqualifiedName(params); }
                emit($cg, $ret . " " . $qname . "(");

                my scalar $params = $fn->{"params"};
                my int $j = 0;
                while ($j < $fn->{"param_count"}) {
                    if ($j > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$j];
                    my int $ptype = $param->{"param_type"};
                    if ($ptype == TYPE_STRUCT()) {
                        emit($cg, $param->{"type_name"} . " *" . $param->{"name"});
                    } else {
                        emit($cg, type_to_c($ptype) . " " . $param->{"name"});
                    }
                    $j = $j + 1;
                }
                if ($fn->{"param_count"} == 0) {
                    emit($cg, "void");
                }
                emit($cg, ") { return " . $name . "(");
                
                $j = 0;
                while ($j < $fn->{"param_count"}) {
                    if ($j > 0) {
                        emit($cg, ", ");
                    }
                    emit($cg, $params->[$j]->{"name"});
                    $j = $j + 1;
                }
                emit($cg, "); }\n");
            }
            $i = $i + 1;
        }
        emit($cg, "\n");
    }

    # Generate __strada_export_info function for shared library metadata
    # This allows import_lib to work without needing the .strada source file
    gen_export_info($cg, $program);
}

# Generate __strada_export_info function that returns metadata about exported functions
# Format: "func:name:return_type:param_count:param_types\n" for each function
func gen_export_info(scalar $cg, scalar $program) void {
    emit($cg, "\n/* Strada export metadata for import_lib */\n");
    emit($cg, "const char* __strada_export_info(void) {\n");
    emit($cg, "    return \"");

    my scalar $funcs = $program->{"functions"};
    my int $i = 0;
    my int $count = $program->{"function_count"};

    while ($i < $count) {
        my scalar $fn = $funcs->[$i];
        my str $name = $fn->{"name"};
        my int $fn_type = $fn->{"type"};

        # Skip main function and extern functions
        if ($name ne "main" && $fn_type != NODE_EXTERN_FUNC()) {
            my int $ret_type = $fn->{"return_type"};
            my int $param_count = $fn->{"param_count"};

            # func:name:return_type:param_count:param_types
            emit($cg, "func:" . sanitize_name($name) . ":" . type_to_export($ret_type) . ":" . $param_count . ":");

            my scalar $params = $fn->{"params"};
            my int $j = 0;
            while ($j < $param_count) {
                if ($j > 0) {
                    emit($cg, ",");
                }
                my scalar $param = $params->[$j];
                emit($cg, type_to_export($param->{"param_type"}));
                $j = $j + 1;
            }
            emit($cg, "\\n");
        }
        $i = $i + 1;
    }

    emit($cg, "\";\n");
    emit($cg, "}\n");

    # Also generate version info if specified
    gen_version_info($cg, $program);
}

# Generate __strada_version function that returns the module version
func gen_version_info(scalar $cg, scalar $program) void {
    my str $version = "";
    if ($program->{"version"} ne "") {
        $version = $program->{"version"};
    }

    emit($cg, "\n/* Strada module version */\n");
    emit($cg, "const char* __strada_version(void) {\n");
    emit($cg, "    return \"" . $version . "\";\n");
    emit($cg, "}\n");
}

# Convert type constant to export string
func type_to_export(int $type) str {
    if ($type == TYPE_INT()) { return "int"; }
    if ($type == TYPE_NUM()) { return "num"; }
    if ($type == TYPE_STR()) { return "str"; }
    if ($type == TYPE_ARRAY()) { return "array"; }
    if ($type == TYPE_HASH()) { return "hash"; }
    if ($type == TYPE_SCALAR()) { return "scalar"; }
    if ($type == TYPE_VOID()) { return "void"; }
    return "scalar";
}

# Generate extern function with body
func gen_extern_function(scalar $cg, scalar $fn) void {
    my str $ret_type = type_to_c_raw($fn->{"return_type"});
    my str $name = sanitize_name($fn->{"name"});

    emit($cg, $ret_type . " " . $name . "(");

    my scalar $params = $fn->{"params"};
    my int $i = 0;
    while ($i < $fn->{"param_count"}) {
        if ($i > 0) {
            emit($cg, ", ");
        }
        my scalar $param = $params->[$i];
        emit($cg, type_to_c_raw($param->{"param_type"}) . " " . $param->{"name"});
        $i = $i + 1;
    }

    if ($fn->{"param_count"} == 0) {
        emit($cg, "void");
    }

    emit($cg, ") ");
    $cg->{"in_extern"} = 1;  # Enable raw C code generation
    gen_block($cg, $fn->{"body"});
    $cg->{"in_extern"} = 0;  # Disable raw C code generation
    emit($cg, "\n\n");
}

# Generate extern function declaration
func gen_extern_decl(scalar $cg, scalar $fn) void {
    my str $ret_type = type_to_c_raw($fn->{"return_type"});
    emit($cg, $ret_type . " " . sanitize_name($fn->{"name"}) . "(");
    
    my scalar $params = $fn->{"params"};
    my int $i = 0;
    while ($i < $fn->{"param_count"}) {
        if ($i > 0) {
            emit($cg, ", ");
        }
        my scalar $param = $params->[$i];
        emit($cg, type_to_c_raw($param->{"param_type"}) . " " . $param->{"name"});
        $i = $i + 1;
    }
    
    if ($fn->{"param_count"} == 0) {
        emit($cg, "void");
    }
    
    emit($cg, ");\n");
}

# Convert type to raw C type (for extern functions)
func type_to_c_raw(int $type) str {
    if ($type == TYPE_INT()) { return "int"; }
    if ($type == TYPE_NUM()) { return "double"; }
    if ($type == TYPE_STR()) { return "char*"; }
    if ($type == TYPE_VOID()) { return "void"; }
    return "void*";
}

# ============================================================
# Main Entry Point
# ============================================================

func generate(scalar $ast, str $filename, int $debug_info, int $enable_profiling) str {
    my scalar $cg = codegen_new($filename, $debug_info, $enable_profiling);
    gen_program($cg, $ast);
    return get_output($cg);  # Join array into final string
}
