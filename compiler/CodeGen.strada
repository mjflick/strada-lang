/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# CodeGen.strada - C Code Generator for self-hosting Strada compiler
# Transforms AST into C source code

# ============================================================
# Code Generator State
# ============================================================

# Sanitize function names for C (replace :: with _)
func sanitize_name(str $name) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($name);
    while ($i < $len) {
        my str $ch = substr($name, $i, 1);
        if ($ch eq ":") {
            # Check for :: sequence and replace with single _
            if ($i + 1 < $len && substr($name, $i + 1, 1) eq ":") {
                $result = $result . "_";
                $i = $i + 1;  # Skip the second colon
            } else {
                $result = $result . "_";
            }
        } else {
            $result = $result . $ch;
        }
        $i = $i + 1;
    }
    return $result;
}

# Escape C keywords used as variable names by prefixing with v_
func escape_c_keyword(str $name) str {
    # C keywords that conflict with Strada variable names
    if ($name eq "for") { return "v_for"; }
    if ($name eq "while") { return "v_while"; }
    if ($name eq "if") { return "v_if"; }
    if ($name eq "else") { return "v_else"; }
    if ($name eq "switch") { return "v_switch"; }
    if ($name eq "case") { return "v_case"; }
    if ($name eq "default") { return "v_default"; }
    if ($name eq "break") { return "v_break"; }
    if ($name eq "continue") { return "v_continue"; }
    if ($name eq "return") { return "v_return"; }
    if ($name eq "goto") { return "v_goto"; }
    if ($name eq "do") { return "v_do"; }
    if ($name eq "int") { return "v_int"; }
    if ($name eq "char") { return "v_char"; }
    if ($name eq "float") { return "v_float"; }
    if ($name eq "double") { return "v_double"; }
    if ($name eq "void") { return "v_void"; }
    if ($name eq "long") { return "v_long"; }
    if ($name eq "short") { return "v_short"; }
    if ($name eq "unsigned") { return "v_unsigned"; }
    if ($name eq "signed") { return "v_signed"; }
    if ($name eq "const") { return "v_const"; }
    if ($name eq "static") { return "v_static"; }
    if ($name eq "extern") { return "v_extern"; }
    if ($name eq "register") { return "v_register"; }
    if ($name eq "volatile") { return "v_volatile"; }
    if ($name eq "auto") { return "v_auto"; }
    if ($name eq "struct") { return "v_struct"; }
    if ($name eq "union") { return "v_union"; }
    if ($name eq "enum") { return "v_enum"; }
    if ($name eq "typedef") { return "v_typedef"; }
    if ($name eq "sizeof") { return "v_sizeof"; }
    # C99/C11 keywords
    if ($name eq "inline") { return "v_inline"; }
    if ($name eq "restrict") { return "v_restrict"; }
    if ($name eq "_Bool") { return "v_Bool"; }
    if ($name eq "_Complex") { return "v_Complex"; }
    if ($name eq "_Imaginary") { return "v_Imaginary"; }
    return $name;
}

func codegen_new(str $filename, int $debug_info, int $enable_profiling) scalar {
    my hash %cg = ();
    # StringBuilder for O(1) amortized append (no O(n^2) string concat)
    $cg{"output_sb"} = sb_new();
    $cg{"preamble_content"} = "";  # Saved preamble when doing multi-phase
    $cg{"funcs_content"} = "";     # Saved funcs when doing multi-phase
    $cg{"oop_fwd_decls"} = "";     # OOP init forward declarations (generated after methods tracked)
    $cg{"indent"} = 0;
    $cg{"debug_info"} = $debug_info;  # Emit #line directives for debugging
    $cg{"enable_profiling"} = $enable_profiling;  # Emit function profiling code
    $cg{"last_line"} = 0;  # Track last emitted line to avoid duplicates
    $cg{"functions"} = {};  # Map function name -> function info
    $cg{"in_extern"} = 0;   # Track if we're inside an extern function
    $cg{"extern_params"} = {};  # Map param name -> type for extern functions
    $cg{"in_main"} = 0;     # Track if we're inside main function
    $cg{"package"} = "";    # Current package name
    $cg{"filename"} = $filename;  # Source file name for __FILE__
    $cg{"map_counter"} = 0;     # Counter for unique map variable names
    $cg{"sort_counter"} = 0;    # Counter for unique sort variable names
    $cg{"grep_counter"} = 0;    # Counter for unique grep variable names
    $cg{"foreach_counter"} = 0; # Counter for unique foreach variable names
    $cg{"in_map_block"} = 0;  # Track if inside map block (for $_)
    $cg{"in_sort_block"} = 0; # Track if inside sort block (for $a, $b)
    $cg{"in_grep_block"} = 0; # Track if inside grep block (for $_)
    $cg{"struct_vars"} = {};  # Map variable name -> struct type name
    $cg{"struct_defs"} = {};  # Map struct name -> struct definition with field info
    $cg{"anon_func_counter"} = 0;  # Counter for unique anonymous function names
    $cg{"anon_func_decls"} = "";   # Forward declarations for anonymous functions
    $cg{"anon_func_defs"} = "";    # Function definitions for anonymous functions
    $cg{"in_anon_func"} = 0;       # Track if inside anonymous function
    $cg{"anon_param_str"} = "";    # Comma-separated param names
    $cg{"anon_local_str"} = "";    # Comma-separated local names
    $cg{"anon_capture_str"} = "";  # Comma-separated capture names
    $cg{"anon_capture_count"} = 0; # Number of captures
    $cg{"current_func_name"} = ""; # Current function name for profiling
    $cg{"global_count"} = 0;       # Number of global variables
    my array @empty_globals = ();
    $cg{"globals"} = \@empty_globals;  # Array of global variable declarations
    $cg{"switch_counter"} = 0;     # Counter for unique switch variable names
    # OOP method registration - per-package tracking
    my hash %empty_pkg_methods = ();
    $cg{"pkg_methods"} = \%empty_pkg_methods;  # Hash: package -> array of method info
    my array @empty_pkg_list = ();
    $cg{"pkg_list"} = \@empty_pkg_list;        # Array of package names (to avoid keys())
    $cg{"pkg_count"} = 0;                      # Number of packages
    $cg{"pkg_seen"} = "|";                     # String of seen package names (for fast lookup)
    $cg{"method_wrappers"} = "";   # Generated wrapper functions
    # Scope tracking for memory management (using string-encoded var lists for bootstrap compat)
    # Each scope is stored as "var1,var2,var3" string (bootstrap doesn't support scalar(@arr))
    my array @scope_vars = ();   # Array of scope strings
    my array @scope_counts = (); # Parallel array of counts
    $cg{"scope_vars"} = \@scope_vars;
    $cg{"scope_counts"} = \@scope_counts;
    $cg{"scope_depth"} = 0;
    $cg{"cleanup_enabled"} = 1;  # Enable scope-based memory cleanup
    $cg{"returns_struct"} = 0;   # Track if current function returns struct
    $cg{"try_depth"} = 0;        # Track nesting depth in try blocks (for proper cleanup on return)
    # Track label-to-scope-depth for proper cleanup on labeled break/continue
    my hash %label_depths = ();
    $cg{"label_depths"} = \%label_depths;
    # Struct scope tracking - stores "name:type,name:type" format for struct vars needing cleanup
    my array @scope_struct_vars = ();
    my array @scope_struct_counts = ();
    $cg{"scope_struct_vars"} = \@scope_struct_vars;
    $cg{"scope_struct_counts"} = \@scope_struct_counts;
    $cg{"skip_struct_cleanup"} = "";  # Struct var name to skip during cleanup (for returns)
    return \%cg;
}

# Push a new scope onto the scope stack
func scope_push(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my scalar $struct_vars = $cg->{"scope_struct_vars"};
    my scalar $struct_counts = $cg->{"scope_struct_counts"};
    my int $depth = $cg->{"scope_depth"};
    push($vars, "");  # Empty scope
    push($counts, 0);
    push($struct_vars, "");  # Empty struct scope
    push($struct_counts, 0);
    $cg->{"scope_depth"} = $depth + 1;
}

# Track a variable in the current scope
func scope_track_var(scalar $cg, str $name) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    if ($depth == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my str $current = $vars->[$depth - 1];
    my int $count = $counts->[$depth - 1];
    if ($count == 0) {
        $vars->[$depth - 1] = $name;
    } else {
        $vars->[$depth - 1] = $current . "," . $name;
    }
    $counts->[$depth - 1] = $count + 1;
}

# Track a struct variable in the current scope (stored as "name:type" format)
func scope_track_struct_var(scalar $cg, str $name, str $struct_type) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    if ($depth == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_struct_vars"};
    my scalar $counts = $cg->{"scope_struct_counts"};
    my str $current = $vars->[$depth - 1];
    my int $count = $counts->[$depth - 1];
    my str $entry = $name . ":" . $struct_type;
    if ($count == 0) {
        $vars->[$depth - 1] = $entry;
    } else {
        $vars->[$depth - 1] = $current . "," . $entry;
    }
    $counts->[$depth - 1] = $count + 1;
}

# Emit cleanup for current scope and pop it
func scope_pop(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    if ($depth == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my scalar $struct_vars = $cg->{"scope_struct_vars"};
    my scalar $struct_counts = $cg->{"scope_struct_counts"};
    my str $scope_str = $vars->[$depth - 1];
    my int $count = $counts->[$depth - 1];

    emit_scope_decref($cg, $scope_str, $count);

    # Also cleanup struct variables
    my str $struct_str = $struct_vars->[$depth - 1];
    my int $struct_count = $struct_counts->[$depth - 1];
    emit_scope_struct_cleanup($cg, $struct_str, $struct_count);

    pop($vars);
    pop($counts);
    pop($struct_vars);
    pop($struct_counts);
    $cg->{"scope_depth"} = $depth - 1;
}

# Check if a variable name is in a comma-separated string
func is_var_in_list(str $var, str $list) int {
    if (length($list) == 0) { return 0; }
    my int $pos = 0;
    my int $len = length($list);
    my str $cur = "";
    while ($pos <= $len) {
        if ($pos == $len) {
            if ($cur eq $var) { return 1; }
            $pos = $pos + 1;
        } else {
            my str $ch = substr($list, $pos, 1);
            if ($ch eq ",") {
                if ($cur eq $var) { return 1; }
                $cur = "";
            } else {
                $cur = $cur . $ch;
            }
            $pos = $pos + 1;
        }
    }
    return 0;
}

# Helper to emit decref for all vars in a scope string
func emit_scope_decref(scalar $cg, str $scope_str, int $count) void {
    if ($count == 0 || length($scope_str) == 0) {
        return;
    }
    # Get capture list to skip captured variables in closures
    my int $in_anon = $cg->{"in_anon_func"};
    my str $capture_str = $cg->{"anon_capture_str"};

    my int $pos = 0;
    my int $len = length($scope_str);
    my str $var_name = "";
    while ($pos <= $len) {
        if ($pos == $len) {
            if (length($var_name) > 0) {
                # Skip captured variables - they're accessed via __captures, not local vars
                if ($in_anon == 0 || is_var_in_list($var_name, $capture_str) == 0) {
                    emit_indent($cg);
                    emit($cg, "strada_decref(" . $var_name . ");\n");
                }
            }
            $pos = $pos + 1;
        } else {
            my str $ch = substr($scope_str, $pos, 1);
            if ($ch eq ",") {
                if (length($var_name) > 0) {
                    # Skip captured variables
                    if ($in_anon == 0 || is_var_in_list($var_name, $capture_str) == 0) {
                        emit_indent($cg);
                        emit($cg, "strada_decref(" . $var_name . ");\n");
                    }
                }
                $var_name = "";
            } else {
                $var_name = $var_name . $ch;
            }
            $pos = $pos + 1;
        }
    }
}

# Helper to emit cleanup for struct variables in a scope
# Format is "name:type,name:type"
func emit_scope_struct_cleanup(scalar $cg, str $scope_str, int $count) void {
    if ($count == 0 || length($scope_str) == 0) {
        return;
    }

    my scalar $struct_defs = $cg->{"struct_defs"};

    my int $pos = 0;
    my int $len = length($scope_str);
    my str $entry = "";
    while ($pos <= $len) {
        if ($pos == $len) {
            if (length($entry) > 0) {
                emit_struct_var_cleanup($cg, $entry, $struct_defs);
            }
            $pos = $pos + 1;
        } else {
            my str $ch = substr($scope_str, $pos, 1);
            if ($ch eq ",") {
                if (length($entry) > 0) {
                    emit_struct_var_cleanup($cg, $entry, $struct_defs);
                }
                $entry = "";
            } else {
                $entry = $entry . $ch;
            }
            $pos = $pos + 1;
        }
    }
}

# Emit cleanup for a single struct variable (entry format: "name:type")
func emit_struct_var_cleanup(scalar $cg, str $entry, scalar $struct_defs) void {
    # Parse "name:type" format
    my int $colon_pos = index($entry, ":");
    if ($colon_pos < 0) {
        return;
    }
    my str $var_name = substr($entry, 0, $colon_pos);
    my str $struct_type = substr($entry, $colon_pos + 1, length($entry) - $colon_pos - 1);

    # Skip if this is the struct being returned
    my str $skip = $cg->{"skip_struct_cleanup"};
    if (length($skip) > 0 && $var_name eq $skip) {
        return;
    }

    # Check if we have info about this struct type (avoid exists() for bootstrap compatibility)
    my scalar $struct_info = $struct_defs->{$struct_type};
    if ($struct_info) {
        # Decref all StradaValue* fields (non-funcptr fields)
        my scalar $field_names = $struct_info->{"field_names"};
        my int $field_count = $struct_info->{"field_count"};
        my scalar $fields = $struct_info->{"fields"};

        my int $f = 0;
        while ($f < $field_count) {
            my str $fname = $field_names->[$f];
            my scalar $finfo = $fields->{$fname};
            # Only decref non-funcptr fields (they're StradaValue*)
            if ($finfo->{"is_funcptr"} == 0) {
                emit_indent($cg);
                emit($cg, "if (" . $var_name . "->" . $fname . ") strada_decref(" . $var_name . "->" . $fname . ");\n");
            }
            $f = $f + 1;
        }
    }

    # Free the struct itself
    emit_indent($cg);
    emit($cg, "free(" . $var_name . ");\n");
}

# Emit cleanup for current scope without popping (for early returns)
func scope_emit_cleanup(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    if ($depth == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my str $scope_str = $vars->[$depth - 1];
    my int $count = $counts->[$depth - 1];
    emit_scope_decref($cg, $scope_str, $count);

    # Also cleanup struct variables
    my scalar $struct_vars = $cg->{"scope_struct_vars"};
    my scalar $struct_counts = $cg->{"scope_struct_counts"};
    my str $struct_str = $struct_vars->[$depth - 1];
    my int $struct_count = $struct_counts->[$depth - 1];
    emit_scope_struct_cleanup($cg, $struct_str, $struct_count);
}

# Emit cleanup for all scopes (for return statements)
func scope_emit_all_cleanup(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my scalar $struct_vars = $cg->{"scope_struct_vars"};
    my scalar $struct_counts = $cg->{"scope_struct_counts"};

    # Emit cleanup from innermost to outermost scope
    my int $d = $depth;
    while ($d > 0) {
        my str $scope_str = $vars->[$d - 1];
        my int $count = $counts->[$d - 1];
        emit_scope_decref($cg, $scope_str, $count);

        # Also cleanup struct variables
        my str $struct_str = $struct_vars->[$d - 1];
        my int $struct_count = $struct_counts->[$d - 1];
        emit_scope_struct_cleanup($cg, $struct_str, $struct_count);

        $d = $d - 1;
    }

    # Also decref function parameters (we incref'd them at function entry)
    my int $pn_count = $cg->{"func_param_count"} + 0;
    if ($pn_count > 0) {
        my scalar $param_names = $cg->{"func_param_names"};
        my int $pn_i = 0;
        while ($pn_i < $pn_count) {
            emit_indent($cg);
            my str $pname = $param_names->[$pn_i];
            emit($cg, "strada_decref(" . $pname . ");\n");
            $pn_i = $pn_i + 1;
        }
    }
}

# Emit cleanup for scopes from current depth down to (but not including) target_depth
# Used for labeled break/continue to clean up intermediate scopes
func scope_emit_cleanup_to_depth(scalar $cg, int $target_depth) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my scalar $struct_vars = $cg->{"scope_struct_vars"};
    my scalar $struct_counts = $cg->{"scope_struct_counts"};

    # Emit cleanup from innermost scope down to (but not including) target_depth
    my int $d = $depth;
    while ($d > $target_depth) {
        my str $scope_str = $vars->[$d - 1];
        my int $count = $counts->[$d - 1];
        emit_scope_decref($cg, $scope_str, $count);

        # Also cleanup struct variables
        my str $struct_str = $struct_vars->[$d - 1];
        my int $struct_count = $struct_counts->[$d - 1];
        emit_scope_struct_cleanup($cg, $struct_str, $struct_count);

        $d = $d - 1;
    }
}

# Emit STRADA_TRY_POP() for each active try block (for early returns in try blocks)
func emit_try_cleanup(scalar $cg) void {
    my int $try_depth = $cg->{"try_depth"};
    while ($try_depth > 0) {
        emit_indent($cg);
        emit($cg, "STRADA_TRY_POP();\n");
        $try_depth = $try_depth - 1;
    }
}

# Register a function with its parameters for default arg handling
func codegen_register_function(scalar $cg, scalar $fn) void {
    my str $name = sanitize_name($fn->{"name"});
    my hash %info = ();
    $info{"param_count"} = $fn->{"param_count"};
    $info{"params"} = $fn->{"params"};
    $info{"return_type"} = $fn->{"return_type"};
    # Track if this is an extern function for call site conversion
    if ($fn->{"type"} == NODE_EXTERN_FUNC()) {
        $info{"is_extern"} = 1;
        # Track if this is a C-style extern (raw C types, direct calls)
        if ($fn->{"is_c_extern"} == 1) {
            $info{"is_c_extern"} = 1;
        } else {
            $info{"is_c_extern"} = 0;
        }
    } else {
        $info{"is_extern"} = 0;
        $info{"is_c_extern"} = 0;
    }

    # Track variadic function info
    $info{"is_variadic"} = $fn->{"is_variadic"};
    $info{"variadic_param_idx"} = -1;
    if ($fn->{"is_variadic"} == 1) {
        my scalar $params = $fn->{"params"};
        my int $pc = $fn->{"param_count"};
        for (my int $i = 0; $i < $pc; $i = $i + 1) {
            if ($params->[$i]->{"is_variadic"} == 1) {
                $info{"variadic_param_idx"} = $i;
            }
        }
    }

    $cg->{"functions"}->{$name} = \%info;
}

# Helper to get arg from packed args array
func gen_oop_helper_decl() str {
    my str $code = "";
    $code = $code . "/* OOP method dispatch helper */\n";
    $code = $code . "static StradaValue* __strada_get_arg(StradaValue* args, int idx) {\n";
    $code = $code . "    if (!args || args->type != STRADA_ARRAY) return NULL;\n";
    $code = $code . "    if ((size_t)idx >= args->value.av->size) return NULL;\n";
    $code = $code . "    return args->value.av->elements[idx];\n";
    $code = $code . "}\n\n";
    return $code;
}

# Track a method for OOP registration (per-package)
func codegen_track_method(scalar $cg, scalar $fn, str $pkg) void {
    my str $name = sanitize_name($fn->{"name"});

    # Skip main, extern functions, and functions starting with underscore
    if ($name eq "main") { return; }
    if ($fn->{"type"} == NODE_EXTERN_FUNC()) { return; }
    if (substr($name, 0, 1) eq "_") { return; }

    # Methods must have at least one parameter (self)
    # Functions with 0 params are class init functions, not methods
    my int $param_count = $fn->{"param_count"};
    if ($param_count == 0) { return; }

    # Check if function name starts with package prefix (e.g., Cannoli_)
    my str $prefix = $pkg . "_";
    my int $prefix_len = length($prefix);
    if (length($name) <= $prefix_len) { return; }
    if (substr($name, 0, $prefix_len) ne $prefix) { return; }

    # Get method name without prefix
    my str $method = substr($name, $prefix_len, length($name) - $prefix_len);

    # Track method info
    my hash %minfo = ();
    $minfo{"func_name"} = $name;
    $minfo{"method_name"} = $method;
    $minfo{"param_count"} = $fn->{"param_count"};
    $minfo{"params"} = $fn->{"params"};
    $minfo{"return_type"} = $fn->{"return_type"};
    $minfo{"package"} = $pkg;
    $minfo{"is_variadic"} = $fn->{"is_variadic"};
    # Find variadic param index
    my int $variadic_idx = -1;
    if ($fn->{"is_variadic"} == 1) {
        my scalar $params = $fn->{"params"};
        my int $pc = $fn->{"param_count"};
        for (my int $vi = 0; $vi < $pc; $vi = $vi + 1) {
            if ($params->[$vi]->{"is_variadic"} == 1) {
                $variadic_idx = $vi;
            }
        }
    }
    $minfo{"variadic_param_idx"} = $variadic_idx;

    # Get or create the methods info for this package
    # Use string index check instead of exists() for bootstrap compatibility
    my str $pkg_marker = "|" . $pkg . "|";
    my str $seen = $cg->{"pkg_seen"};
    my int $found_idx = index($seen, $pkg_marker);
    if ($found_idx < 0) {
        # New package - initialize it
        my hash %pkg_info = ();
        my array @new_arr = ();
        $pkg_info{"methods"} = \@new_arr;
        $pkg_info{"count"} = 0;
        my scalar $pkg_methods = $cg->{"pkg_methods"};
        $pkg_methods->{$pkg} = \%pkg_info;
        # Also track package name in the list
        my int $pkg_idx = $cg->{"pkg_count"};
        $cg->{"pkg_list"}->[$pkg_idx] = $pkg;
        $cg->{"pkg_count"} = $pkg_idx + 1;
        # Mark as seen
        $cg->{"pkg_seen"} = $seen . $pkg . "|";
    }
    my scalar $pkg_methods = $cg->{"pkg_methods"};
    my scalar $pkg_info = $pkg_methods->{$pkg};
    my int $idx = $pkg_info->{"count"};
    $pkg_info->{"methods"}->[$idx] = \%minfo;
    $pkg_info->{"count"} = $idx + 1;
}

# Generate method wrapper functions for a single package
# $pkg_info is a hash with "methods" array and "count" int
func gen_method_wrappers_for_pkg(str $pkg, scalar $pkg_info) str {
    my str $code = "";
    my int $method_count = $pkg_info->{"count"};
    my scalar $methods = $pkg_info->{"methods"};
    if ($method_count == 0) { return ""; }

    $code = $code . "/* OOP method wrappers for package " . $pkg . " */\n";

    my int $i = 0;
    while ($i < $method_count) {
        my scalar $m = $methods->[$i];
        my str $func_name = $m->{"func_name"};
        my int $param_count = $m->{"param_count"};
        my int $ret_type = $m->{"return_type"};
        my int $is_void = $ret_type == TYPE_VOID();

        # Generate wrapper: __wrap_FuncName(self, args) { ... }
        $code = $code . "static StradaValue* __wrap_" . $func_name . "(StradaValue* self, StradaValue* args) {\n";

        if ($param_count <= 1) {
            # 0 or 1 param (just self)
            $code = $code . "    (void)args;\n";
            if ($is_void == 1) {
                $code = $code . "    " . $func_name . "(self);\n";
                $code = $code . "    return strada_undef_static();\n";
            } else {
                $code = $code . "    return " . $func_name . "(self);\n";
            }
        } else {
            # Multiple params - unpack from args
            my int $is_variadic = $m->{"is_variadic"};
            my int $variadic_idx = $m->{"variadic_param_idx"};

            if ($is_variadic == 1) {
                # Variadic method - need special handling
                # variadic_idx is the index in the param list (0=self, 1+=other params)
                # For params before variadic: use __strada_get_arg
                # For variadic param: pass remaining args as array

                if ($variadic_idx == 1) {
                    # Variadic is first param after self - pass args directly
                    if ($is_void == 1) {
                        $code = $code . "    " . $func_name . "(self, args);\n";
                        $code = $code . "    return strada_undef_static();\n";
                    } else {
                        $code = $code . "    return " . $func_name . "(self, args);\n";
                    }
                } else {
                    # There are fixed params before the variadic one
                    # Build sub-array for variadic param
                    $code = $code . "    StradaArray *__args = strada_deref_array(args);\n";
                    $code = $code . "    StradaValue *__va_arr = strada_new_array();\n";
                    my int $var_start = $variadic_idx - 1;  # Adjust for self being param 0
                    $code = $code . "    for (size_t __i = " . $var_start . "; __i < __args->size; __i++) {\n";
                    $code = $code . "        strada_array_push(strada_deref_array(__va_arr), __args->elements[__i]);\n";
                    $code = $code . "        strada_incref(__args->elements[__i]);\n";
                    $code = $code . "    }\n";
                    if ($is_void == 1) {
                        $code = $code . "    " . $func_name . "(self";
                    } else {
                        $code = $code . "    return " . $func_name . "(self";
                    }
                    # Emit fixed params
                    my int $j = 1;  # Skip self
                    while ($j < $variadic_idx) {
                        my int $arg_idx = $j - 1;
                        $code = $code . ", __strada_get_arg(args, " . $arg_idx . ")";
                        $j = $j + 1;
                    }
                    # Emit variadic array
                    $code = $code . ", __va_arr);\n";
                    if ($is_void == 1) {
                        $code = $code . "    return strada_undef_static();\n";
                    }
                }
            } else {
                # Non-variadic - unpack all args normally
                if ($is_void == 1) {
                    $code = $code . "    " . $func_name . "(self";
                } else {
                    $code = $code . "    return " . $func_name . "(self";
                }
                my int $j = 1;  # Skip self
                while ($j < $param_count) {
                    my int $arg_idx = $j - 1;
                    $code = $code . ", __strada_get_arg(args, " . $arg_idx . ")";
                    $j = $j + 1;
                }
                $code = $code . ");\n";
                if ($is_void == 1) {
                    $code = $code . "    return strada_undef_static();\n";
                }
            }
        }

        $code = $code . "}\n\n";
        $i = $i + 1;
    }

    # Generate initialization function for this package
    $code = $code . "/* OOP method registration initializer */\n";
    $code = $code . "static int __" . $pkg . "_oop_initialized = 0;\n";
    $code = $code . "void __" . $pkg . "_oop_init(void) {\n";
    $code = $code . "    if (__" . $pkg . "_oop_initialized) return;\n";
    $code = $code . "    __" . $pkg . "_oop_initialized = 1;\n\n";

    $i = 0;
    while ($i < $method_count) {
        my scalar $m = $methods->[$i];
        my str $func_name = $m->{"func_name"};
        my str $method_name = $m->{"method_name"};

        $code = $code . "    strada_method_register(\"" . $pkg . "\", \"" . $method_name . "\", __wrap_" . $func_name . ");\n";
        $i = $i + 1;
    }

    $code = $code . "}\n\n";

    return $code;
}

# Generate method wrappers for ALL packages
func gen_all_method_wrappers(scalar $cg) str {
    my str $code = "";
    my int $num_pkgs = get_oop_pkg_count($cg);
    if ($num_pkgs == 0) { return ""; }

    my scalar $pkg_methods = $cg->{"pkg_methods"};
    my scalar $pkg_list = get_oop_packages($cg);

    # Add the helper function once
    $code = $code . gen_oop_helper_decl();

    # Generate wrappers for each package
    my int $i = 0;
    while ($i < $num_pkgs) {
        my str $pkg = $pkg_list->[$i];
        my scalar $pkg_info = $pkg_methods->{$pkg};
        $code = $code . gen_method_wrappers_for_pkg($pkg, $pkg_info);
        $i = $i + 1;
    }

    return $code;
}

# Get all packages that have registered methods
# Returns the pkg_list array reference (not a copy)
func get_oop_packages(scalar $cg) scalar {
    return $cg->{"pkg_list"};
}

# Get count of packages
func get_oop_pkg_count(scalar $cg) int {
    return $cg->{"pkg_count"};
}

# Check if an expression is clearly a scalar value (not an array or function call)
# Used to determine if we need to wrap it when assigning to an array variable
func is_scalar_expr(scalar $expr) int {
    my int $type = $expr->{"type"};

    # Scalar variables ($x)
    if ($type == NODE_VARIABLE()) {
        my str $sigil = $expr->{"sigil"};
        if ($sigil eq "$") {
            return 1;
        }
        return 0;
    }

    # Literal values
    if ($type == NODE_INT_LITERAL() || $type == NODE_NUM_LITERAL() || $type == NODE_STR_LITERAL()) {
        return 1;
    }

    # Unary operators on scalars
    if ($type == NODE_UNARY_OP()) {
        return 1;
    }

    # Binary operators produce scalars (arithmetic, comparison, etc.)
    if ($type == NODE_BINARY_OP()) {
        return 1;
    }

    # Ternary produces a scalar
    if ($type == NODE_TERNARY()) {
        return 1;
    }

    # Array/hash subscript returns a scalar
    if ($type == NODE_SUBSCRIPT() || $type == NODE_HASH_ACCESS()) {
        return 1;
    }

    # Field access returns a scalar
    if ($type == NODE_FIELD_ACCESS()) {
        return 1;
    }

    # Everything else (function calls, deref, etc.) - assume not scalar
    return 0;
}

func emit(scalar $cg, str $text) void {
    # O(1) amortized append using StringBuilder
    sb_append($cg->{"output_sb"}, $text);
}

# Emit #line directive for source-level debugging
# Format: #line <line_number> "<filename>"
func emit_line_directive(scalar $cg, int $line) void {
    if ($cg->{"debug_info"} == 0) {
        return;
    }
    if ($line <= 0) {
        return;
    }
    # Avoid emitting duplicate line directives
    if ($line == $cg->{"last_line"}) {
        return;
    }
    $cg->{"last_line"} = $line;

    my str $filename = $cg->{"filename"};
    emit($cg, "#line " . $line . " \"" . $filename . "\"\n");
}

# Emit #line directive before a statement (with indent)
func emit_line_for_stmt(scalar $cg, scalar $stmt) void {
    if ($cg->{"debug_info"} == 0) {
        return;
    }
    # stmt should always be defined when called from gen_statement
    my int $line = $stmt->{"line"};
    if ($line > 0) {
        emit_line_directive($cg, $line);
    }
}

# Generate string comparison with proper cleanup of temporaries
# If one side is a string literal, use strada_str_*_lit to avoid creating temporaries
func gen_str_cmp(scalar $cg, scalar $expr, str $op) void {
    my scalar $left = $expr->{"left"};
    my scalar $right = $expr->{"right"};
    my int $left_type = $left->{"type"};
    my int $right_type = $right->{"type"};

    # Determine comparison function suffix and C operator
    my str $cmp_suffix = $op;
    my str $cmp_op = "== 0";
    if ($op eq "ne") {
        $cmp_op = "!= 0";
    } elsif ($op eq "lt") {
        $cmp_op = "< 0";
    } elsif ($op eq "gt") {
        $cmp_op = "> 0";
    } elsif ($op eq "le") {
        $cmp_op = "<= 0";
    } elsif ($op eq "ge") {
        $cmp_op = ">= 0";
    }

    # Case 1: Right side is string literal - use strada_str_*_lit (no temp allocation)
    if ($right_type == NODE_STR_LITERAL()) {
        # Check if left needs cleanup
        if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($left) == 1) {
            emit($cg, "({ StradaValue *__cmp_l = ");
            gen_expression($cg, $left);
            emit($cg, "; int __cmp_r = strada_str_");
            emit($cg, $cmp_suffix);
            emit($cg, "_lit(__cmp_l, ");
            gen_str_literal_c($cg, $right->{"value"});
            emit($cg, "); strada_decref(__cmp_l); strada_new_int(__cmp_r); })");
        } else {
            emit($cg, "strada_new_int(strada_str_");
            emit($cg, $cmp_suffix);
            emit($cg, "_lit(");
            gen_expression($cg, $left);
            emit($cg, ", ");
            gen_str_literal_c($cg, $right->{"value"});
            emit($cg, "))");
        }
        return;
    }

    # Case 2: Left side is string literal - swap and use strada_str_*_lit
    if ($left_type == NODE_STR_LITERAL()) {
        my str $swapped = $cmp_suffix;
        if ($op eq "lt") {
            $swapped = "gt";
        } elsif ($op eq "gt") {
            $swapped = "lt";
        } elsif ($op eq "le") {
            $swapped = "ge";
        } elsif ($op eq "ge") {
            $swapped = "le";
        }
        # Check if right needs cleanup
        if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($right) == 1) {
            emit($cg, "({ StradaValue *__cmp_r = ");
            gen_expression($cg, $right);
            emit($cg, "; int __cmp_res = strada_str_");
            emit($cg, $swapped);
            emit($cg, "_lit(__cmp_r, ");
            gen_str_literal_c($cg, $left->{"value"});
            emit($cg, "); strada_decref(__cmp_r); strada_new_int(__cmp_res); })");
        } else {
            emit($cg, "strada_new_int(strada_str_");
            emit($cg, $swapped);
            emit($cg, "_lit(");
            gen_expression($cg, $right);
            emit($cg, ", ");
            gen_str_literal_c($cg, $left->{"value"});
            emit($cg, "))");
        }
        return;
    }

    # Case 3: Neither side is a string literal - use standard comparison
    emit($cg, "strada_new_int(strcmp(strada_to_str(");
    gen_expression($cg, $left);
    emit($cg, "), strada_to_str(");
    gen_expression($cg, $right);
    emit($cg, ")) ");
    emit($cg, $cmp_op);
    emit($cg, ")");
}

# Emit a C string literal with proper escaping
func gen_str_literal_c(scalar $cg, str $val) void {
    emit($cg, "\"");
    my int $i = 0;
    my int $len = bytes($val);
    my str $bs = chr(92);
    while ($i < $len) {
        my str $ch = substr_bytes($val, $i, 1);
        my int $byte = ord($ch);
        if ($byte == 92) {
            emit($cg, $bs);
            emit($cg, $bs);
        } elsif ($byte == 34) {
            emit($cg, $bs);
            emit($cg, chr(34));
        } elsif ($byte == 10) {
            emit($cg, $bs);
            emit($cg, "n");
        } elsif ($byte == 13) {
            emit($cg, $bs);
            emit($cg, "r");
        } elsif ($byte == 9) {
            emit($cg, $bs);
            emit($cg, "t");
        } elsif ($byte >= 32 && $byte < 127) {
            emit($cg, $ch);
        } else {
            my int $o1 = $byte / 64;
            my int $tmp = $byte / 8;
            my int $o2 = $tmp - ($o1 * 8);
            my int $o3 = $byte - ($tmp * 8);
            emit($cg, $bs);
            emit($cg, $o1);
            emit($cg, $o2);
            emit($cg, $o3);
        }
        $i = $i + 1;
    }
    emit($cg, "\"");
}

# Get accumulated output as a single string
func get_output(scalar $cg) str {
    # Get the current output from StringBuilder
    my str $final = sb_to_string($cg->{"output_sb"});

    # Check if we used multi-phase generation
    my str $preamble = $cg->{"preamble_content"};
    if (length($preamble) > 0) {
        my str $funcs = $cg->{"funcs_content"};
        my str $anon_decls = $cg->{"anon_func_decls"};
        my str $oop_decls = $cg->{"oop_fwd_decls"};

        # Build result: preamble + oop_decls + anon_decls + funcs + final
        my str $result = $preamble;
        if (length($oop_decls) > 0) {
            $result = $result . $oop_decls;
        }
        if (length($anon_decls) > 0) {
            $result = $result . "/* Anonymous function forward declarations */\n";
            $result = $result . $anon_decls;
            $result = $result . "\n";
        }
        $result = $result . $funcs;
        $result = $result . $final;
        return $result;
    }

    return $final;
}

# Set output - for save/restore pattern in anonymous functions
func set_output(scalar $cg, str $text) void {
    sb_clear($cg->{"output_sb"});
    sb_append($cg->{"output_sb"}, $text);
}

func emit_line(scalar $cg, str $text) void {
    emit_indent($cg);
    emit($cg, $text . "\n");
}

func emit_indent(scalar $cg) void {
    my int $i = 0;
    while ($i < $cg->{"indent"}) {
        emit($cg, "    ");
        $i = $i + 1;
    }
}

func indent(scalar $cg) void {
    $cg->{"indent"} = $cg->{"indent"} + 1;
}

func dedent(scalar $cg) void {
    $cg->{"indent"} = $cg->{"indent"} - 1;
}

# Check if name is in comma-separated string (workaround for bootstrap limitation)
func str_contains_name(str $list, str $name) int {
    my str $search = "," . $name . ",";
    my str $padded = "," . $list . ",";
    my int $pos = index($padded, $search);
    if ($pos >= 0) { return 1; }
    return 0;
}

# Get index of name in comma-separated capture string
func get_capture_index(str $list, str $name) int {
    if ($list eq "") { return -1; }
    my int $idx = 0;
    my int $start = 0;
    my int $len = length($list);
    my int $i = 0;
    while ($i <= $len) {
        my str $ch = "";
        if ($i < $len) { $ch = substr($list, $i, 1); }
        if ($ch eq "," || $i == $len) {
            my str $part = substr($list, $start, $i - $start);
            if ($part eq $name) { return $idx; }
            $idx = $idx + 1;
            $start = $i + 1;
        }
        $i = $i + 1;
    }
    return -1;
}

# Generate code for regex pattern with variable interpolation
# Pattern like "$foo" or "^$pattern$" gets converted to runtime string building
func gen_regex_interpolated_pattern(scalar $cg, str $pattern) void {
    # Parse pattern into parts (literals and variables)
    # We manually track the count since bootstrap doesn't support scalar(@array)
    my array @parts = ();
    my int $num_parts = 0;
    my int $len = length($pattern);
    my int $i = 0;
    my str $literal = "";

    while ($i < $len) {
        my str $ch = substr($pattern, $i, 1);

        if ($ch eq "$") {
            # Save any accumulated literal
            if (length($literal) > 0) {
                my hash %part = ();
                $part{"type"} = "lit";
                $part{"value"} = $literal;
                push(@parts, \%part);
                $num_parts = $num_parts + 1;
                $literal = "";
            }

            # Parse variable name
            $i = $i + 1;
            my str $varname = "";
            while ($i < $len) {
                my str $vch = substr($pattern, $i, 1);
                if ($vch eq "_" || ($vch ge "a" && $vch le "z") || ($vch ge "A" && $vch le "Z") || ($vch ge "0" && $vch le "9")) {
                    $varname = $varname . $vch;
                    $i = $i + 1;
                } else {
                    last;
                }
            }

            if (length($varname) > 0) {
                my hash %part = ();
                $part{"type"} = "var";
                $part{"value"} = $varname;
                push(@parts, \%part);
                $num_parts = $num_parts + 1;
            } else {
                # Not a variable - preserve $ as literal (regex end-of-line anchor)
                $literal = $literal . "$";
            }
        } else {
            $literal = $literal . $ch;
            $i = $i + 1;
        }
    }

    # Save any remaining literal
    if (length($literal) > 0) {
        my hash %part = ();
        $part{"type"} = "lit";
        $part{"value"} = $literal;
        push(@parts, \%part);
        $num_parts = $num_parts + 1;
    }

    # Generate concatenation code
    if ($num_parts == 0) {
        emit($cg, "strada_new_str(\"\")");
        return;
    }
    if ($num_parts == 1) {
        my scalar $p = @parts[0];
        if ($p->{"type"} eq "var") {
            emit($cg, $p->{"value"});
        } else {
            emit($cg, "strada_new_str(\"");
            emit_escaped_string($cg, $p->{"value"});
            emit($cg, "\")");
        }
        return;
    }

    # Multiple parts - build with strada_concat_sv chain (fast, no copies)
    # strada_concat_sv(a, strada_concat_sv(b, c))
    my int $pi = 0;
    while ($pi < $num_parts - 1) {
        emit($cg, "strada_concat_sv(");
        $pi = $pi + 1;
    }

    # Emit first part
    my scalar $first_p = @parts[0];
    if ($first_p->{"type"} eq "var") {
        emit($cg, $first_p->{"value"});
    } else {
        emit($cg, "strada_new_str(\"");
        emit_escaped_string($cg, $first_p->{"value"});
        emit($cg, "\")");
    }
    emit($cg, ", ");

    # Emit remaining parts
    $pi = 1;
    while ($pi < $num_parts) {
        my scalar $p = @parts[$pi];
        if ($p->{"type"} eq "var") {
            emit($cg, $p->{"value"});
        } else {
            emit($cg, "strada_new_str(\"");
            emit_escaped_string($cg, $p->{"value"});
            emit($cg, "\")");
        }
        emit($cg, ")");
        if ($pi < $num_parts - 1) {
            emit($cg, ", ");
        }
        $pi = $pi + 1;
    }
}

# Helper to emit an escaped C string
func emit_escaped_string(scalar $cg, str $s) void {
    my int $i = 0;
    my int $len = length($s);
    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        if ($ch eq "\\") {
            emit($cg, "\\\\");
        } elsif ($ch eq "\"") {
            emit($cg, "\\\"");
        } elsif ($ch eq "\n") {
            emit($cg, "\\n");
        } elsif ($ch eq "\t") {
            emit($cg, "\\t");
        } else {
            emit($cg, $ch);
        }
        $i = $i + 1;
    }
}

# ============================================================
# Type Conversion
# ============================================================

func type_to_c(int $type) str {
    if ($type == TYPE_INT()) { return "StradaValue*"; }
    if ($type == TYPE_NUM()) { return "StradaValue*"; }
    if ($type == TYPE_STR()) { return "StradaValue*"; }
    if ($type == TYPE_BOOL()) { return "StradaValue*"; }
    if ($type == TYPE_ARRAY()) { return "StradaValue*"; }
    if ($type == TYPE_HASH()) { return "StradaValue*"; }
    if ($type == TYPE_SCALAR()) { return "StradaValue*"; }
    if ($type == TYPE_VOID()) { return "void"; }
    if ($type == TYPE_STRUCT()) { return "void*"; }  # Struct pointer
    if ($type == TYPE_FUNCPTR()) { return "void*"; }  # Function pointer
    return "StradaValue*";
}

# ============================================================
# Expression Code Generation
# ============================================================

# Helper: emit a numeric operand efficiently
# For literals, emit the value directly; otherwise use strada_to_num()
func emit_num_operand(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    if ($type == NODE_INT_LITERAL()) {
        my str $val = $expr->{"value"};
        # Check if it's a hex, octal, or binary literal
        # Also check for leading zeros (octal in C)
        my str $first = substr($val, 0, 1);
        my str $second = "";
        if (length($val) > 1) {
            $second = substr($val, 1, 1);
        }
        if (substr($val, 0, 2) eq "0x" || substr($val, 0, 2) eq "0X" ||
            substr($val, 0, 2) eq "0o" || substr($val, 0, 2) eq "0O" ||
            substr($val, 0, 2) eq "0b" || substr($val, 0, 2) eq "0B") {
            # Cast hex/octal/binary to double
            emit($cg, "(double)(" . $val . ")");
        } elsif ($first eq "0" && length($val) > 1 && $second ne ".") {
            # Leading zero means octal in C - must cast to preserve value
            emit($cg, "(double)(" . $val . ")");
        } else {
            emit($cg, $val . ".0");
        }
    } elsif ($type == NODE_NUM_LITERAL()) {
        emit($cg, $expr->{"value"});
    } else {
        # Check if expression creates a temp that needs cleanup
        if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($expr) == 1) {
            # Wrap in statement expression to capture and cleanup temp
            emit($cg, "({ StradaValue *__num_tmp = ");
            gen_expression($cg, $expr);
            emit($cg, "; double __num_val = strada_to_num(__num_tmp); strada_decref(__num_tmp); __num_val; })");
        } else {
            emit($cg, "strada_to_num(");
            gen_expression($cg, $expr);
            emit($cg, ")");
        }
    }
}

# Helper: emit an integer operand efficiently
# For literals, emit the value directly; otherwise use strada_to_int()
func emit_int_operand(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    if ($type == NODE_INT_LITERAL()) {
        emit($cg, $expr->{"value"});
    } elsif ($type == NODE_NUM_LITERAL()) {
        emit($cg, "(int64_t)" . $expr->{"value"});
    } else {
        # Check if expression creates a temp that needs cleanup
        if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($expr) == 1) {
            # Wrap in statement expression to capture and cleanup temp
            emit($cg, "({ StradaValue *__int_tmp = ");
            gen_expression($cg, $expr);
            emit($cg, "; int64_t __int_val = strada_to_int(__int_tmp); strada_decref(__int_tmp); __int_val; })");
        } else {
            emit($cg, "strada_to_int(");
            gen_expression($cg, $expr);
            emit($cg, ")");
        }
    }
}

# Helper: emit a bool operand efficiently
# For literals, emit the value directly; otherwise use strada_to_bool()
func emit_bool_operand(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    if ($type == NODE_INT_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
    } elsif ($type == NODE_NUM_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0" || $val eq "0.0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
    } else {
        # Check if expression creates a temp that needs cleanup
        if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($expr) == 1) {
            # Wrap in statement expression to capture and cleanup temp
            emit($cg, "({ StradaValue *__bool_tmp = ");
            gen_expression($cg, $expr);
            emit($cg, "; int __bool_val = strada_to_bool(__bool_tmp); strada_decref(__bool_tmp); __bool_val; })");
        } else {
            emit($cg, "strada_to_bool(");
            gen_expression($cg, $expr);
            emit($cg, ")");
        }
    }
}

# Helper: emit an expression as a C string in extern mode
# Converts non-string types (int, num) to strings using helper functions
func emit_extern_str_operand(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};

    # String literals - emit as raw C string
    if ($type == NODE_STR_LITERAL()) {
        gen_expression($cg, $expr);
        return;
    }

    # Integer literals - convert to string
    if ($type == NODE_INT_LITERAL()) {
        emit($cg, "strada_int_to_cstr(" . $expr->{"value"} . ")");
        return;
    }

    # Number literals - convert to string
    if ($type == NODE_NUM_LITERAL()) {
        emit($cg, "strada_num_to_cstr(" . $expr->{"value"} . ")");
        return;
    }

    # Variables - check extern_params for type and convert if needed
    if ($type == NODE_VARIABLE()) {
        my str $var_name = $expr->{"name"};
        my scalar $extern_params = $cg->{"extern_params"};
        if ($extern_params) {
            my scalar $param_type = $extern_params->{$var_name};
            if ($param_type) {
                if ($param_type == TYPE_INT() || $param_type == TYPE_BOOL() || $param_type == TYPE_INT32() || $param_type == TYPE_INT64()) {
                    emit($cg, "strada_int_to_cstr(" . $var_name . ")");
                    return;
                } elsif ($param_type == TYPE_NUM() || $param_type == TYPE_FLOAT32() || $param_type == TYPE_FLOAT64()) {
                    emit($cg, "strada_num_to_cstr(" . $var_name . ")");
                    return;
                }
            }
        }
        # String type or unknown - emit as-is
        emit($cg, $var_name);
        return;
    }

    # Binary op (nested concatenation) - recurse
    if ($type == NODE_BINARY_OP() && $expr->{"op"} eq ".") {
        emit($cg, "strada_cstr_concat(");
        emit_extern_str_operand($cg, $expr->{"left"});
        emit($cg, ", ");
        emit_extern_str_operand($cg, $expr->{"right"});
        emit($cg, ")");
        return;
    }

    # Other expressions - just emit (assume they return char*)
    gen_expression($cg, $expr);
}

# Helper: emit a condition as raw C boolean (avoids strada_new_int allocation)
# Used for while/for/if conditions to prevent memory leaks
func emit_condition(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};

    # Literals: emit 0 or 1 directly
    if ($type == NODE_INT_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
        return;
    }
    if ($type == NODE_NUM_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0" || $val eq "0.0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
        return;
    }

    # Binary operators: handle comparisons and logical ops without allocation
    if ($type == NODE_BINARY_OP()) {
        my str $op = $expr->{"op"};

        # Comparison operators: emit raw C comparison
        if ($op eq "==" || $op eq "!=" || $op eq "<" || $op eq ">" || $op eq "<=" || $op eq ">=") {
            emit($cg, "(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " " . $op . " ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
            return;
        }

        # Logical AND: recurse on both sides
        if ($op eq "&&") {
            emit($cg, "(");
            emit_condition($cg, $expr->{"left"});
            emit($cg, " && ");
            emit_condition($cg, $expr->{"right"});
            emit($cg, ")");
            return;
        }

        # Logical OR: recurse on both sides
        if ($op eq "||") {
            emit($cg, "(");
            emit_condition($cg, $expr->{"left"});
            emit($cg, " || ");
            emit_condition($cg, $expr->{"right"});
            emit($cg, ")");
            return;
        }
    }

    # Unary NOT: recurse
    if ($type == NODE_UNARY_OP()) {
        my str $op = $expr->{"op"};
        if ($op eq "!") {
            emit($cg, "!(");
            emit_condition($cg, $expr->{"operand"});
            emit($cg, ")");
            return;
        }
    }

    # Function call: handle defined() specially to avoid leak
    if ($type == NODE_CALL()) {
        my str $name = $expr->{"name"};
        if ($name eq "defined") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            # Use non-allocating strada_defined_bool, cleanup arg if temporary
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($arg) == 1) {
                emit($cg, "({ StradaValue *__def_tmp = ");
                gen_expression($cg, $arg);
                emit($cg, "; int __def_res = strada_defined_bool(__def_tmp); strada_decref(__def_tmp); __def_res; })");
            } else {
                emit($cg, "strada_defined_bool(");
                gen_expression($cg, $arg);
                emit($cg, ")");
            }
            return;
        }
    }

    # Fallback: use strada_to_bool on the expression
    # If expression produces temporary value, capture and free it
    if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($expr) == 1) {
        emit($cg, "({ StradaValue *__cond_tmp = ");
        gen_expression($cg, $expr);
        emit($cg, "; int __cond_res = strada_to_bool(__cond_tmp); strada_decref(__cond_tmp); __cond_res; })");
    } else {
        emit($cg, "strada_to_bool(");
        gen_expression($cg, $expr);
        emit($cg, ")");
    }
}

# Helper: check if expression is a simple variable (doesn't need cleanup)
func is_variable_expr(scalar $expr) int {
    my int $type = $expr->{"type"};
    if ($type == NODE_VARIABLE()) {
        return 1;
    }
    return 0;
}

# Helper: check if expression produces an owned StradaValue* that needs cleanup
# Returns 1 for expressions we KNOW produce owned pointers (literals, concat, arithmetic)
# Returns 0 for unknown types (function calls, etc.) to be safe
func needs_temp_cleanup(scalar $expr) int {
    my int $type = $expr->{"type"};

    # Literals always create owned StradaValue*
    if ($type == NODE_INT_LITERAL() || $type == NODE_NUM_LITERAL() || $type == NODE_STR_LITERAL()) {
        return 1;
    }

    # Binary ops that produce StradaValue*
    if ($type == NODE_BINARY_OP()) {
        my str $op = $expr->{"op"};
        # These ops produce owned StradaValue*
        if ($op eq "." || $op eq "+" || $op eq "-" || $op eq "*" || $op eq "/" ||
            $op eq "%" || $op eq "**" || $op eq "==" || $op eq "!=" ||
            $op eq "<" || $op eq ">" || $op eq "<=" || $op eq ">=" ||
            $op eq "&&" || $op eq "||" || $op eq "&" || $op eq "|" ||
            $op eq "^" || $op eq "<<" || $op eq ">>" ||
            $op eq "eq" || $op eq "ne" || $op eq "lt" || $op eq "gt" ||
            $op eq "le" || $op eq "ge") {
            return 1;
        }
    }

    # Unary ops that produce StradaValue*
    if ($type == NODE_UNARY_OP()) {
        my str $op = $expr->{"op"};
        if ($op eq "!" || $op eq "-") {
            return 1;
        }
    }

    # Array/hash constructors
    if ($type == NODE_ANON_ARRAY() || $type == NODE_ANON_HASH()) {
        return 1;
    }

    # Reference expressions (\$var, \@arr, \%hash) create owned refs
    if ($type == NODE_REF()) {
        return 1;
    }

    # Ternary produces owned StradaValue* (from either branch)
    if ($type == NODE_TERNARY()) {
        return 1;
    }

    # Variables don't need cleanup (already tracked)
    if ($type == NODE_VARIABLE()) {
        return 0;
    }

    # Method calls return owned StradaValue* that need cleanup
    if ($type == NODE_METHOD_CALL()) {
        return 1;
    }

    # Function calls: check if it's a known function that returns owned StradaValue*
    if ($type == NODE_CALL()) {
        my str $name = $expr->{"name"};
        # Built-in functions that return owned StradaValue*
        if ($name eq "chr" || $name eq "ord" ||
            $name eq "sys::base64_encode" || $name eq "sys::base64_decode" ||
            $name eq "sys::pack" || $name eq "sys::unpack" ||
            $name eq "sys::ord_byte" || $name eq "sys::get_byte" ||
            $name eq "sys::byte_length" || $name eq "sys::byte_substr" ||
            $name eq "sys::set_byte" ||
            $name eq "substr" || $name eq "length" || $name eq "index" ||
            $name eq "uc" || $name eq "lc" || $name eq "ucfirst" || $name eq "lcfirst" ||
            $name eq "trim" || $name eq "ltrim" || $name eq "rtrim" ||
            $name eq "chomp" || $name eq "chop" ||
            $name eq "sprintf" || $name eq "join" || $name eq "reverse" ||
            $name eq "split" || $name eq "keys" || $name eq "values" ||
            $name eq "defined" || $name eq "exists" ||
            $name eq "ref" || $name eq "bless" || $name eq "blessed" ||
            $name eq "isa" || $name eq "can" ||
            $name eq "UNIVERSAL::isa" || $name eq "UNIVERSAL::can" ||
            $name eq "size" || $name eq "scalar" ||
            $name eq "push" || $name eq "pop" || $name eq "shift" || $name eq "unshift" ||
            $name eq "abs" || $name eq "int" || $name eq "rand" || $name eq "srand" ||
            $name eq "refcount" ||
            $name eq "time" || $name eq "localtime" || $name eq "gmtime" ||
            $name eq "math::sin" || $name eq "math::cos" || $name eq "math::tan" ||
            $name eq "math::sqrt" || $name eq "math::pow" || $name eq "math::log" ||
            $name eq "math::exp" || $name eq "math::floor" || $name eq "math::ceil" ||
            $name eq "math::abs" || $name eq "math::round") {
            return 1;
        }
        # User-defined functions (non-sys::, non-math::) usually return owned values
        # But be conservative for now
        return 0;
    }

    # Default: don't cleanup (be conservative)
    return 0;
}

# Helper: check if return value needs incref before returning
# Returns 1 for variables and borrowed references (need incref to survive scope cleanup)
# Returns 0 for new/owned values (already have correct refcount)
func return_needs_incref(scalar $expr) int {
    my int $type = $expr->{"type"};

    # Variables need incref because scope cleanup will decref them
    if ($type == NODE_VARIABLE()) {
        return 1;
    }

    # Hash and array access return borrowed references - need incref
    if ($type == NODE_HASH_ACCESS() || $type == NODE_SUBSCRIPT()) {
        return 1;
    }

    # Deref expressions returning borrowed refs
    if ($type == NODE_DEREF_HASH() || $type == NODE_DEREF_ARRAY()) {
        return 1;
    }

    # Method calls return owned values - no incref needed (they already have refcount)
    if ($type == NODE_METHOD_CALL()) {
        return 0;
    }

    # Function calls - most return owned values, but bless() returns its argument
    if ($type == NODE_CALL()) {
        my str $name = $expr->{"name"};
        # bless() returns its first argument, so check if THAT needs incref
        if ($name eq "bless") {
            my scalar $args = $expr->{"args"};
            if ($args && $expr->{"arg_count"} > 0) {
                return return_needs_incref($args->[0]);
            }
            return 0;
        }
        return 0;
    }

    # Literals create owned values
    if ($type == NODE_INT_LITERAL() || $type == NODE_NUM_LITERAL() || $type == NODE_STR_LITERAL()) {
        return 0;
    }

    # Binary ops create owned values
    if ($type == NODE_BINARY_OP()) {
        return 0;
    }

    # Unary ops create owned values
    if ($type == NODE_UNARY_OP()) {
        return 0;
    }

    # Reference/anon constructors create owned values
    if ($type == NODE_REF() || $type == NODE_ANON_ARRAY() || $type == NODE_ANON_HASH()) {
        return 0;
    }

    # Ternary - check both branches (if either needs incref, do incref to be safe)
    if ($type == NODE_TERNARY()) {
        my int $true_needs = return_needs_incref($expr->{"true_expr"});
        my int $false_needs = return_needs_incref($expr->{"false_expr"});
        if ($true_needs == 1 || $false_needs == 1) {
            return 1;
        }
        return 0;
    }

    # Default: incref to be safe (conservative)
    return 1;
}

# Helper: generate a function call with temporary argument cleanup
# c_func_name: the C function to call (e.g., "strada_glob")
# args: array of argument expressions
# arg_count: number of arguments
# Returns nothing, emits code directly
func gen_call_with_arg_cleanup(scalar $cg, str $c_func_name, scalar $args, int $arg_count) void {
    if ($cg->{"cleanup_enabled"} == 0 || $arg_count == 0) {
        # No cleanup needed - emit simple call
        emit($cg, $c_func_name . "(");
        my int $i = 0;
        while ($i < $arg_count) {
            if ($i > 0) {
                emit($cg, ", ");
            }
            gen_expression($cg, $args->[$i]);
            $i = $i + 1;
        }
        emit($cg, ")");
        return;
    }

    # Check which arguments are temporaries (up to 8 args supported)
    my int $temp0 = 0;
    my int $temp1 = 0;
    my int $temp2 = 0;
    my int $temp3 = 0;
    my int $has_temps = 0;

    if ($arg_count > 0 && needs_temp_cleanup($args->[0]) == 1) {
        $temp0 = 1;
        $has_temps = 1;
    }
    if ($arg_count > 1 && needs_temp_cleanup($args->[1]) == 1) {
        $temp1 = 1;
        $has_temps = 1;
    }
    if ($arg_count > 2 && needs_temp_cleanup($args->[2]) == 1) {
        $temp2 = 1;
        $has_temps = 1;
    }
    if ($arg_count > 3 && needs_temp_cleanup($args->[3]) == 1) {
        $temp3 = 1;
        $has_temps = 1;
    }

    if ($has_temps == 0) {
        # No temporaries - emit simple call
        emit($cg, $c_func_name . "(");
        my int $i = 0;
        while ($i < $arg_count) {
            if ($i > 0) {
                emit($cg, ", ");
            }
            gen_expression($cg, $args->[$i]);
            $i = $i + 1;
        }
        emit($cg, ")");
        return;
    }

    # Has temporaries - wrap with cleanup
    emit($cg, "({ ");

    # Declare temp variables for each temporary argument
    if ($temp0 == 1) {
        emit($cg, "StradaValue *__call_arg0 = ");
        gen_expression($cg, $args->[0]);
        emit($cg, "; ");
    }
    if ($temp1 == 1) {
        emit($cg, "StradaValue *__call_arg1 = ");
        gen_expression($cg, $args->[1]);
        emit($cg, "; ");
    }
    if ($temp2 == 1) {
        emit($cg, "StradaValue *__call_arg2 = ");
        gen_expression($cg, $args->[2]);
        emit($cg, "; ");
    }
    if ($temp3 == 1) {
        emit($cg, "StradaValue *__call_arg3 = ");
        gen_expression($cg, $args->[3]);
        emit($cg, "; ");
    }

    # Emit the call with result capture
    emit($cg, "StradaValue *__call_result = " . $c_func_name . "(");
    my int $i = 0;
    while ($i < $arg_count) {
        if ($i > 0) {
            emit($cg, ", ");
        }
        if ($i == 0 && $temp0 == 1) {
            emit($cg, "__call_arg0");
        } elsif ($i == 1 && $temp1 == 1) {
            emit($cg, "__call_arg1");
        } elsif ($i == 2 && $temp2 == 1) {
            emit($cg, "__call_arg2");
        } elsif ($i == 3 && $temp3 == 1) {
            emit($cg, "__call_arg3");
        } else {
            gen_expression($cg, $args->[$i]);
        }
        $i = $i + 1;
    }
    emit($cg, "); ");

    # Decref all temp arguments
    if ($temp0 == 1) {
        emit($cg, "strada_decref(__call_arg0); ");
    }
    if ($temp1 == 1) {
        emit($cg, "strada_decref(__call_arg1); ");
    }
    if ($temp2 == 1) {
        emit($cg, "strada_decref(__call_arg2); ");
    }
    if ($temp3 == 1) {
        emit($cg, "strada_decref(__call_arg3); ");
    }

    # Return the result
    emit($cg, "__call_result; })");
}

func gen_expression(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    my int $in_extern = $cg->{"in_extern"};

    # Integer literal
    if ($type == NODE_INT_LITERAL()) {
        if ($in_extern) {
            emit($cg, $expr->{"value"});
        } else {
            emit($cg, "strada_new_int(" . $expr->{"value"} . ")");
        }
        return;
    }

    # Number literal
    if ($type == NODE_NUM_LITERAL()) {
        if ($in_extern) {
            emit($cg, $expr->{"value"});
        } else {
            emit($cg, "strada_new_num(" . $expr->{"value"} . ")");
        }
        return;
    }
    
    # String literal - use byte-level operations for proper UTF-8 handling
    if ($type == NODE_STR_LITERAL()) {
        # In extern mode, emit raw C string literal
        if ($in_extern) {
            emit($cg, "\"");
        } else {
            emit($cg, "strada_new_str(\"");
        }
        my str $val = $expr->{"value"};
        my int $i = 0;
        my int $len = bytes($val);
        while ($i < $len) {
            my int $code = char_at($val, $i);
            if ($code == 10) {
                emit($cg, "\\n");
            } elsif ($code == 9) {
                emit($cg, "\\t");
            } elsif ($code == 13) {
                emit($cg, "\\r");
            } elsif ($code == 0) {
                emit($cg, "\\0");
            } elsif ($code == 7) {
                emit($cg, "\\a");
            } elsif ($code == 8) {
                emit($cg, "\\b");
            } elsif ($code == 12) {
                emit($cg, "\\f");
            } elsif ($code == 11) {
                emit($cg, "\\v");
            } elsif ($code == 27) {
                emit($cg, "\\033");
            } elsif ($code == 34) {
                emit($cg, "\\\"");
            } elsif ($code == 92) {
                emit($cg, "\\\\");
            } elsif ($code >= 32 && $code <= 126) {
                # Printable ASCII - output as-is
                emit($cg, chr($code));
            } else {
                # Non-printable/high bytes - output raw byte directly
                # The C source file is UTF-8, so raw UTF-8 bytes are valid
                emit($cg, substr_bytes($val, $i, 1));
            }
            $i = $i + 1;
        }
        if ($in_extern) {
            emit($cg, "\"");
        } else {
            emit($cg, "\")");
        }
        return;
    }

    # Undef literal
    if ($type == NODE_UNDEF()) {
        emit($cg, "strada_new_undef()");
        return;
    }

    # Variable
    if ($type == NODE_VARIABLE()) {
        my str $var_name = $expr->{"name"};
        # Escape C keywords in variable names
        my str $c_var_name = escape_c_keyword($var_name);
        # Handle magic variables for map/sort/grep blocks (only when in those contexts)
        if ($var_name eq "_" && ($cg->{"in_map_block"} || $cg->{"in_grep_block"})) {
            emit($cg, "__elem_");
        } elsif ($var_name eq "a" && $cg->{"in_sort_block"}) {
            emit($cg, "__sort_a_");
        } elsif ($var_name eq "b" && $cg->{"in_sort_block"}) {
            emit($cg, "__sort_b_");
        } elsif ($cg->{"in_anon_func"}) {
            # Inside anonymous function - check if it's a param, local, or capture
            my str $param_str = $cg->{"anon_param_str"};
            my str $local_str = $cg->{"anon_local_str"};
            my str $capture_str = $cg->{"anon_capture_str"};
            if (str_contains_name($param_str, $var_name)) {
                # It's a parameter - use directly (escaped for C)
                emit($cg, $c_var_name);
            } elsif (str_contains_name($local_str, $var_name)) {
                # It's a local variable - use directly (escaped for C)
                emit($cg, $c_var_name);
            } else {
                # It's a capture - get or add index
                my int $idx = get_capture_index($capture_str, $var_name);
                if ($idx < 0) {
                    # New capture - add it
                    if ($capture_str eq "") {
                        $cg->{"anon_capture_str"} = $var_name;
                    } else {
                        $cg->{"anon_capture_str"} = $capture_str . "," . $var_name;
                    }
                    $idx = $cg->{"anon_capture_count"};
                    $cg->{"anon_capture_count"} = $idx + 1;
                }
                # Use double pointer dereference for capture-by-reference
                emit($cg, "(*__captures[" . $idx . "])");
            }
        } else {
            emit($cg, $c_var_name);
        }
        return;
    }
    
    # Binary operation
    if ($type == NODE_BINARY_OP()) {
        my str $op = $expr->{"op"};

        # For extern functions, generate raw C arithmetic
        if ($in_extern) {
            if ($op eq "+" || $op eq "-" || $op eq "*" || $op eq "/" || $op eq "%") {
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } elsif ($op eq "**") {
                # Exponentiation in extern - use pow()
                emit($cg, "pow(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, ", ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } elsif ($op eq "==" || $op eq "!=" || $op eq "<" || $op eq ">" || $op eq "<=" || $op eq ">=") {
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } elsif ($op eq "&&" || $op eq "||" || $op eq "&" || $op eq "|" || $op eq "^" || $op eq "<<" || $op eq ">>") {
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } elsif ($op eq ".") {
                # String concatenation in extern mode - use strada_cstr_concat helper
                # Need to convert non-string types to strings
                emit($cg, "strada_cstr_concat(");
                emit_extern_str_operand($cg, $expr->{"left"});
                emit($cg, ", ");
                emit_extern_str_operand($cg, $expr->{"right"});
                emit($cg, ")");
            } else {
                # Fallback for other ops
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            }
            return;
        }

        if ($op eq "+") {
            emit($cg, "strada_new_num(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " + ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "-") {
            emit($cg, "strada_new_num(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " - ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "*") {
            emit($cg, "strada_new_num(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " * ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "/") {
            # Safe division - returns undef if divisor is zero
            emit($cg, "strada_safe_div(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, ", ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "**") {
            # Exponentiation - use pow() from math.h
            emit($cg, "strada_new_num(pow(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, ", ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, "))");
        } elsif ($op eq "%") {
            # Safe modulo - returns undef if divisor is zero
            emit($cg, "strada_safe_mod((int64_t)");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, ", (int64_t)");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq ".") {
            # Fast concat directly on StradaValues - no intermediate copies
            # When cleanup enabled, properly handle temporary arguments
            my scalar $left = $expr->{"left"};
            my scalar $right = $expr->{"right"};
            my int $left_is_temp = 0;
            my int $right_is_temp = 0;
            if ($cg->{"cleanup_enabled"} == 1) {
                if (needs_temp_cleanup($left) == 1) {
                    $left_is_temp = 1;
                }
                if (needs_temp_cleanup($right) == 1) {
                    $right_is_temp = 1;
                }
            }

            if ($left_is_temp == 1 || $right_is_temp == 1) {
                emit($cg, "({ ");
                if ($left_is_temp == 1) {
                    emit($cg, "StradaValue *__concat_l = ");
                    gen_expression($cg, $left);
                    emit($cg, "; ");
                }
                if ($right_is_temp == 1) {
                    emit($cg, "StradaValue *__concat_r = ");
                    gen_expression($cg, $right);
                    emit($cg, "; ");
                }
                emit($cg, "StradaValue *__concat_res = strada_concat_sv(");
                if ($left_is_temp == 1) {
                    emit($cg, "__concat_l");
                } else {
                    gen_expression($cg, $left);
                }
                emit($cg, ", ");
                if ($right_is_temp == 1) {
                    emit($cg, "__concat_r");
                } else {
                    gen_expression($cg, $right);
                }
                emit($cg, "); ");
                if ($left_is_temp == 1) {
                    emit($cg, "strada_decref(__concat_l); ");
                }
                if ($right_is_temp == 1) {
                    emit($cg, "strada_decref(__concat_r); ");
                }
                emit($cg, "__concat_res; })");
            } else {
                emit($cg, "strada_concat_sv(");
                gen_expression($cg, $left);
                emit($cg, ", ");
                gen_expression($cg, $right);
                emit($cg, ")");
            }
        } elsif ($op eq "==") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " == ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "!=") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " != ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "<") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " < ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq ">") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " > ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "<=") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " <= ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq ">=") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " >= ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "&&") {
            emit($cg, "strada_new_int(");
            emit_bool_operand($cg, $expr->{"left"});
            emit($cg, " && ");
            emit_bool_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "||") {
            emit($cg, "strada_new_int(");
            emit_bool_operand($cg, $expr->{"left"});
            emit($cg, " || ");
            emit_bool_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "&") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " & ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "|") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " | ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "^") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " ^ ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "<<") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " << ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq ">>") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " >> ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "eq") {
            gen_str_cmp($cg, $expr, "eq");
        } elsif ($op eq "ne") {
            gen_str_cmp($cg, $expr, "ne");
        } elsif ($op eq "lt") {
            gen_str_cmp($cg, $expr, "lt");
        } elsif ($op eq "gt") {
            gen_str_cmp($cg, $expr, "gt");
        } elsif ($op eq "le") {
            gen_str_cmp($cg, $expr, "le");
        } elsif ($op eq "ge") {
            gen_str_cmp($cg, $expr, "ge");
        } elsif ($op eq "<=>") {
            # Spaceship operator: returns -1, 0, or 1
            emit($cg, "strada_new_int(({ double __l = strada_to_num(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "); double __r = strada_to_num(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, "); (__l < __r) ? -1 : ((__l > __r) ? 1 : 0); }))");
        } elsif ($op eq "=~") {
            # Regex match with string pattern (no flags)
            emit($cg, "strada_new_int(strada_regex_match_with_capture(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, "), NULL))");
        } elsif ($op eq "!~") {
            # Negated regex match with string pattern (no flags)
            emit($cg, "strada_new_int(!strada_regex_match_with_capture(strada_to_str(");
            gen_expression($cg, $expr->{"left"});
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $expr->{"right"});
            emit($cg, "), NULL))");
        }
        return;
    }

    # Regex match: $str =~ /pattern/flags or $str !~ /pattern/flags
    if ($type == NODE_REGEX_MATCH()) {
        my str $op = $expr->{"op"};
        my str $pattern = $expr->{"pattern"};
        my str $flags = $expr->{"flags"};

        if ($op eq "=~") {
            emit($cg, "strada_new_int(strada_regex_match_with_capture(strada_to_str(");
        } else {
            emit($cg, "strada_new_int(!strada_regex_match_with_capture(strada_to_str(");
        }
        gen_expression($cg, $expr->{"target"});
        emit($cg, "), ");

        # Check if pattern contains variable interpolation ($varname)
        # Only consider it interpolation if $ is followed by a word character
        # (not $ at end of pattern which is regex end-of-line anchor)
        my int $has_interp = 0;
        my int $check_i = 0;
        my int $pat_len = length($pattern);
        while ($check_i < $pat_len) {
            my str $ch = substr($pattern, $check_i, 1);
            if ($ch eq "$" && $check_i + 1 < $pat_len) {
                my str $next_ch = substr($pattern, $check_i + 1, 1);
                # Check if next char is start of variable name (letter or underscore)
                if ($next_ch eq "_" || ($next_ch ge "a" && $next_ch le "z") || ($next_ch ge "A" && $next_ch le "Z")) {
                    $has_interp = 1;
                    last;
                }
            }
            $check_i = $check_i + 1;
        }

        if ($has_interp == 1) {
            # Pattern has variable interpolation - build at runtime
            # Parse and generate concatenation expression
            emit($cg, "strada_to_str(");
            gen_regex_interpolated_pattern($cg, $pattern);
            emit($cg, ")");
        } else {
            # Static pattern - emit as literal string
            emit($cg, "\"");
            my int $i = 0;
            my int $len = length($pattern);
            while ($i < $len) {
                my str $ch = substr($pattern, $i, 1);
                if ($ch eq "\\") {
                    emit($cg, "\\\\");
                } elsif ($ch eq "\"") {
                    emit($cg, "\\\"");
                } elsif ($ch eq "\n") {
                    emit($cg, "\\n");
                } elsif ($ch eq "\t") {
                    emit($cg, "\\t");
                } else {
                    emit($cg, $ch);
                }
                $i = $i + 1;
            }
            emit($cg, "\"");
        }
        emit($cg, ", ");
        # Pass flags (or NULL if empty)
        if (length($flags) > 0) {
            emit($cg, "\"" . $flags . "\"");
        } else {
            emit($cg, "NULL");
        }
        emit($cg, "))");
        return;
    }

    # Regex substitution: $str =~ s/pattern/replacement/flags
    if ($type == NODE_REGEX_SUBST()) {
        my str $pattern = $expr->{"pattern"};
        my str $replacement = $expr->{"replacement"};
        my str $flags = $expr->{"flags"};

        # Check for global flag
        my int $global = 0;
        if (index($flags, "g") >= 0) {
            $global = 1;
        }

        # Generate: target = strada_new_str(strada_regex_replace[_all](strada_to_str(target), pattern, replacement, flags))
        gen_expression($cg, $expr->{"target"});
        emit($cg, " = ");

        if ($global == 1) {
            emit($cg, "strada_new_str(strada_regex_replace_all(strada_to_str(");
        } else {
            emit($cg, "strada_new_str(strada_regex_replace(strada_to_str(");
        }
        gen_expression($cg, $expr->{"target"});
        emit($cg, "), \"");
        # Escape pattern
        my int $i = 0;
        my int $len = length($pattern);
        while ($i < $len) {
            my str $ch = substr($pattern, $i, 1);
            if ($ch eq "\\") {
                emit($cg, "\\\\");
            } elsif ($ch eq "\"") {
                emit($cg, "\\\"");
            } elsif ($ch eq "\n") {
                emit($cg, "\\n");
            } elsif ($ch eq "\t") {
                emit($cg, "\\t");
            } elsif ($ch eq "\r") {
                emit($cg, "\\r");
            } else {
                emit($cg, $ch);
            }
            $i = $i + 1;
        }
        emit($cg, "\", \"");
        # Escape replacement
        $i = 0;
        $len = length($replacement);
        while ($i < $len) {
            my str $ch = substr($replacement, $i, 1);
            if ($ch eq "\\") {
                emit($cg, "\\\\");
            } elsif ($ch eq "\"") {
                emit($cg, "\\\"");
            } elsif ($ch eq "\n") {
                emit($cg, "\\n");
            } elsif ($ch eq "\t") {
                emit($cg, "\\t");
            } elsif ($ch eq "\r") {
                emit($cg, "\\r");
            } else {
                emit($cg, $ch);
            }
            $i = $i + 1;
        }
        emit($cg, "\", ");
        # Pass flags (or NULL if empty)
        if (length($flags) > 0) {
            emit($cg, "\"" . $flags . "\"");
        } else {
            emit($cg, "NULL");
        }
        emit($cg, "))");
        return;
    }

    # Unary operation
    if ($type == NODE_UNARY_OP()) {
        my str $op = $expr->{"op"};
        if ($op eq "-") {
            emit($cg, "strada_new_num(-strada_to_num(");
            gen_expression($cg, $expr->{"operand"});
            emit($cg, "))");
        } elsif ($op eq "!") {
            emit($cg, "strada_new_int(!strada_to_bool(");
            gen_expression($cg, $expr->{"operand"});
            emit($cg, "))");
        } elsif ($op eq "~") {
            emit($cg, "strada_new_int(~strada_to_int(");
            gen_expression($cg, $expr->{"operand"});
            emit($cg, "))");
        }
        return;
    }

    # Increment/decrement (++ and --)
    if ($type == NODE_INCREMENT()) {
        my str $op = $expr->{"op"};
        my int $is_prefix = $expr->{"is_prefix"};
        my scalar $operand = $expr->{"operand"};
        my int $operand_type = $operand->{"type"};

        # For simple variables, use address-of
        if ($operand_type == NODE_VARIABLE()) {
            if ($is_prefix == 1) {
                if ($op eq "++") {
                    emit($cg, "strada_preincr(&");
                } else {
                    emit($cg, "strada_predecr(&");
                }
            } else {
                if ($op eq "++") {
                    emit($cg, "strada_postincr(&");
                } else {
                    emit($cg, "strada_postdecr(&");
                }
            }
            gen_expression($cg, $operand);
            emit($cg, ")");
        } else {
            # For complex expressions, fall back to inline increment
            # This works for statement context but returns wrong value for postfix
            emit($cg, "(");
            gen_expression($cg, $operand);
            emit($cg, " = strada_new_num(strada_to_num(");
            gen_expression($cg, $operand);
            if ($op eq "++") {
                emit($cg, ") + 1))");
            } else {
                emit($cg, ") - 1))");
            }
        }
        return;
    }

    # Function call
    if ($type == NODE_CALL()) {
        my str $name = $expr->{"name"};

        # Handle constant references (e.g., enum values like Color::RED)
        if ($expr->{"is_constant"} == 1) {
            emit($cg, "strada_new_int(" . sanitize_name($name) . ")");
            return;
        }

        # Built-in functions
        if ($name eq "say") {
            my int $argc = $expr->{"arg_count"};
            my scalar $args = $expr->{"args"};
            if ($argc == 2) {
                # say($fh, $text) - say to filehandle
                emit($cg, "strada_say_fh(");
                gen_expression($cg, $args->[1]);  # text
                emit($cg, ", ");
                gen_expression($cg, $args->[0]);  # filehandle
                emit($cg, ")");
            } elsif ($argc > 0) {
                my scalar $arg = $args->[0];
                # If cleanup enabled and arg is a temporary, wrap to decref after
                if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($arg) == 1) {
                    emit($cg, "({ StradaValue *__say_tmp = ");
                    gen_expression($cg, $arg);
                    emit($cg, "; strada_say(__say_tmp); strada_decref(__say_tmp); })");
                } else {
                    emit($cg, "strada_say(");
                    gen_expression($cg, $arg);
                    emit($cg, ")");
                }
            } else {
                emit($cg, "strada_say(strada_new_str(\"\"))");
            }
            return;
        }

        if ($name eq "print") {
            my int $argc = $expr->{"arg_count"};
            my scalar $args = $expr->{"args"};
            if ($argc == 2) {
                # print($fh, $text) - print to filehandle
                emit($cg, "strada_print_fh(");
                gen_expression($cg, $args->[1]);  # text
                emit($cg, ", ");
                gen_expression($cg, $args->[0]);  # filehandle
                emit($cg, ")");
            } elsif ($argc > 0) {
                my scalar $arg = $args->[0];
                # If cleanup enabled and arg is a temporary, wrap to decref after
                if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($arg) == 1) {
                    emit($cg, "({ StradaValue *__print_tmp = ");
                    gen_expression($cg, $arg);
                    emit($cg, "; strada_print(__print_tmp); strada_decref(__print_tmp); })");
                } else {
                    emit($cg, "strada_print(");
                    gen_expression($cg, $arg);
                    emit($cg, ")");
                }
            } else {
                emit($cg, "strada_print(strada_new_str(\"\"))");
            }
            return;
        }
        
        if ($name eq "length") {
            # UTF-8 character count
            # strada_to_str() returns a strdup'd string that MUST be freed
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            emit($cg, "({ StradaValue *__len_tmp = ");
            gen_expression($cg, $arg);
            emit($cg, "; char *__len_str = strada_to_str(__len_tmp); int64_t __len_res = strada_length(__len_str); free(__len_str); ");
            if (needs_temp_cleanup($arg) == 1) {
                emit($cg, "strada_decref(__len_tmp); ");
            }
            emit($cg, "strada_new_int(__len_res); })");
            return;
        }

        if ($name eq "bytes") {
            # Binary-safe byte count using struct_size
            emit($cg, "strada_new_int(strada_length_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "char_at") {
            emit($cg, "strada_char_at(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "substr_bytes") {
            emit($cg, "strada_substr_bytes(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), ");
            if ($expr->{"arg_count"} > 2) {
                emit($cg, "strada_to_int(");
                gen_expression($cg, $args->[2]);
                emit($cg, ")");
            } else {
                emit($cg, "-1");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "substr") {
            emit($cg, "strada_substr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), ");
            if ($expr->{"arg_count"} > 2) {
                emit($cg, "strada_to_int(");
                gen_expression($cg, $args->[2]);
                emit($cg, ")");
            } else {
                emit($cg, "-1");
            }
            emit($cg, ")");
            return;
        }
        
        if ($name eq "push") {
            my scalar $args = $expr->{"args"};
            my scalar $val_arg = $args->[1];
            # Check if value needs cleanup after push (newly created values do)
            if (needs_temp_cleanup($val_arg) == 1) {
                emit($cg, "({ StradaValue *__push_v = ");
                gen_expression($cg, $val_arg);
                emit($cg, "; strada_array_push(strada_deref_array(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), __push_v); strada_decref(__push_v); strada_undef_static(); })");
            } else {
                # Value is borrowed (variable, array/hash access) - no decref needed
                emit($cg, "(strada_array_push(strada_deref_array(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), ");
                gen_expression($cg, $val_arg);
                emit($cg, "), strada_undef_static())");
            }
            return;
        }

        # reserve - pre-allocate array capacity
        if ($name eq "reserve") {
            emit($cg, "(strada_reserve_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")), strada_undef_static())");
            return;
        }

        if ($name eq "size") {
            emit($cg, "strada_new_int(strada_size(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "pop") {
            emit($cg, "strada_array_pop(strada_deref_array(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "shift") {
            emit($cg, "strada_array_shift(strada_deref_array(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "unshift") {
            my scalar $args = $expr->{"args"};
            my scalar $val_arg = $args->[1];
            # Check if value needs cleanup after unshift (newly created values do)
            if (needs_temp_cleanup($val_arg) == 1) {
                emit($cg, "({ StradaValue *__unsh_v = ");
                gen_expression($cg, $val_arg);
                emit($cg, "; strada_array_unshift(strada_deref_array(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), __unsh_v); strada_decref(__unsh_v); strada_undef_static(); })");
            } else {
                # Value is borrowed (variable, array/hash access) - no decref needed
                emit($cg, "(strada_array_unshift(strada_deref_array(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), ");
                gen_expression($cg, $val_arg);
                emit($cg, "), strada_undef_static())");
            }
            return;
        }

        if ($name eq "sort") {
            emit($cg, "strada_sort(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "nsort") {
            emit($cg, "strada_nsort(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "split") {
            # split(pattern, string) - like Perl
            # strada_regex_split(str, pattern) - runtime signature
            emit($cg, "(({ StradaValue *__sv = strada_new_array(); ");
            emit($cg, "__sv->value.av = strada_regex_split(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[1]);  # string comes first in runtime
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[0]);  # pattern comes second in runtime
            emit($cg, ")); __sv; }))");
            return;
        }
        
        if ($name eq "join") {
            emit($cg, "strada_new_str(strada_join(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_deref_array(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }
        
        if ($name eq "keys") {
            emit($cg, "strada_new_array_from_av(strada_hash_keys(strada_deref_hash(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        if ($name eq "values") {
            emit($cg, "strada_new_array_from_av(strada_hash_values(strada_deref_hash(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        if ($name eq "exists") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            
            # Check if single arg is a hash access node
            if ($expr->{"arg_count"} == 1 && $arg0->{"type"} == NODE_HASH_ACCESS()) {
                emit($cg, "strada_new_int(strada_hash_exists(strada_deref_hash(");
                gen_expression($cg, $arg0->{"hash"});
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $arg0->{"key"});
                emit($cg, ")))");
            } else {
                # Two arg form: exists(hash, key)
                emit($cg, "strada_new_int(strada_hash_exists(strada_deref_hash(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, ")))");
            }
            return;
        }
        
        if ($name eq "delete") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            
            # Check if single arg is a hash access node
            if ($expr->{"arg_count"} == 1 && $arg0->{"type"} == NODE_HASH_ACCESS()) {
                emit($cg, "strada_hash_delete(strada_deref_hash(");
                gen_expression($cg, $arg0->{"hash"});
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $arg0->{"key"});
                emit($cg, "))");
            } else {
                emit($cg, "strada_hash_delete(strada_deref_hash(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, "))");
            }
            return;
        }
        
        if ($name eq "hash_new") {
            emit($cg, "strada_new_hash()");
            return;
        }
        
        if ($name eq "hash_get") {
            emit($cg, "strada_hash_get(strada_deref_hash(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "hash_set") {
            emit($cg, "strada_hash_set(strada_deref_hash(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }
        
        if ($name eq "array_new") {
            emit($cg, "strada_new_array()");
            return;
        }
        
        if ($name eq "sys::cstruct_new") {
            emit($cg, "strada_new_hash()");
            return;
        }
        
        if ($name eq "defined") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            # If cleanup enabled and arg is a temporary, wrap to decref after
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($arg) == 1) {
                emit($cg, "({ StradaValue *__def_tmp = ");
                gen_expression($cg, $arg);
                emit($cg, "; int __def_res = strada_defined_bool(__def_tmp); strada_decref(__def_tmp); strada_new_int(__def_res); })");
            } else {
                emit($cg, "strada_defined(");
                gen_expression($cg, $arg);
                emit($cg, ")");
            }
            return;
        }
        
        if ($name eq "ref") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($arg) == 1) {
                emit($cg, "({ StradaValue *__ref_tmp = ");
                gen_expression($cg, $arg);
                emit($cg, "; StradaValue *__ref_res = strada_new_str(strada_reftype(__ref_tmp)); strada_decref(__ref_tmp); __ref_res; })");
            } else {
                emit($cg, "strada_new_str(strada_reftype(");
                gen_expression($cg, $arg);
                emit($cg, "))");
            }
            return;
        }
        
        if ($name eq "dumper") {
            emit($cg, "strada_dumper(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "dumper_str") {
            emit($cg, "strada_dumper_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "exit") {
            emit($cg, "exit(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # Process control functions
        if ($name eq "sys::sleep") {
            emit($cg, "strada_sleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::usleep") {
            emit($cg, "strada_usleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fork") {
            emit($cg, "strada_fork()");
            return;
        }

        if ($name eq "sys::wait") {
            emit($cg, "strada_wait()");
            return;
        }

        if ($name eq "sys::waitpid") {
            emit($cg, "strada_waitpid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "strada_new_int(0)");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpid") {
            emit($cg, "strada_getpid()");
            return;
        }

        if ($name eq "sys::getppid") {
            emit($cg, "strada_getppid()");
            return;
        }

        # Pipe and IPC functions
        if ($name eq "sys::pipe") {
            emit($cg, "strada_pipe()");
            return;
        }

        if ($name eq "sys::dup2") {
            emit($cg, "strada_dup2(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::close_fd") {
            emit($cg, "strada_close_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::exec") {
            emit($cg, "strada_exec(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "exec_argv") {
            emit($cg, "strada_exec_argv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::system") {
            emit($cg, "strada_system(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::system_argv") {
            emit($cg, "strada_system_argv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setprocname") {
            emit($cg, "strada_setprocname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getprocname") {
            emit($cg, "strada_getprocname()");
            return;
        }

        if ($name eq "sys::setproctitle") {
            emit($cg, "strada_setproctitle(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getproctitle") {
            emit($cg, "strada_getproctitle()");
            return;
        }

        if ($name eq "sys::read_fd") {
            emit($cg, "strada_read_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::write_fd") {
            emit($cg, "strada_write_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::read_all_fd") {
            emit($cg, "strada_read_all_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "fdopen_read") {
            emit($cg, "strada_fdopen_read(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "fdopen_write") {
            emit($cg, "strada_fdopen_write(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # POSIX functions
        if ($name eq "sys::getenv") {
            emit($cg, "strada_getenv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setenv") {
            emit($cg, "strada_setenv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::unsetenv") {
            emit($cg, "strada_unsetenv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # sys::array_default_capacity - get or set default array capacity
        if ($name eq "sys::array_default_capacity") {
            my scalar $args = $expr->{"args"};
            my int $nargs = size($args);
            if ($nargs == 0) {
                # Get current default capacity
                emit($cg, "strada_new_int(strada_get_array_default_capacity())");
            } else {
                # Set new default capacity and return it
                emit($cg, "(strada_set_array_default_capacity(strada_to_int(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")), strada_new_int(strada_get_array_default_capacity()))");
            }
            return;
        }

        # sys::hash_default_capacity - get or set default hash bucket count
        if ($name eq "sys::hash_default_capacity") {
            my scalar $args = $expr->{"args"};
            my int $nargs = size($args);
            if ($nargs == 0) {
                # Get current default capacity
                emit($cg, "strada_new_int(strada_get_hash_default_capacity())");
            } else {
                # Set new default capacity and return it
                emit($cg, "(strada_set_hash_default_capacity(strada_to_int(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")), strada_new_int(strada_get_hash_default_capacity()))");
            }
            return;
        }

        if ($name eq "sys::getcwd") {
            emit($cg, "strada_getcwd()");
            return;
        }

        if ($name eq "sys::chdir") {
            emit($cg, "strada_chdir(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mkdir") {
            emit($cg, "strada_mkdir(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "strada_new_int(0755)");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::rmdir") {
            emit($cg, "strada_rmdir(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::unlink") {
            emit($cg, "strada_unlink(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::link") {
            emit($cg, "strada_link(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::symlink") {
            emit($cg, "strada_symlink(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::readlink") {
            emit($cg, "strada_readlink(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::rename") {
            emit($cg, "strada_rename(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::chmod") {
            emit($cg, "strada_chmod(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::access") {
            emit($cg, "strada_access(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::umask") {
            emit($cg, "strada_umask(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getuid") {
            emit($cg, "strada_getuid()");
            return;
        }

        if ($name eq "sys::geteuid") {
            emit($cg, "strada_geteuid()");
            return;
        }

        if ($name eq "sys::getgid") {
            emit($cg, "strada_getgid()");
            return;
        }

        if ($name eq "sys::getegid") {
            emit($cg, "strada_getegid()");
            return;
        }

        if ($name eq "sys::kill") {
            emit($cg, "strada_kill(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::signal") {
            emit($cg, "strada_signal(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::alarm") {
            emit($cg, "strada_alarm(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::stat") {
            emit($cg, "strada_stat(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::lstat") {
            emit($cg, "strada_lstat(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::isatty") {
            emit($cg, "strada_isatty(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::strerror") {
            emit($cg, "strada_strerror(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::errno") {
            emit($cg, "strada_errno()");
            return;
        }

        if ($name eq "sys::time") {
            emit($cg, "strada_time()");
            return;
        }

        if ($name eq "sys::localtime") {
            emit($cg, "strada_localtime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::gmtime") {
            emit($cg, "strada_gmtime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mktime") {
            emit($cg, "strada_mktime(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::strftime") {
            emit($cg, "strada_strftime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($arg_count > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ctime") {
            emit($cg, "strada_ctime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::sleep") {
            emit($cg, "strada_sleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::usleep") {
            emit($cg, "strada_usleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::gettimeofday") {
            emit($cg, "strada_gettimeofday()");
            return;
        }

        if ($name eq "sys::hires_time") {
            emit($cg, "strada_hires_time()");
            return;
        }

        # Memory profiler functions
        if ($name eq "sys::memprof_enable") {
            emit($cg, "(strada_memprof_enable(), strada_undef_static())");
            return;
        }
        if ($name eq "sys::memprof_disable") {
            emit($cg, "(strada_memprof_disable(), strada_undef_static())");
            return;
        }
        if ($name eq "sys::memprof_report") {
            emit($cg, "(strada_memprof_report(), strada_undef_static())");
            return;
        }
        if ($name eq "sys::memprof_reset") {
            emit($cg, "(strada_memprof_reset(), strada_undef_static())");
            return;
        }

        if ($name eq "sys::tv_interval") {
            emit($cg, "strada_tv_interval(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($arg_count > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::nanosleep") {
            emit($cg, "strada_nanosleep_ns(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clock_gettime") {
            emit($cg, "strada_clock_gettime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clock_getres") {
            emit($cg, "strada_clock_getres(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_open") {
            emit($cg, "strada_dl_open(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "strada_dl_open_raw") {
            emit($cg, "strada_dl_open_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_sym") {
            emit($cg, "strada_dl_sym(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_close") {
            emit($cg, "strada_dl_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_error") {
            emit($cg, "strada_dl_error()");
            return;
        }

        if ($name eq "sys::dl_call_int") {
            emit($cg, "strada_dl_call_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_num") {
            emit($cg, "strada_dl_call_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_str") {
            emit($cg, "strada_dl_call_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_void") {
            emit($cg, "strada_dl_call_void(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_int_sv") {
            emit($cg, "strada_dl_call_int_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_str_sv") {
            emit($cg, "strada_dl_call_str_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_void_sv") {
            emit($cg, "strada_dl_call_void_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_sv") {
            emit($cg, "strada_dl_call_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_export_info") {
            emit($cg, "strada_dl_call_export_info(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_version") {
            emit($cg, "strada_dl_call_version(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Pointer access for FFI
        if ($name eq "sys::int_ptr") {
            emit($cg, "strada_int_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::num_ptr") {
            emit($cg, "strada_num_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::str_ptr") {
            emit($cg, "strada_str_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_int") {
            emit($cg, "strada_ptr_deref_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_num") {
            emit($cg, "strada_ptr_deref_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_str") {
            emit($cg, "strada_ptr_deref_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_int") {
            emit($cg, "strada_ptr_set_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_num") {
            emit($cg, "strada_ptr_set_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::rand") {
            emit($cg, "strada_rand()");
            return;
        }

        if ($name eq "sys::exit_status") {
            emit($cg, "strada_exit_status(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Thread functions
        if ($name eq "thread::create") {
            emit($cg, "strada_thread_create(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::join") {
            emit($cg, "strada_thread_join(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::detach") {
            emit($cg, "strada_thread_detach(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::self") {
            emit($cg, "strada_thread_self()");
            return;
        }

        if ($name eq "thread::mutex_new") {
            emit($cg, "strada_mutex_new()");
            return;
        }

        if ($name eq "thread::mutex_lock") {
            emit($cg, "strada_mutex_lock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::mutex_trylock") {
            emit($cg, "strada_mutex_trylock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::mutex_unlock") {
            emit($cg, "strada_mutex_unlock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::mutex_destroy") {
            emit($cg, "strada_mutex_destroy(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_new") {
            emit($cg, "strada_cond_new()");
            return;
        }

        if ($name eq "thread::cond_wait") {
            emit($cg, "strada_cond_wait(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_signal") {
            emit($cg, "strada_cond_signal(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_broadcast") {
            emit($cg, "strada_cond_broadcast(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_destroy") {
            emit($cg, "strada_cond_destroy(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # ===== ASYNC/AWAIT NAMESPACE FUNCTIONS =====
        if ($name eq "async::all") {
            emit($cg, "strada_future_all(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::race") {
            emit($cg, "strada_future_race(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::timeout") {
            emit($cg, "strada_async_timeout(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::cancel") {
            emit($cg, "(strada_future_cancel(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_undef_static())");
            return;
        }

        if ($name eq "async::is_done") {
            emit($cg, "strada_new_int(strada_future_is_done(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::is_cancelled") {
            emit($cg, "strada_new_int(strada_future_is_cancelled(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::pool_init") {
            emit($cg, "(strada_pool_init(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")), strada_undef_static())");
            return;
        }

        if ($name eq "async::pool_shutdown") {
            emit($cg, "(strada_pool_shutdown(), strada_undef_static())");
            return;
        }

        # ===== CHANNEL NAMESPACE FUNCTIONS =====
        if ($name eq "async::channel") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                emit($cg, "strada_channel_new(strada_to_int(");
                gen_expression($cg, $args->[0]);
                emit($cg, "))");
            } else {
                emit($cg, "strada_channel_new(0)");
            }
            return;
        }

        if ($name eq "async::send") {
            emit($cg, "(strada_channel_send(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_undef_static())");
            return;
        }

        if ($name eq "async::recv") {
            emit($cg, "strada_channel_recv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::try_send") {
            emit($cg, "strada_new_int(strada_channel_try_send(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::try_recv") {
            emit($cg, "strada_channel_try_recv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::close") {
            emit($cg, "(strada_channel_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_undef_static())");
            return;
        }

        if ($name eq "async::is_closed") {
            emit($cg, "strada_new_int(strada_channel_is_closed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::len") {
            emit($cg, "strada_new_int(strada_channel_len(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # ===== MUTEX NAMESPACE FUNCTIONS =====
        # These use the existing sys::mutex_* implementation (CPOINTER-based)
        if ($name eq "async::mutex") {
            emit($cg, "strada_mutex_new()");
            return;
        }

        if ($name eq "async::lock") {
            emit($cg, "strada_mutex_lock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::unlock") {
            emit($cg, "strada_mutex_unlock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::try_lock") {
            emit($cg, "strada_mutex_trylock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::mutex_destroy") {
            emit($cg, "strada_mutex_destroy(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # ===== ATOMIC NAMESPACE FUNCTIONS =====
        if ($name eq "async::atomic") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                emit($cg, "strada_atomic_new(strada_to_int(");
                gen_expression($cg, $args->[0]);
                emit($cg, "))");
            } else {
                emit($cg, "strada_atomic_new(0)");
            }
            return;
        }

        if ($name eq "async::atomic_load") {
            emit($cg, "strada_new_int(strada_atomic_load(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::atomic_store") {
            emit($cg, "(strada_atomic_store(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")), strada_undef_static())");
            return;
        }

        if ($name eq "async::atomic_add") {
            emit($cg, "strada_new_int(strada_atomic_add(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        if ($name eq "async::atomic_sub") {
            emit($cg, "strada_new_int(strada_atomic_sub(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        if ($name eq "async::atomic_inc") {
            emit($cg, "strada_new_int(strada_atomic_inc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::atomic_dec") {
            emit($cg, "strada_new_int(strada_atomic_dec(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::atomic_cas") {
            emit($cg, "strada_new_int(strada_atomic_cas(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }

        # Directory functions
        if ($name eq "sys::readdir") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_readdir", $args, 1);
            return;
        }

        if ($name eq "sys::readdir_full") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_readdir_full", $args, 1);
            return;
        }

        if ($name eq "sys::is_dir") {
            emit($cg, "strada_is_dir(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::is_file") {
            emit($cg, "strada_is_file(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::file_exists") {
            emit($cg, "strada_new_int(strada_file_exists(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }

        if ($name eq "sys::dir_exists") {
            # dir_exists is the same as is_dir - returns 1 if path exists and is a directory
            emit($cg, "strada_is_dir(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::file_size") {
            emit($cg, "strada_file_size(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Math functions
        if ($name eq "math::sin") {
            emit($cg, "strada_sin(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::cos") {
            emit($cg, "strada_cos(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::tan") {
            emit($cg, "strada_tan(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::asin") {
            emit($cg, "strada_asin(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::acos") {
            emit($cg, "strada_acos(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::atan") {
            emit($cg, "strada_atan(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::atan2") {
            emit($cg, "strada_atan2(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::log") {
            emit($cg, "strada_log(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::log10") {
            emit($cg, "strada_log10(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::exp") {
            emit($cg, "strada_exp(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::pow") {
            emit($cg, "strada_pow(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::floor") {
            emit($cg, "strada_floor(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::ceil") {
            emit($cg, "strada_ceil(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::round") {
            emit($cg, "strada_round(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::fabs") {
            emit($cg, "strada_fabs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::fmod") {
            emit($cg, "strada_fmod(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::sinh") {
            emit($cg, "strada_sinh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::cosh") {
            emit($cg, "strada_cosh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::tanh") {
            emit($cg, "strada_tanh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # File seek functions
        if ($name eq "sys::seek") {
            emit($cg, "strada_seek(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 2) {
                gen_expression($cg, $args->[2]);
            } else {
                emit($cg, "strada_new_int(0)");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::tell") {
            emit($cg, "strada_tell(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::rewind") {
            emit($cg, "strada_rewind(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::eof") {
            emit($cg, "strada_eof(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::flush") {
            emit($cg, "strada_flush(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::readline") {
            emit($cg, "strada_read_line(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # DNS/Hostname functions
        if ($name eq "sys::gethostbyname") {
            emit($cg, "strada_gethostbyname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::gethostbyname_all") {
            emit($cg, "strada_gethostbyname_all(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::gethostname") {
            emit($cg, "strada_gethostname()");
            return;
        }

        if ($name eq "sys::getaddrinfo") {
            emit($cg, "strada_getaddrinfo_first(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "strada_new_str(\"\")");
            }
            emit($cg, ")");
            return;
        }

        # Path functions
        if ($name eq "sys::realpath") {
            emit($cg, "strada_realpath(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dirname") {
            emit($cg, "strada_dirname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::basename") {
            emit($cg, "strada_basename(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::glob") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_glob", $args, 1);
            return;
        }

        if ($name eq "sys::fnmatch") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_fnmatch", $args, 2);
            return;
        }

        if ($name eq "sys::file_ext") {
            emit($cg, "strada_file_ext(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::path_join") {
            emit($cg, "strada_path_join(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "int") {
            emit($cg, "strada_new_int(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "chr") {
            # Use strada_chr_sv for binary-safe chr that handles NUL bytes
            # Use emit_int_operand to avoid leaking memoria for integer literals
            emit($cg, "strada_chr_sv(");
            my scalar $args = $expr->{"args"};
            emit_int_operand($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        if ($name eq "ord") {
            emit($cg, "strada_new_int(strada_ord(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }

        # ord_byte - binary-safe ord that returns raw byte value 0-255
        if ($name eq "sys::ord_byte") {
            emit($cg, "strada_new_int(strada_ord_byte(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # get_byte - get byte at position (0-indexed), returns 0-255 or -1
        if ($name eq "sys::get_byte") {
            emit($cg, "strada_new_int(strada_get_byte(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # set_byte - set byte at position, returns new string
        if ($name eq "sys::set_byte") {
            emit($cg, "strada_set_byte(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[1]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        # byte_length - get byte length (not UTF-8 character count)
        if ($name eq "sys::byte_length") {
            emit($cg, "strada_new_int(strada_byte_length(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # byte_substr - substring by byte positions
        if ($name eq "sys::byte_substr") {
            emit($cg, "strada_byte_substr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "))");
            return;
        }

        # pack - pack values into binary string (Perl-like)
        # sys::pack($fmt, $val1, $val2, ...) -> strada_pack(fmt, array_of_values)
        if ($name eq "sys::pack") {
            emit($cg, "strada_pack(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), ");
            # Build array from remaining arguments
            my int $value_count = $expr->{"arg_count"} - 1;
            emit($cg, "strada_anon_array(" . $value_count);
            my int $i = 1;
            while ($i < $expr->{"arg_count"}) {
                emit($cg, ", ");
                gen_expression($cg, $args->[$i]);
                $i = $i + 1;
            }
            emit($cg, "))");
            return;
        }

        # unpack - unpack binary string to array (Perl-like)
        if ($name eq "sys::unpack") {
            emit($cg, "strada_unpack(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # base64_encode - encode string to base64
        if ($name eq "sys::base64_encode") {
            emit($cg, "strada_base64_encode(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # base64_decode - decode base64 to string
        if ($name eq "sys::base64_decode") {
            emit($cg, "strada_base64_decode(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "uc" || $name eq "upper") {
            emit($cg, "strada_new_str(strada_uc(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        if ($name eq "lc" || $name eq "lower") {
            emit($cg, "strada_new_str(strada_lc(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        if ($name eq "index") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count == 3) {
                # 3-argument form: index(string, substring, offset)
                emit($cg, "strada_new_int(strada_index_offset(strada_to_str(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, "), strada_to_int(");
                gen_expression($cg, $args->[2]);
                emit($cg, ")))");
            } else {
                # 2-argument form: index(string, substring)
                emit($cg, "strada_new_int(strada_index(strada_to_str(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, ")))");
            }
            return;
        }
        
        if ($name eq "sprintf") {
            emit($cg, "strada_sprintf_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", " . ($expr->{"arg_count"} - 1));
            my int $i = 1;
            while ($i < $expr->{"arg_count"}) {
                emit($cg, ", ");
                gen_expression($cg, $args->[$i]);
                $i = $i + 1;
            }
            emit($cg, ")");
            return;
        }
        
        if ($name eq "printf") {
            emit($cg, "strada_printf(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            my int $i = 1;
            while ($i < $expr->{"arg_count"}) {
                emit($cg, ", strada_to_str(");
                gen_expression($cg, $args->[$i]);
                emit($cg, ")");
                $i = $i + 1;
            }
            emit($cg, ")");
            return;
        }
        
        if ($name eq "warn") {
            emit($cg, "strada_warn(\"%s\", strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "sys::slurp" || $name eq "slurp") {
            emit($cg, "strada_slurp(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "sys::slurp_fh") {
            emit($cg, "strada_slurp_fh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::slurp_fd") {
            emit($cg, "strada_slurp_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::spew" || $name eq "spew") {
            emit($cg, "strada_spew(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        if ($name eq "sys::spew_fh") {
            emit($cg, "strada_spew_fh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::spew_fd") {
            emit($cg, "strada_spew_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # StringBuilder functions for O(1) amortized append
        if ($name eq "sb_new") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                emit($cg, "strada_sb_new_cap(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            } else {
                emit($cg, "strada_sb_new()");
            }
            return;
        }

        if ($name eq "sb_append") {
            emit($cg, "(strada_sb_append(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_undef_static())");
            return;
        }

        if ($name eq "sb_to_string") {
            emit($cg, "strada_sb_to_string(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sb_length") {
            emit($cg, "strada_sb_length(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sb_clear") {
            emit($cg, "(strada_sb_clear(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_undef_static())");
            return;
        }

        if ($name eq "sb_free") {
            emit($cg, "(strada_sb_free(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_undef_static())");
            return;
        }

        # open(filename, mode) - open file for reading/writing/appending
        if ($name eq "sys::open") {
            emit($cg, "strada_open(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        if ($name eq "sys::open_fd") {
            emit($cg, "strada_open_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # close(fh) - close file handle
        if ($name eq "sys::close") {
            emit($cg, "strada_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # write_fd(fd, str) - write to file descriptor
        if ($name eq "write_fd" || $name eq "sys::write_fd") {
            emit($cg, "strada_write_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # close_fd(fd) - close file descriptor
        if ($name eq "close_fd" || $name eq "sys::close_fd") {
            emit($cg, "strada_close_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # getpid() - get process ID
        if ($name eq "getpid" || $name eq "sys::getpid") {
            emit($cg, "strada_new_int(getpid())");
            return;
        }

        # unlink(path) - delete file
        if ($name eq "unlink" || $name eq "sys::unlink") {
            emit($cg, "strada_unlink(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # fwrite(fh, content) - write to file handle
        if ($name eq "sys::fwrite") {
            emit($cg, "strada_write_file(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # fread(fh) - read entire file from handle
        if ($name eq "sys::fread") {
            emit($cg, "strada_read_file(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "die") {
            emit($cg, "strada_die(\"%s\", strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "throw") {
            emit($cg, "strada_throw_value(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # scalar() - get array length as int
        if ($name eq "scalar") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($arg) == 1) {
                emit($cg, "({ StradaValue *__sc_tmp = ");
                gen_expression($cg, $arg);
                emit($cg, "; int64_t __sc_res = strada_array_length(strada_deref_array(__sc_tmp)); strada_decref(__sc_tmp); strada_new_int(__sc_res); })");
            } else {
                emit($cg, "strada_new_int(strada_array_length(strada_deref_array(");
                gen_expression($cg, $arg);
                emit($cg, ")))");
            }
            return;
        }
        
        # is_ref / is_refto - check if value is a reference
        if ($name eq "is_ref" || $name eq "is_refto") {
            emit($cg, "strada_new_int(strada_is_ref(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # reftype - get reference type string
        if ($name eq "reftype") {
            emit($cg, "strada_new_str(strada_reftype(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # refto - create a reference
        if ($name eq "refto") {
            emit($cg, "strada_new_ref(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", '$')");
            return;
        }
        
        # derefto - dereference
        if ($name eq "derefto" || $name eq "deref") {
            emit($cg, "strada_deref(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # deref_array - dereference to array (returns StradaValue*)
        if ($name eq "deref_array") {
            emit($cg, "strada_deref_array_value(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # deref_hash - dereference to hash (returns StradaValue*)
        if ($name eq "deref_hash") {
            emit($cg, "strada_deref_hash_value(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # deref_set - set value through a scalar reference
        if ($name eq "deref_set") {
            emit($cg, "strada_deref_set(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # clone - deep copy a value
        if ($name eq "clone") {
            emit($cg, "strada_clone(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # typeof - get type name string (returns StradaValue* str)
        if ($name eq "typeof") {
            emit($cg, "strada_new_str(strada_typeof(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # abs - absolute value
        if ($name eq "math::abs") {
            emit($cg, "strada_abs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # sqrt - square root
        if ($name eq "math::sqrt") {
            emit($cg, "strada_sqrt(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # rand - random number
        if ($name eq "math::rand") {
            emit($cg, "strada_rand()");
            return;
        }
        
        # time - current timestamp
        if ($name eq "sys::time") {
            emit($cg, "strada_time()");
            return;
        }

        # localtime - convert timestamp to local time hash
        if ($name eq "sys::localtime") {
            emit($cg, "strada_localtime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # gmtime - convert timestamp to UTC time hash
        if ($name eq "sys::gmtime") {
            emit($cg, "strada_gmtime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # mktime - convert time hash to timestamp
        if ($name eq "sys::mktime") {
            emit($cg, "strada_mktime(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # strftime - format time
        if ($name eq "sys::strftime") {
            emit($cg, "strada_strftime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($arg_count > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # ctime - convert timestamp to string
        if ($name eq "sys::ctime") {
            emit($cg, "strada_ctime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # sleep - sleep for seconds
        if ($name eq "sys::sleep") {
            emit($cg, "strada_sleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # usleep - sleep for microseconds
        if ($name eq "sys::usleep") {
            emit($cg, "strada_usleep(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # gettimeofday - high-res time
        if ($name eq "sys::gettimeofday") {
            emit($cg, "strada_gettimeofday()");
            return;
        }

        # hires_time - floating point seconds
        if ($name eq "sys::hires_time") {
            emit($cg, "strada_hires_time()");
            return;
        }

        # Memory profiler functions
        if ($name eq "sys::memprof_enable") {
            emit($cg, "(strada_memprof_enable(), strada_undef_static())");
            return;
        }
        if ($name eq "sys::memprof_disable") {
            emit($cg, "(strada_memprof_disable(), strada_undef_static())");
            return;
        }
        if ($name eq "sys::memprof_report") {
            emit($cg, "(strada_memprof_report(), strada_undef_static())");
            return;
        }
        if ($name eq "sys::memprof_reset") {
            emit($cg, "(strada_memprof_reset(), strada_undef_static())");
            return;
        }

        # tv_interval - time interval
        if ($name eq "sys::tv_interval") {
            emit($cg, "strada_tv_interval(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($arg_count > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # nanosleep - sleep nanoseconds
        if ($name eq "sys::nanosleep") {
            emit($cg, "strada_nanosleep_ns(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # clock_gettime - get clock time
        if ($name eq "sys::clock_gettime") {
            emit($cg, "strada_clock_gettime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # clock_getres - get clock resolution
        if ($name eq "sys::clock_getres") {
            emit($cg, "strada_clock_getres(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # dl_open - open shared library
        if ($name eq "sys::dl_open") {
            emit($cg, "strada_dl_open(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # strada_dl_open_raw - internal raw library open
        if ($name eq "strada_dl_open_raw") {
            emit($cg, "strada_dl_open_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # strada_dl_sym_raw - internal raw symbol lookup
        if ($name eq "strada_dl_sym_raw") {
            emit($cg, "strada_dl_sym_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # strada_dl_close_raw - internal raw library close
        if ($name eq "strada_dl_close_raw") {
            emit($cg, "strada_dl_close_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # dl_sym - get symbol from library
        if ($name eq "sys::dl_sym") {
            emit($cg, "strada_dl_sym(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_close - close library
        if ($name eq "sys::dl_close") {
            emit($cg, "strada_dl_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # dl_error - get last error
        if ($name eq "sys::dl_error") {
            emit($cg, "strada_dl_error()");
            return;
        }

        # dl_call_int - call function returning int
        if ($name eq "sys::dl_call_int") {
            emit($cg, "strada_dl_call_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_num - call function returning num
        if ($name eq "sys::dl_call_num") {
            emit($cg, "strada_dl_call_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_str - call function returning string
        if ($name eq "sys::dl_call_str") {
            emit($cg, "strada_dl_call_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_void - call function with no return
        if ($name eq "sys::dl_call_void") {
            emit($cg, "strada_dl_call_void(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_int_sv - call function passing StradaValue* directly, returns int
        if ($name eq "sys::dl_call_int_sv") {
            emit($cg, "strada_dl_call_int_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_str_sv - call function passing StradaValue* directly, returns string
        if ($name eq "sys::dl_call_str_sv") {
            emit($cg, "strada_dl_call_str_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_void_sv - call function passing StradaValue* directly, no return
        if ($name eq "sys::dl_call_void_sv") {
            emit($cg, "strada_dl_call_void_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_sv") {
            emit($cg, "strada_dl_call_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_export_info") {
            emit($cg, "strada_dl_call_export_info(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_version") {
            emit($cg, "strada_dl_call_version(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Pointer access for FFI
        if ($name eq "sys::int_ptr") {
            emit($cg, "strada_int_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::num_ptr") {
            emit($cg, "strada_num_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::str_ptr") {
            emit($cg, "strada_str_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_int") {
            emit($cg, "strada_ptr_deref_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_num") {
            emit($cg, "strada_ptr_deref_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_str") {
            emit($cg, "strada_ptr_deref_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_int") {
            emit($cg, "strada_ptr_set_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_num") {
            emit($cg, "strada_ptr_set_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # ============================================
        # c:: namespace - C interop helper functions
        # ============================================

        # c::str_to_ptr - Convert Strada string to C char* (allocates)
        if ($name eq "c::str_to_ptr") {
            emit($cg, "strada_c_str_to_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # c::ptr_to_str - Convert C char* to Strada string (copies)
        if ($name eq "c::ptr_to_str") {
            emit($cg, "strada_c_ptr_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # c::ptr_to_str_n - Convert C char* to Strada string with length
        if ($name eq "c::ptr_to_str_n") {
            emit($cg, "strada_c_ptr_to_str_n(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # c::free - Free C-allocated memory
        if ($name eq "c::free") {
            emit($cg, "strada_c_free(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # c::alloc - Allocate memory (malloc wrapper)
        if ($name eq "c::alloc") {
            emit($cg, "strada_c_alloc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # c::realloc - Reallocate memory
        if ($name eq "c::realloc") {
            emit($cg, "strada_c_realloc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # c::null - Return NULL pointer
        if ($name eq "c::null") {
            emit($cg, "strada_c_null()");
            return;
        }

        # c::is_null - Check if pointer is NULL
        if ($name eq "c::is_null") {
            emit($cg, "strada_c_is_null(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # c::ptr_add - Pointer arithmetic
        if ($name eq "c::ptr_add") {
            emit($cg, "strada_c_ptr_add(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # c:: memory read functions
        if ($name eq "c::read_int8") {
            emit($cg, "strada_c_read_int8(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::read_int16") {
            emit($cg, "strada_c_read_int16(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::read_int32") {
            emit($cg, "strada_c_read_int32(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::read_int64") {
            emit($cg, "strada_c_read_int64(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::read_ptr") {
            emit($cg, "strada_c_read_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::read_float") {
            emit($cg, "strada_c_read_float(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::read_double") {
            emit($cg, "strada_c_read_double(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # c:: memory write functions
        if ($name eq "c::write_int8") {
            emit($cg, "strada_c_write_int8(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::write_int16") {
            emit($cg, "strada_c_write_int16(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::write_int32") {
            emit($cg, "strada_c_write_int32(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::write_int64") {
            emit($cg, "strada_c_write_int64(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::write_ptr") {
            emit($cg, "strada_c_write_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::write_float") {
            emit($cg, "strada_c_write_float(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::write_double") {
            emit($cg, "strada_c_write_double(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # c:: size introspection
        if ($name eq "c::sizeof_int") {
            emit($cg, "strada_c_sizeof_int()");
            return;
        }

        if ($name eq "c::sizeof_long") {
            emit($cg, "strada_c_sizeof_long()");
            return;
        }

        if ($name eq "c::sizeof_ptr") {
            emit($cg, "strada_c_sizeof_ptr()");
            return;
        }

        if ($name eq "c::sizeof_size_t") {
            emit($cg, "strada_c_sizeof_size_t()");
            return;
        }

        # c:: memory operations
        if ($name eq "c::memcpy") {
            emit($cg, "strada_c_memcpy(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::memset") {
            emit($cg, "strada_c_memset(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        # readline - read line from stdin or file handle
        if ($name eq "readline") {
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                # readline(fh) - read from file handle
                emit($cg, "strada_read_line(");
                my scalar $args = $expr->{"args"};
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            } else {
                # readline() - read from stdin
                emit($cg, "strada_readline()");
            }
            return;
        }
        
        # refcount - get reference count
        if ($name eq "refcount") {
            emit($cg, "strada_new_int(strada_refcount(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # free - explicitly decrement refcount, free if zero, and set variable to undef
        # free(\$var) -> frees $var's value and sets $var = undef (same as release)
        if ($name eq "free" || $name eq "sys::free" || $name eq "sys::release") {
            my scalar $args = $expr->{"args"};
            my scalar $ref_arg = $args->[0];

            # Check if argument is a reference expression like \$var
            if ($ref_arg->{"type"} == NODE_REF() && $ref_arg->{"target"}->{"type"} == NODE_VARIABLE()) {
                my str $varname = $ref_arg->{"target"}->{"name"};
                # Generate: (strada_free(varname), varname = strada_new_undef())
                emit($cg, "(strada_free(" . $varname . "), " . $varname . " = strada_new_undef())");
            } else {
                # Fallback: just call the runtime function
                emit($cg, "strada_release(");
                gen_expression($cg, $ref_arg);
                emit($cg, ")");
            }
            return;
        }

        # ucfirst - uppercase first letter
        if ($name eq "ucfirst") {
            emit($cg, "strada_new_str(strada_ucfirst(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # lcfirst - lowercase first letter
        if ($name eq "lcfirst") {
            emit($cg, "strada_new_str(strada_lcfirst(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # match - regex match
        if ($name eq "match") {
            emit($cg, "strada_new_int(strada_regex_match(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }
        
        # capture - regex capture
        if ($name eq "capture") {
            emit($cg, "strada_new_array_from_av(strada_regex_capture(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # captures - get captures from last =~ match
        if ($name eq "captures") {
            emit($cg, "strada_captures()");
            return;
        }

        # replace - regex replace (no flags for function-based API)
        if ($name eq "replace") {
            emit($cg, "strada_new_str(strada_regex_replace(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), NULL))");
            return;
        }
        
        # cstruct_set_int
        if ($name eq "sys::cstruct_set_int") {
            emit($cg, "strada_cstruct_set_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_set_string
        if ($name eq "sys::cstruct_set_string") {
            emit($cg, "strada_cstruct_set_string(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_set_double
        if ($name eq "sys::cstruct_set_double") {
            emit($cg, "strada_cstruct_set_double(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_num(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_get_int
        if ($name eq "sys::cstruct_get_int") {
            emit($cg, "strada_new_int(strada_cstruct_get_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_get_string
        if ($name eq "sys::cstruct_get_string") {
            emit($cg, "strada_new_str(strada_cstruct_get_string(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_get_double
        if ($name eq "sys::cstruct_get_double") {
            emit($cg, "strada_new_num(strada_cstruct_get_double(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_new
        if ($name eq "sys::cstruct_new") {
            emit($cg, "strada_cstruct_new(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_ptr
        if ($name eq "sys::cstruct_ptr") {
            emit($cg, "strada_cstruct_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # socket_client
        if ($name eq "sys::socket_client") {
            emit($cg, "strada_socket_client(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }
        
        # socket_server
        if ($name eq "sys::socket_server") {
            emit($cg, "strada_socket_server(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # socket_server_backlog
        if ($name eq "sys::socket_server_backlog") {
            emit($cg, "strada_socket_server_backlog(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # socket_accept
        if ($name eq "sys::socket_accept") {
            emit($cg, "strada_socket_accept(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # socket_recv
        if ($name eq "sys::socket_recv") {
            emit($cg, "strada_socket_recv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }
        
        # socket_send - use binary-safe version that handles NUL bytes
        if ($name eq "sys::socket_send") {
            emit($cg, "strada_socket_send_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }
        
        # socket_close
        if ($name eq "sys::socket_close") {
            emit($cg, "strada_socket_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # socket_flush - flush write buffer
        if ($name eq "sys::socket_flush") {
            emit($cg, "strada_socket_flush(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # socket_select - wait for sockets to be ready for reading
        if ($name eq "sys::socket_select") {
            emit($cg, "strada_socket_select(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # socket_fd - get file descriptor from socket
        if ($name eq "sys::socket_fd") {
            emit($cg, "strada_new_int(strada_socket_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # select_fds - wait for file descriptors to be ready for reading
        if ($name eq "sys::select_fds") {
            emit($cg, "strada_select_fds(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # UDP socket functions

        # udp_socket - create a UDP socket
        if ($name eq "sys::udp_socket") {
            emit($cg, "strada_udp_socket()");
            return;
        }

        # udp_bind - bind UDP socket to a port
        if ($name eq "sys::udp_bind") {
            emit($cg, "strada_new_int(strada_udp_bind(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # udp_server - create UDP server bound to a port
        if ($name eq "sys::udp_server") {
            emit($cg, "strada_udp_server(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # udp_recvfrom - receive UDP packet with sender info
        if ($name eq "sys::udp_recvfrom") {
            emit($cg, "strada_udp_recvfrom(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # udp_sendto - send UDP packet to host:port
        if ($name eq "sys::udp_sendto") {
            emit($cg, "strada_new_int(strada_udp_sendto_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[3]);
            emit($cg, ")))");
            return;
        }

        # stacktrace - print stack trace to stderr (like Carp::cluck)
        if ($name eq "stacktrace") {
            emit($cg, "(strada_stacktrace(), strada_undef_static())");
            return;
        }

        # stacktrace_str - return stack trace as string (like Carp::longmess)
        if ($name eq "stacktrace_str") {
            emit($cg, "strada_new_str(strada_stacktrace_str())");
            return;
        }

        # caller - get caller info at given level
        if ($name eq "caller") {
            my scalar $args = $expr->{"args"};
            if ($expr->{"arg_count"} > 0) {
                emit($cg, "strada_new_str(strada_caller(strada_to_int(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")))");
            } else {
                emit($cg, "strada_new_str(strada_caller(1))");
            }
            return;
        }
        
        # trim - trim whitespace
        if ($name eq "trim") {
            emit($cg, "strada_new_str(strada_trim(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # ltrim - trim left whitespace
        if ($name eq "ltrim") {
            emit($cg, "strada_new_str(strada_ltrim(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # rtrim - trim right whitespace
        if ($name eq "rtrim") {
            emit($cg, "strada_new_str(strada_rtrim(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_new - create new C struct
        if ($name eq "sys::cstruct_new") {
            emit($cg, "strada_cstruct_new(\"struct\", ");
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_to_int(");
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_set_int - set int field in C struct
        if ($name eq "sys::cstruct_set_int") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_cstruct_set_int(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_get_int - get int field from C struct
        if ($name eq "sys::cstruct_get_int") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_int(strada_cstruct_get_int(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # reverse - reverse a string or array
        if ($name eq "reverse") {
            emit($cg, "strada_reverse_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # repeat - repeat a string
        if ($name eq "repeat") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_str(strada_repeat(strada_to_str(");
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }
        
        # replace_all - replace all occurrences
        if ($name eq "replace_all") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_str(strada_replace_all(strada_to_str(");
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # chomp - remove trailing newline
        if ($name eq "chomp") {
            emit($cg, "strada_new_str(strada_chomp(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # chop - remove last character
        if ($name eq "chop") {
            emit($cg, "strada_new_str(strada_chop(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_set_string - set string field in C struct
        if ($name eq "sys::cstruct_set_string") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_cstruct_set_string(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_str(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_set_double - set double field in C struct
        if ($name eq "sys::cstruct_set_double") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_cstruct_set_double(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_num(");
            gen_expression($cg, $args->[3]);
            emit($cg, "))");
            return;
        }
        
        # cast_int - cast value to int
        if ($name eq "cast_int") {
            emit($cg, "strada_new_int(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # cast_num - cast value to num
        if ($name eq "cast_num") {
            emit($cg, "strada_new_num(strada_to_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # cast_str - cast value to str
        if ($name eq "cast_str") {
            emit($cg, "strada_new_str(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_get_string - get string field from C struct
        if ($name eq "sys::cstruct_get_string") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_str(strada_cstruct_get_string(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_get_double - get double field from C struct
        if ($name eq "sys::cstruct_get_double") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_num(strada_cstruct_get_double(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")))");
            return;
        }
        
        # cstruct_ptr - get raw pointer from C struct
        if ($name eq "sys::cstruct_ptr") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_cstruct_ptr(");
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # OOP - bless($ref, "Package") - bless a reference into a package
        if ($name eq "bless") {
            my scalar $args = $expr->{"args"};
            my scalar $pkg_arg = $args->[1];
            if ($pkg_arg->{"type"} == NODE_STR_LITERAL()) {
                # String literal - emit directly (no allocation)
                emit($cg, "strada_bless(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_str_literal_c($cg, $pkg_arg->{"value"});
                emit($cg, ")");
            } else {
                # Expression - need to convert and free after bless
                emit($cg, "({ StradaValue *__bless_tmp = ");
                gen_expression($cg, $pkg_arg);
                emit($cg, "; char *__bless_ps = strada_to_str(__bless_tmp); ");
                if (needs_temp_cleanup($pkg_arg) == 1) {
                    emit($cg, "strada_decref(__bless_tmp); ");
                }
                emit($cg, "StradaValue *__bless_r = strada_bless(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __bless_ps); free(__bless_ps); __bless_r; })");
            }
            return;
        }

        # OOP - blessed($ref) - get package name or undef
        if ($name eq "blessed") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_blessed(");
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # OOP - set_package("Name") - set current package context
        if ($name eq "set_package") {
            my scalar $args = $expr->{"args"};
            my scalar $pkg_arg = $args->[0];
            if ($pkg_arg->{"type"} == NODE_STR_LITERAL()) {
                emit($cg, "strada_set_package(");
                gen_str_literal_c($cg, $pkg_arg->{"value"});
                emit($cg, ")");
            } else {
                emit($cg, "({ StradaValue *__setpkg_t = ");
                gen_expression($cg, $pkg_arg);
                emit($cg, "; char *__setpkg_s = strada_to_str(__setpkg_t); ");
                if (needs_temp_cleanup($pkg_arg) == 1) {
                    emit($cg, "strada_decref(__setpkg_t); ");
                }
                emit($cg, "strada_set_package(__setpkg_s); free(__setpkg_s); })");
            }
            return;
        }

        # OOP - inherit("Parent") or inherit("Child", "Parent") - set up inheritance
        if ($name eq "inherit") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count == 1) {
                # Single arg: inherit from parent using current package
                my scalar $parent_arg = $args->[0];
                if ($parent_arg->{"type"} == NODE_STR_LITERAL()) {
                    # String literal - emit directly
                    emit($cg, "strada_inherit_from(");
                    gen_str_literal_c($cg, $parent_arg->{"value"});
                    emit($cg, ")");
                } else {
                    # Expression - need to free temp
                    emit($cg, "({ StradaValue *__inh_p = ");
                    gen_expression($cg, $parent_arg);
                    emit($cg, "; char *__inh_ps = strada_to_str(__inh_p); ");
                    emit($cg, "strada_inherit_from(__inh_ps); ");
                    emit($cg, "free(__inh_ps); ");
                    if (needs_temp_cleanup($parent_arg) == 1) {
                        emit($cg, "strada_decref(__inh_p); ");
                    }
                    emit($cg, "})");
                }
            } else {
                # Two args: inherit(child, parent)
                my scalar $child_arg = $args->[0];
                my scalar $parent_arg = $args->[1];
                my int $child_is_lit = $child_arg->{"type"} == NODE_STR_LITERAL();
                my int $parent_is_lit = $parent_arg->{"type"} == NODE_STR_LITERAL();

                if ($child_is_lit == 1 && $parent_is_lit == 1) {
                    # Both literals - emit directly
                    emit($cg, "strada_inherit(");
                    gen_str_literal_c($cg, $child_arg->{"value"});
                    emit($cg, ", ");
                    gen_str_literal_c($cg, $parent_arg->{"value"});
                    emit($cg, ")");
                } else {
                    # At least one expression - wrap for cleanup
                    emit($cg, "({ StradaValue *__inh_c = ");
                    gen_expression($cg, $child_arg);
                    emit($cg, "; StradaValue *__inh_p = ");
                    gen_expression($cg, $parent_arg);
                    emit($cg, "; char *__inh_cs = strada_to_str(__inh_c); ");
                    emit($cg, "char *__inh_ps = strada_to_str(__inh_p); ");
                    emit($cg, "strada_inherit(__inh_cs, __inh_ps); ");
                    emit($cg, "free(__inh_cs); free(__inh_ps); ");
                    if (needs_temp_cleanup($child_arg) == 1) {
                        emit($cg, "strada_decref(__inh_c); ");
                    }
                    if (needs_temp_cleanup($parent_arg) == 1) {
                        emit($cg, "strada_decref(__inh_p); ");
                    }
                    emit($cg, "})");
                }
            }
            return;
        }

        # OOP - isa($obj, "Package") - check if object is of a type
        if ($name eq "isa") {
            my scalar $args = $expr->{"args"};
            my scalar $pkg_arg = $args->[1];
            if ($pkg_arg->{"type"} == NODE_STR_LITERAL()) {
                emit($cg, "strada_new_int(strada_isa(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_str_literal_c($cg, $pkg_arg->{"value"});
                emit($cg, "))");
            } else {
                emit($cg, "({ StradaValue *__isa_t = ");
                gen_expression($cg, $pkg_arg);
                emit($cg, "; char *__isa_s = strada_to_str(__isa_t); ");
                if (needs_temp_cleanup($pkg_arg) == 1) {
                    emit($cg, "strada_decref(__isa_t); ");
                }
                emit($cg, "int __isa_r = strada_isa(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __isa_s); free(__isa_s); strada_new_int(__isa_r); })");
            }
            return;
        }

        # OOP - can($obj, "method") - check if object can do a method
        if ($name eq "can") {
            my scalar $args = $expr->{"args"};
            my scalar $meth_arg = $args->[1];
            if ($meth_arg->{"type"} == NODE_STR_LITERAL()) {
                emit($cg, "strada_new_int(strada_can(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_str_literal_c($cg, $meth_arg->{"value"});
                emit($cg, "))");
            } else {
                emit($cg, "({ StradaValue *__can_t = ");
                gen_expression($cg, $meth_arg);
                emit($cg, "; char *__can_s = strada_to_str(__can_t); ");
                if (needs_temp_cleanup($meth_arg) == 1) {
                    emit($cg, "strada_decref(__can_t); ");
                }
                emit($cg, "int __can_r = strada_can(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __can_s); free(__can_s); strada_new_int(__can_r); })");
            }
            return;
        }

        # OOP - UNIVERSAL::isa($obj, "Package") - Perl-style type check
        if ($name eq "UNIVERSAL::isa") {
            my scalar $args = $expr->{"args"};
            my scalar $pkg_arg = $args->[1];
            if ($pkg_arg->{"type"} == NODE_STR_LITERAL()) {
                emit($cg, "strada_new_int(strada_isa(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_str_literal_c($cg, $pkg_arg->{"value"});
                emit($cg, "))");
            } else {
                emit($cg, "({ StradaValue *__isa_t = ");
                gen_expression($cg, $pkg_arg);
                emit($cg, "; char *__isa_s = strada_to_str(__isa_t); ");
                if (needs_temp_cleanup($pkg_arg) == 1) {
                    emit($cg, "strada_decref(__isa_t); ");
                }
                emit($cg, "int __isa_r = strada_isa(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __isa_s); free(__isa_s); strada_new_int(__isa_r); })");
            }
            return;
        }

        # OOP - UNIVERSAL::can($obj, "method") - Perl-style method check
        if ($name eq "UNIVERSAL::can") {
            my scalar $args = $expr->{"args"};
            my scalar $meth_arg = $args->[1];
            if ($meth_arg->{"type"} == NODE_STR_LITERAL()) {
                emit($cg, "strada_new_int(strada_can(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_str_literal_c($cg, $meth_arg->{"value"});
                emit($cg, "))");
            } else {
                emit($cg, "({ StradaValue *__can_t = ");
                gen_expression($cg, $meth_arg);
                emit($cg, "; char *__can_s = strada_to_str(__can_t); ");
                if (needs_temp_cleanup($meth_arg) == 1) {
                    emit($cg, "strada_decref(__can_t); ");
                }
                emit($cg, "int __can_r = strada_can(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __can_s); free(__can_s); strada_new_int(__can_r); })");
            }
            return;
        }

        # ============================================================
        # NEW LIBC FUNCTIONS
        # ============================================================

        # Additional File I/O
        if ($name eq "sys::fgetc") {
            emit($cg, "strada_fgetc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fputc") {
            emit($cg, "strada_fputc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fgets") {
            emit($cg, "strada_fgets(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fputs") {
            emit($cg, "strada_fputs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ferror") {
            emit($cg, "strada_ferror(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fileno") {
            emit($cg, "strada_fileno(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clearerr") {
            emit($cg, "strada_clearerr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Temporary files
        if ($name eq "sys::tmpfile") {
            emit($cg, "strada_tmpfile()");
            return;
        }

        if ($name eq "sys::mkstemp") {
            emit($cg, "strada_mkstemp(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mkdtemp") {
            emit($cg, "strada_mkdtemp(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Command execution (popen)
        if ($name eq "sys::popen") {
            emit($cg, "strada_popen(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::pclose") {
            emit($cg, "strada_pclose(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Command execution with output capture (backticks/qx)
        if ($name eq "sys::qx") {
            emit($cg, "strada_qx(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Additional file system
        if ($name eq "sys::truncate") {
            emit($cg, "strada_truncate(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ftruncate") {
            emit($cg, "strada_ftruncate(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::chown") {
            emit($cg, "strada_chown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::lchown") {
            emit($cg, "strada_lchown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fchmod") {
            emit($cg, "strada_fchmod(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fchown") {
            emit($cg, "strada_fchown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::utime") {
            emit($cg, "strada_utime(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::utimes") {
            emit($cg, "strada_utimes(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        # Session/process group control
        if ($name eq "sys::setsid") {
            emit($cg, "strada_setsid()");
            return;
        }

        if ($name eq "sys::getsid") {
            emit($cg, "strada_getsid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setpgid") {
            emit($cg, "strada_setpgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpgid") {
            emit($cg, "strada_getpgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpgrp") {
            emit($cg, "strada_getpgrp()");
            return;
        }

        if ($name eq "sys::setpgrp") {
            emit($cg, "strada_setpgrp()");
            return;
        }

        # User/group ID control
        if ($name eq "sys::setuid") {
            emit($cg, "strada_setuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setgid") {
            emit($cg, "strada_setgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::seteuid") {
            emit($cg, "strada_seteuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setegid") {
            emit($cg, "strada_setegid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setreuid") {
            emit($cg, "strada_setreuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setregid") {
            emit($cg, "strada_setregid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # Additional socket operations
        if ($name eq "sys::setsockopt") {
            emit($cg, "strada_setsockopt(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ", ");
            gen_expression($cg, $args->[3]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getsockopt") {
            emit($cg, "strada_getsockopt(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::shutdown") {
            emit($cg, "strada_shutdown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpeername") {
            emit($cg, "strada_getpeername(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getsockname") {
            emit($cg, "strada_getsockname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_pton") {
            emit($cg, "strada_inet_pton(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_ntop") {
            emit($cg, "strada_inet_ntop(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_addr") {
            emit($cg, "strada_inet_addr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_ntoa") {
            emit($cg, "strada_inet_ntoa(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::htons") {
            emit($cg, "strada_htons(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::htonl") {
            emit($cg, "strada_htonl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ntohs") {
            emit($cg, "strada_ntohs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ntohl") {
            emit($cg, "strada_ntohl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::poll") {
            emit($cg, "strada_poll(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # Random seeding
        if ($name eq "sys::srand") {
            emit($cg, "strada_srand(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::srandom") {
            emit($cg, "strada_srandom(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::rand") {
            emit($cg, "strada_libc_rand()");
            return;
        }

        if ($name eq "sys::random") {
            emit($cg, "strada_libc_random()");
            return;
        }

        # Advanced signals
        if ($name eq "sys::sigprocmask") {
            emit($cg, "strada_sigprocmask(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::raise") {
            emit($cg, "strada_raise(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::killpg") {
            emit($cg, "strada_killpg(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::pause") {
            emit($cg, "strada_pause()");
            return;
        }

        # User/Group database
        if ($name eq "sys::getpwnam") {
            emit($cg, "strada_getpwnam(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpwuid") {
            emit($cg, "strada_getpwuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getgrnam") {
            emit($cg, "strada_getgrnam(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getgrgid") {
            emit($cg, "strada_getgrgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getlogin") {
            emit($cg, "strada_getlogin()");
            return;
        }

        if ($name eq "sys::getgroups") {
            emit($cg, "strada_getgroups()");
            return;
        }

        # Resource/Priority
        if ($name eq "sys::nice") {
            emit($cg, "strada_nice(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpriority") {
            emit($cg, "strada_getpriority(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setpriority") {
            emit($cg, "strada_setpriority(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getrusage") {
            emit($cg, "strada_getrusage(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getrlimit") {
            emit($cg, "strada_getrlimit(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setrlimit") {
            emit($cg, "strada_setrlimit(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # Additional time functions
        if ($name eq "sys::difftime") {
            emit($cg, "strada_difftime(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clock") {
            emit($cg, "strada_clock()");
            return;
        }

        if ($name eq "sys::times") {
            emit($cg, "strada_times()");
            return;
        }

        # Additional memory functions
        if ($name eq "sys::calloc") {
            emit($cg, "strada_calloc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::realloc") {
            emit($cg, "strada_realloc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mmap") {
            emit($cg, "strada_mmap(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ", ");
            gen_expression($cg, $args->[3]);
            emit($cg, ", ");
            gen_expression($cg, $args->[4]);
            emit($cg, ", ");
            gen_expression($cg, $args->[5]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::munmap") {
            emit($cg, "strada_munmap(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mlock") {
            emit($cg, "strada_mlock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::munlock") {
            emit($cg, "strada_munlock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # String conversion
        if ($name eq "sys::strtol") {
            emit($cg, "strada_strtol(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::strtod") {
            emit($cg, "strada_strtod(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::atoi") {
            emit($cg, "strada_atoi(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::atof") {
            emit($cg, "strada_atof(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Terminal/TTY
        if ($name eq "sys::ttyname") {
            emit($cg, "strada_ttyname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::tcgetattr") {
            emit($cg, "strada_tcgetattr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::tcsetattr") {
            emit($cg, "strada_tcsetattr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfgetospeed") {
            emit($cg, "strada_cfgetospeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfsetospeed") {
            emit($cg, "strada_cfsetospeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfgetispeed") {
            emit($cg, "strada_cfgetispeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfsetispeed") {
            emit($cg, "strada_cfsetispeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # serial_open - high-level serial port open
        if ($name eq "sys::serial_open") {
            emit($cg, "strada_serial_open(strada_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "), ");
            if ($expr->{"arg_count"} > 2) {
                emit($cg, "strada_to_str(");
                gen_expression($cg, $args->[2]);
                emit($cg, ")");
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # tcflush - flush input/output queues
        if ($name eq "sys::tcflush") {
            emit($cg, "strada_tcflush(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # tcdrain - wait for output to be transmitted
        if ($name eq "sys::tcdrain") {
            emit($cg, "strada_tcdrain(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Baud rate constants
        if ($name eq "sys::B0") { emit($cg, "strada_new_int(B0)"); return; }
        if ($name eq "sys::B50") { emit($cg, "strada_new_int(B50)"); return; }
        if ($name eq "sys::B75") { emit($cg, "strada_new_int(B75)"); return; }
        if ($name eq "sys::B110") { emit($cg, "strada_new_int(B110)"); return; }
        if ($name eq "sys::B134") { emit($cg, "strada_new_int(B134)"); return; }
        if ($name eq "sys::B150") { emit($cg, "strada_new_int(B150)"); return; }
        if ($name eq "sys::B200") { emit($cg, "strada_new_int(B200)"); return; }
        if ($name eq "sys::B300") { emit($cg, "strada_new_int(B300)"); return; }
        if ($name eq "sys::B600") { emit($cg, "strada_new_int(B600)"); return; }
        if ($name eq "sys::B1200") { emit($cg, "strada_new_int(B1200)"); return; }
        if ($name eq "sys::B1800") { emit($cg, "strada_new_int(B1800)"); return; }
        if ($name eq "sys::B2400") { emit($cg, "strada_new_int(B2400)"); return; }
        if ($name eq "sys::B4800") { emit($cg, "strada_new_int(B4800)"); return; }
        if ($name eq "sys::B9600") { emit($cg, "strada_new_int(B9600)"); return; }
        if ($name eq "sys::B19200") { emit($cg, "strada_new_int(B19200)"); return; }
        if ($name eq "sys::B38400") { emit($cg, "strada_new_int(B38400)"); return; }
        if ($name eq "sys::B57600") { emit($cg, "strada_new_int(B57600)"); return; }
        if ($name eq "sys::B115200") { emit($cg, "strada_new_int(B115200)"); return; }
        if ($name eq "sys::B230400") { emit($cg, "strada_new_int(B230400)"); return; }
        if ($name eq "sys::B460800") { emit($cg, "strada_new_int(B460800)"); return; }
        if ($name eq "sys::B500000") { emit($cg, "strada_new_int(B500000)"); return; }
        if ($name eq "sys::B576000") { emit($cg, "strada_new_int(B576000)"); return; }
        if ($name eq "sys::B921600") { emit($cg, "strada_new_int(B921600)"); return; }
        if ($name eq "sys::B1000000") { emit($cg, "strada_new_int(B1000000)"); return; }
        if ($name eq "sys::B1152000") { emit($cg, "strada_new_int(B1152000)"); return; }
        if ($name eq "sys::B1500000") { emit($cg, "strada_new_int(B1500000)"); return; }
        if ($name eq "sys::B2000000") { emit($cg, "strada_new_int(B2000000)"); return; }

        # Termios control mode flags (c_cflag)
        if ($name eq "sys::CSIZE") { emit($cg, "strada_new_int(CSIZE)"); return; }
        if ($name eq "sys::CS5") { emit($cg, "strada_new_int(CS5)"); return; }
        if ($name eq "sys::CS6") { emit($cg, "strada_new_int(CS6)"); return; }
        if ($name eq "sys::CS7") { emit($cg, "strada_new_int(CS7)"); return; }
        if ($name eq "sys::CS8") { emit($cg, "strada_new_int(CS8)"); return; }
        if ($name eq "sys::CSTOPB") { emit($cg, "strada_new_int(CSTOPB)"); return; }
        if ($name eq "sys::CREAD") { emit($cg, "strada_new_int(CREAD)"); return; }
        if ($name eq "sys::PARENB") { emit($cg, "strada_new_int(PARENB)"); return; }
        if ($name eq "sys::PARODD") { emit($cg, "strada_new_int(PARODD)"); return; }
        if ($name eq "sys::HUPCL") { emit($cg, "strada_new_int(HUPCL)"); return; }
        if ($name eq "sys::CLOCAL") { emit($cg, "strada_new_int(CLOCAL)"); return; }
        if ($name eq "sys::CRTSCTS") { emit($cg, "strada_new_int(CRTSCTS)"); return; }

        # Termios input mode flags (c_iflag)
        if ($name eq "sys::IGNBRK") { emit($cg, "strada_new_int(IGNBRK)"); return; }
        if ($name eq "sys::BRKINT") { emit($cg, "strada_new_int(BRKINT)"); return; }
        if ($name eq "sys::IGNPAR") { emit($cg, "strada_new_int(IGNPAR)"); return; }
        if ($name eq "sys::PARMRK") { emit($cg, "strada_new_int(PARMRK)"); return; }
        if ($name eq "sys::INPCK") { emit($cg, "strada_new_int(INPCK)"); return; }
        if ($name eq "sys::ISTRIP") { emit($cg, "strada_new_int(ISTRIP)"); return; }
        if ($name eq "sys::INLCR") { emit($cg, "strada_new_int(INLCR)"); return; }
        if ($name eq "sys::IGNCR") { emit($cg, "strada_new_int(IGNCR)"); return; }
        if ($name eq "sys::ICRNL") { emit($cg, "strada_new_int(ICRNL)"); return; }
        if ($name eq "sys::IXON") { emit($cg, "strada_new_int(IXON)"); return; }
        if ($name eq "sys::IXOFF") { emit($cg, "strada_new_int(IXOFF)"); return; }
        if ($name eq "sys::IXANY") { emit($cg, "strada_new_int(IXANY)"); return; }

        # Termios output mode flags (c_oflag)
        if ($name eq "sys::OPOST") { emit($cg, "strada_new_int(OPOST)"); return; }
        if ($name eq "sys::ONLCR") { emit($cg, "strada_new_int(ONLCR)"); return; }
        if ($name eq "sys::OCRNL") { emit($cg, "strada_new_int(OCRNL)"); return; }

        # Termios local mode flags (c_lflag)
        if ($name eq "sys::ISIG") { emit($cg, "strada_new_int(ISIG)"); return; }
        if ($name eq "sys::ICANON") { emit($cg, "strada_new_int(ICANON)"); return; }
        if ($name eq "sys::ECHO") { emit($cg, "strada_new_int(ECHO)"); return; }
        if ($name eq "sys::ECHOE") { emit($cg, "strada_new_int(ECHOE)"); return; }
        if ($name eq "sys::ECHOK") { emit($cg, "strada_new_int(ECHOK)"); return; }
        if ($name eq "sys::ECHONL") { emit($cg, "strada_new_int(ECHONL)"); return; }
        if ($name eq "sys::NOFLSH") { emit($cg, "strada_new_int(NOFLSH)"); return; }
        if ($name eq "sys::TOSTOP") { emit($cg, "strada_new_int(TOSTOP)"); return; }
        if ($name eq "sys::IEXTEN") { emit($cg, "strada_new_int(IEXTEN)"); return; }

        # tcsetattr when values
        if ($name eq "sys::TCSANOW") { emit($cg, "strada_new_int(TCSANOW)"); return; }
        if ($name eq "sys::TCSADRAIN") { emit($cg, "strada_new_int(TCSADRAIN)"); return; }
        if ($name eq "sys::TCSAFLUSH") { emit($cg, "strada_new_int(TCSAFLUSH)"); return; }

        # tcflush queue selectors
        if ($name eq "sys::TCIFLUSH") { emit($cg, "strada_new_int(TCIFLUSH)"); return; }
        if ($name eq "sys::TCOFLUSH") { emit($cg, "strada_new_int(TCOFLUSH)"); return; }
        if ($name eq "sys::TCIOFLUSH") { emit($cg, "strada_new_int(TCIOFLUSH)"); return; }

        # File open flags (for low-level open)
        if ($name eq "sys::O_RDONLY") { emit($cg, "strada_new_int(O_RDONLY)"); return; }
        if ($name eq "sys::O_WRONLY") { emit($cg, "strada_new_int(O_WRONLY)"); return; }
        if ($name eq "sys::O_RDWR") { emit($cg, "strada_new_int(O_RDWR)"); return; }
        if ($name eq "sys::O_CREAT") { emit($cg, "strada_new_int(O_CREAT)"); return; }
        if ($name eq "sys::O_EXCL") { emit($cg, "strada_new_int(O_EXCL)"); return; }
        if ($name eq "sys::O_NOCTTY") { emit($cg, "strada_new_int(O_NOCTTY)"); return; }
        if ($name eq "sys::O_TRUNC") { emit($cg, "strada_new_int(O_TRUNC)"); return; }
        if ($name eq "sys::O_APPEND") { emit($cg, "strada_new_int(O_APPEND)"); return; }
        if ($name eq "sys::O_NONBLOCK") { emit($cg, "strada_new_int(O_NONBLOCK)"); return; }
        if ($name eq "sys::O_SYNC") { emit($cg, "strada_new_int(O_SYNC)"); return; }

        # Advanced file operations
        if ($name eq "sys::fcntl") {
            emit($cg, "strada_fcntl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 2) {
                gen_expression($cg, $args->[2]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::flock") {
            emit($cg, "strada_flock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ioctl") {
            emit($cg, "strada_ioctl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 2) {
                gen_expression($cg, $args->[2]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::statvfs") {
            emit($cg, "strada_statvfs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fstatvfs") {
            emit($cg, "strada_fstatvfs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dup") {
            emit($cg, "strada_dup(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Additional math functions
        if ($name eq "math::hypot") {
            emit($cg, "strada_hypot(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::cbrt") {
            emit($cg, "strada_cbrt(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::isnan") {
            emit($cg, "strada_isnan(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::isinf") {
            emit($cg, "strada_isinf(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::isfinite") {
            emit($cg, "strada_isfinite(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::fmax") {
            emit($cg, "strada_fmax(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::fmin") {
            emit($cg, "strada_fmin(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::copysign") {
            emit($cg, "strada_copysign(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::remainder") {
            emit($cg, "strada_remainder(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::trunc") {
            emit($cg, "strada_trunc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::ldexp") {
            emit($cg, "strada_ldexp(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::frexp") {
            emit($cg, "strada_frexp(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::modf") {
            emit($cg, "strada_modf(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::scalbn") {
            emit($cg, "strada_scalbn(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # User-defined function - check for default parameters
        my str $c_name = sanitize_name($name);
        my scalar $func_info = $cg->{"functions"}->{$c_name};
        my scalar $args = $expr->{"args"};
        my int $arg_count = $expr->{"arg_count"};

        # Handle extern function calls - convert between StradaValue* and raw C types
        if ($func_info && $func_info->{"is_extern"} == 1) {
            my int $ret_type = $func_info->{"return_type"};
            my int $param_count = $func_info->{"param_count"};
            my scalar $params = $func_info->{"params"};
            my int $is_c_extern = $func_info->{"is_c_extern"};

            # Generate block for extern call with conversion
            emit($cg, "({ ");

            # Create temps for args and convert from StradaValue* to raw C types
            my int $t = 0;
            while ($t < $arg_count) {
                my int $param_type = TYPE_SCALAR();
                if ($t < $param_count) {
                    $param_type = $params->[$t]->{"param_type"};
                }
                emit($cg, "StradaValue *__sv_arg" . $t . " = ");
                gen_expression($cg, $args->[$t]);
                emit($cg, "; ");
                $t = $t + 1;
            }

            # Call the extern function with converted args
            if ($ret_type == TYPE_VOID()) {
                emit($cg, $c_name . "(");
            } elsif ($ret_type == TYPE_STR()) {
                emit($cg, "char *__ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_INT()) {
                emit($cg, "int __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_BOOL()) {
                emit($cg, "bool __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_NUM()) {
                emit($cg, "double __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_INT32()) {
                emit($cg, "int32_t __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_INT64()) {
                emit($cg, "int64_t __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_FLOAT32()) {
                emit($cg, "float __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_FLOAT64()) {
                emit($cg, "double __ext_ret = " . $c_name . "(");
            } else {
                emit($cg, "void *__ext_ret = " . $c_name . "(");
            }

            # Pass converted arguments
            my int $a = 0;
            while ($a < $arg_count) {
                if ($a > 0) {
                    emit($cg, ", ");
                }
                my int $param_type = TYPE_SCALAR();
                if ($a < $param_count) {
                    $param_type = $params->[$a]->{"param_type"};
                }

                # For c_extern, use direct conversions without allocation
                if ($is_c_extern == 1) {
                    if ($param_type == TYPE_STR()) {
                        # For c_extern, str is already a char* pointer stored as int
                        emit($cg, "(char*)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_INT() || $param_type == TYPE_BOOL()) {
                        emit($cg, "(int)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_INT32()) {
                        emit($cg, "(int32_t)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_INT64()) {
                        emit($cg, "strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_UINT8()) {
                        emit($cg, "(uint8_t)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_UINT16()) {
                        emit($cg, "(uint16_t)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_UINT32()) {
                        emit($cg, "(uint32_t)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_UINT64()) {
                        emit($cg, "(uint64_t)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_SIZE_T()) {
                        emit($cg, "(size_t)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_CHAR()) {
                        emit($cg, "(char)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_NUM() || $param_type == TYPE_FLOAT64()) {
                        emit($cg, "strada_to_num(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_FLOAT32()) {
                        emit($cg, "(float)strada_to_num(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_LONG_DOUBLE()) {
                        emit($cg, "(long double)strada_to_num(__sv_arg" . $a . ")");
                    } else {
                        emit($cg, "(void*)strada_to_int(__sv_arg" . $a . ")");
                    }
                } else {
                    # Traditional extern - uses strada_to_str which allocates
                    if ($param_type == TYPE_STR()) {
                        emit($cg, "strada_to_str(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_INT() || $param_type == TYPE_BOOL()) {
                        emit($cg, "(int)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_INT32()) {
                        emit($cg, "(int32_t)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_INT64()) {
                        emit($cg, "strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_NUM() || $param_type == TYPE_FLOAT64()) {
                        emit($cg, "strada_to_num(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_FLOAT32()) {
                        emit($cg, "(float)strada_to_num(__sv_arg" . $a . ")");
                    } else {
                        emit($cg, "strada_to_str(__sv_arg" . $a . ")");
                    }
                }
                $a = $a + 1;
            }
            emit($cg, "); ");

            # Decref the temp StradaValue args (skip for c_extern - no allocations)
            if ($is_c_extern == 0) {
                my int $d = 0;
                while ($d < $arg_count) {
                    if (needs_temp_cleanup($args->[$d]) == 1) {
                        emit($cg, "strada_decref(__sv_arg" . $d . "); ");
                    }
                    $d = $d + 1;
                }
            }

            # Convert return value back to StradaValue*
            if ($ret_type == TYPE_VOID()) {
                emit($cg, "strada_new_undef(); })");
            } elsif ($ret_type == TYPE_STR()) {
                if ($is_c_extern == 1) {
                    # For c_extern, store the char* as an int64
                    emit($cg, "strada_new_int((int64_t)__ext_ret); })");
                } else {
                    emit($cg, "strada_new_str(__ext_ret); })");
                }
            } elsif ($ret_type == TYPE_INT() || $ret_type == TYPE_BOOL() || $ret_type == TYPE_INT32() || $ret_type == TYPE_INT64()) {
                emit($cg, "strada_new_int(__ext_ret); })");
            } elsif ($ret_type == TYPE_UINT8() || $ret_type == TYPE_UINT16() || $ret_type == TYPE_UINT32() || $ret_type == TYPE_UINT64() || $ret_type == TYPE_SIZE_T() || $ret_type == TYPE_CHAR()) {
                emit($cg, "strada_new_int(__ext_ret); })");
            } elsif ($ret_type == TYPE_NUM() || $ret_type == TYPE_FLOAT32() || $ret_type == TYPE_FLOAT64() || $ret_type == TYPE_LONG_DOUBLE()) {
                emit($cg, "strada_new_num(__ext_ret); })");
            } else {
                emit($cg, "strada_new_undef(); })");
            }
            return;
        }

        # Check if this is a variadic function call or if any arg has spread
        my int $is_variadic_call = 0;
        my int $variadic_param_idx = -1;
        my int $has_spread = 0;

        # Check for spread in arguments
        for (my int $sa = 0; $sa < $arg_count; $sa = $sa + 1) {
            if ($args->[$sa]->{"type"} == NODE_SPREAD()) {
                $has_spread = 1;
            }
        }

        # Check if function is variadic
        if ($func_info) {
            if ($func_info->{"is_variadic"} == 1) {
                $is_variadic_call = 1;
                $variadic_param_idx = $func_info->{"variadic_param_idx"};
            }
        }

        # Variadic call: pack args into array at call site
        if ($is_variadic_call == 1 || $has_spread == 1) {
            # For variadic functions, variadic_param_idx tells us where to start packing
            # For non-variadic functions with spread, pack ALL args and let runtime sort it out
            if ($variadic_param_idx < 0) {
                $variadic_param_idx = 0;  # Pack all args if no variadic info
            }

            # Check if function returns void
            my int $returns_void = 0;
            if ($func_info) {
                my int $ret_type = $func_info->{"return_type"};
                if ($ret_type == TYPE_VOID()) {
                    $returns_void = 1;
                }
            }

            emit($cg, "({ ");
            emit($cg, "StradaValue *__va_arr = strada_new_array(); ");

            # Pack args starting from variadic position
            my int $a = $variadic_param_idx;
            while ($a < $arg_count) {
                my scalar $arg = $args->[$a];
                if ($arg->{"type"} == NODE_SPREAD()) {
                    # Spread: iterate array and push elements
                    # Incref first to keep element alive, then use push_take to transfer ownership to variadic array
                    emit($cg, "{ StradaValue *__spread = ");
                    gen_expression($cg, $arg->{"target"});
                    emit($cg, "; StradaArray *__sa = strada_deref_array(__spread); ");
                    emit($cg, "if (__sa) { for (size_t __si = 0; __si < __sa->size; __si++) { ");
                    emit($cg, "strada_incref(__sa->elements[__si]); ");
                    emit($cg, "strada_array_push_take(strada_deref_array(__va_arr), __sa->elements[__si]); ");
                    emit($cg, "} } } ");
                } else {
                    # Regular arg: push to array using push_take since we're creating new values
                    emit($cg, "strada_array_push_take(strada_deref_array(__va_arr), ");
                    gen_expression($cg, $arg);
                    emit($cg, "); ");
                }
                $a = $a + 1;
            }

            # Emit the function call with fixed args + variadic array
            if ($returns_void == 0) {
                emit($cg, "StradaValue *__va_result = ");
            }
            emit($cg, $c_name . "(");

            # Emit fixed args (before variadic position)
            for (my int $f = 0; $f < $variadic_param_idx; $f = $f + 1) {
                if ($f > 0) {
                    emit($cg, ", ");
                }
                if ($f < $arg_count) {
                    gen_expression($cg, $args->[$f]);
                } else {
                    # Missing arg - use default or undef
                    if ($func_info) {
                        my scalar $params = $func_info->{"params"};
                        my scalar $param = $params->[$f];
                        if ($param->{"has_default"} == 1) {
                            gen_expression($cg, $param->{"default"});
                        } else {
                            emit($cg, "strada_new_undef()");
                        }
                    } else {
                        emit($cg, "strada_new_undef()");
                    }
                }
            }

            # Emit variadic array as last param
            if ($variadic_param_idx > 0) {
                emit($cg, ", ");
            }
            emit($cg, "__va_arr); strada_decref(__va_arr); ");

            # Return result
            if ($returns_void == 0) {
                emit($cg, "__va_result; })");
            } else {
                emit($cg, "})");
            }
            return;
        }

        # Check if any arguments need temp cleanup (anonymous values)
        my int $needs_temps = 0;
        my int $check_i = 0;
        while ($check_i < $arg_count) {
            if (needs_temp_cleanup($args->[$check_i]) == 1) {
                $needs_temps = 1;
            }
            $check_i = $check_i + 1;
        }

        if ($needs_temps == 1) {
            # Check if function returns void
            # Default to non-void when we don't have func_info (safer - allows use in expression context)
            my int $returns_void = 0;
            if ($func_info) {
                my int $ret_type = $func_info->{"return_type"};
                if ($ret_type == TYPE_VOID()) {
                    $returns_void = 1;
                }
            }

            # Generate block with temp variables for cleanup
            emit($cg, "({ ");
            # Declare temps for args that need cleanup
            my int $t = 0;
            while ($t < $arg_count) {
                if (needs_temp_cleanup($args->[$t]) == 1) {
                    emit($cg, "StradaValue *__arg" . $t . " = ");
                    gen_expression($cg, $args->[$t]);
                    emit($cg, "; ");
                }
                $t = $t + 1;
            }
            # Emit the function call, storing result if not void
            if ($returns_void == 0) {
                emit($cg, "StradaValue *__call_result = ");
            }
            emit($cg, $c_name . "(");
            if ($func_info) {
                my int $param_count = $func_info->{"param_count"};
                my scalar $params = $func_info->{"params"};
                my int $i = 0;
                while ($i < $param_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    if ($i < $arg_count) {
                        if (needs_temp_cleanup($args->[$i]) == 1) {
                            emit($cg, "__arg" . $i);
                        } else {
                            gen_expression($cg, $args->[$i]);
                        }
                    } else {
                        my scalar $param = $params->[$i];
                        if ($param->{"has_default"} == 1) {
                            gen_expression($cg, $param->{"default"});
                        } else {
                            emit($cg, "strada_new_undef()");
                        }
                    }
                    $i = $i + 1;
                }
            } else {
                my int $i = 0;
                while ($i < $arg_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    if (needs_temp_cleanup($args->[$i]) == 1) {
                        emit($cg, "__arg" . $i);
                    } else {
                        gen_expression($cg, $args->[$i]);
                    }
                    $i = $i + 1;
                }
            }
            emit($cg, "); ");
            # Decref temps
            my int $d = 0;
            while ($d < $arg_count) {
                if (needs_temp_cleanup($args->[$d]) == 1) {
                    emit($cg, "strada_decref(__arg" . $d . "); ");
                }
                $d = $d + 1;
            }
            # Return result if not void
            if ($returns_void == 0) {
                emit($cg, "__call_result; })");
            } else {
                emit($cg, "})");
            }
        } else {
            # No temps needed, simple call
            emit($cg, $c_name . "(");
            if ($func_info) {
                my int $param_count = $func_info->{"param_count"};
                my scalar $params = $func_info->{"params"};
                my int $i = 0;
                while ($i < $param_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    if ($i < $arg_count) {
                        gen_expression($cg, $args->[$i]);
                    } else {
                        my scalar $param = $params->[$i];
                        if ($param->{"has_default"} == 1) {
                            gen_expression($cg, $param->{"default"});
                        } else {
                            emit($cg, "strada_new_undef()");
                        }
                    }
                    $i = $i + 1;
                }
            } else {
                my int $i = 0;
                while ($i < $arg_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    gen_expression($cg, $args->[$i]);
                    $i = $i + 1;
                }
            }
            emit($cg, ")");
        }
        return;
    }
    
    # Assignment
    if ($type == NODE_ASSIGN()) {
        my str $op = $expr->{"op"};
        my scalar $target = $expr->{"target"};
        my int $target_type = $target->{"type"};
        
        if ($op eq "=") {
            # Special case: hash assignment %hash{key} = value
            # strada_hash_set handles incref internally for shared ownership
            # For anonymous values, we need to decref after hash_set takes ownership
            if ($target_type == NODE_HASH_ACCESS()) {
                my scalar $val = $expr->{"value"};
                my int $val_type = $val->{"type"};
                # Check if value is anonymous (needs decref after storing)
                my int $is_anonymous = 0;
                if ($val_type == NODE_ANON_ARRAY() || $val_type == NODE_ANON_HASH() ||
                    $val_type == NODE_INT_LITERAL() || $val_type == NODE_NUM_LITERAL() ||
                    $val_type == NODE_STR_LITERAL() || $val_type == NODE_CALL() ||
                    $val_type == NODE_REF() || $val_type == NODE_METHOD_CALL() ||
                    $val_type == NODE_BINARY_OP() || $val_type == NODE_UNARY_OP() ||
                    $val_type == NODE_TERNARY()) {
                    $is_anonymous = 1;
                }
                my scalar $key_expr = $target->{"key"};
                my int $key_is_literal = $key_expr->{"type"} == NODE_STR_LITERAL();
                if ($is_anonymous == 1) {
                    # Anonymous value: store in temp, hash_set takes shared ownership, then release our copy
                    emit($cg, "({ StradaValue *__hset_v = ");
                    # Handle empty () which parser returns as anon_hash
                    if ($val_type == NODE_ANON_HASH() && $val->{"pair_count"} == 0) {
                        emit($cg, "strada_new_hash()");
                    } else {
                        gen_expression($cg, $val);
                    }
                    emit($cg, "; ");
                    if ($key_is_literal == 1) {
                        # Literal key - use directly without allocation
                        emit($cg, "strada_hash_set(strada_deref_hash(");
                        gen_expression($cg, $target->{"hash"});
                        emit($cg, "), ");
                        gen_str_literal_c($cg, $key_expr->{"value"});
                        emit($cg, ", __hset_v); strada_decref(__hset_v); })");
                    } else {
                        # Expression key - save to temp, get string, cleanup both
                        my int $key_needs_cleanup = needs_temp_cleanup($key_expr);
                        emit($cg, "StradaValue *__hset_k = ");
                        gen_expression($cg, $key_expr);
                        emit($cg, "; char *__hset_ks = strada_to_str(__hset_k); ");
                        emit($cg, "strada_hash_set(strada_deref_hash(");
                        gen_expression($cg, $target->{"hash"});
                        emit($cg, "), __hset_ks, __hset_v); ");
                        emit($cg, "free(__hset_ks); ");
                        if ($key_needs_cleanup == 1) {
                            emit($cg, "strada_decref(__hset_k); ");
                        }
                        emit($cg, "strada_decref(__hset_v); })");
                    }
                } else {
                    # Borrowed value: just pass to hash_set which handles incref
                    if ($key_is_literal == 1) {
                        # Literal key - use directly without allocation
                        emit($cg, "strada_hash_set(strada_deref_hash(");
                        gen_expression($cg, $target->{"hash"});
                        emit($cg, "), ");
                        gen_str_literal_c($cg, $key_expr->{"value"});
                        emit($cg, ", ");
                        gen_expression($cg, $val);
                        emit($cg, ")");
                    } else {
                        # Expression key - save to temp, get string, cleanup both
                        my int $key_needs_cleanup = needs_temp_cleanup($key_expr);
                        emit($cg, "({ StradaValue *__hset_k = ");
                        gen_expression($cg, $key_expr);
                        emit($cg, "; char *__hset_ks = strada_to_str(__hset_k); ");
                        emit($cg, "strada_hash_set(strada_deref_hash(");
                        gen_expression($cg, $target->{"hash"});
                        emit($cg, "), __hset_ks, ");
                        gen_expression($cg, $val);
                        emit($cg, "); free(__hset_ks); ");
                        if ($key_needs_cleanup == 1) {
                            emit($cg, "strada_decref(__hset_k); ");
                        }
                        emit($cg, "})");
                    }
                }
                return;
            }
            # Special case: hash deref assignment $ref->{key} = value
            # strada_hash_set handles incref internally for shared ownership
            # For anonymous values, we need to decref after hash_set takes ownership
            if ($target_type == NODE_DEREF_HASH()) {
                my scalar $val = $expr->{"value"};
                my int $val_type = $val->{"type"};
                # Check if value is anonymous (needs decref after storing)
                my int $is_anonymous = 0;
                if ($val_type == NODE_ANON_ARRAY() || $val_type == NODE_ANON_HASH() ||
                    $val_type == NODE_INT_LITERAL() || $val_type == NODE_NUM_LITERAL() ||
                    $val_type == NODE_STR_LITERAL() || $val_type == NODE_CALL() ||
                    $val_type == NODE_REF() || $val_type == NODE_METHOD_CALL() ||
                    $val_type == NODE_BINARY_OP() || $val_type == NODE_UNARY_OP() ||
                    $val_type == NODE_TERNARY()) {
                    $is_anonymous = 1;
                }
                my scalar $key_expr = $target->{"key"};
                my int $key_is_literal = $key_expr->{"type"} == NODE_STR_LITERAL();
                if ($is_anonymous == 1) {
                    # Anonymous value: store in temp, hash_set takes shared ownership, then release our copy
                    emit($cg, "({ StradaValue *__hset_v = ");
                    gen_expression($cg, $val);
                    emit($cg, "; ");
                    if ($key_is_literal == 1) {
                        # Literal key - use directly without allocation
                        emit($cg, "strada_hash_set(strada_deref_hash(");
                        gen_expression($cg, $target->{"ref"});
                        emit($cg, "), ");
                        gen_str_literal_c($cg, $key_expr->{"value"});
                        emit($cg, ", __hset_v); strada_decref(__hset_v); })");
                    } else {
                        # Expression key - save to temp, get string, cleanup both
                        my int $key_needs_cleanup = needs_temp_cleanup($key_expr);
                        emit($cg, "StradaValue *__hset_k = ");
                        gen_expression($cg, $key_expr);
                        emit($cg, "; char *__hset_ks = strada_to_str(__hset_k); ");
                        emit($cg, "strada_hash_set(strada_deref_hash(");
                        gen_expression($cg, $target->{"ref"});
                        emit($cg, "), __hset_ks, __hset_v); ");
                        emit($cg, "free(__hset_ks); ");
                        if ($key_needs_cleanup == 1) {
                            emit($cg, "strada_decref(__hset_k); ");
                        }
                        emit($cg, "strada_decref(__hset_v); })");
                    }
                } else {
                    # Borrowed value: just pass to hash_set which handles incref
                    if ($key_is_literal == 1) {
                        # Literal key - use directly without allocation
                        emit($cg, "strada_hash_set(strada_deref_hash(");
                        gen_expression($cg, $target->{"ref"});
                        emit($cg, "), ");
                        gen_str_literal_c($cg, $key_expr->{"value"});
                        emit($cg, ", ");
                        gen_expression($cg, $val);
                        emit($cg, ")");
                    } else {
                        # Expression key - save to temp, get string, cleanup both
                        my int $key_needs_cleanup = needs_temp_cleanup($key_expr);
                        emit($cg, "({ StradaValue *__hset_k = ");
                        gen_expression($cg, $key_expr);
                        emit($cg, "; char *__hset_ks = strada_to_str(__hset_k); ");
                        emit($cg, "strada_hash_set(strada_deref_hash(");
                        gen_expression($cg, $target->{"ref"});
                        emit($cg, "), __hset_ks, ");
                        gen_expression($cg, $val);
                        emit($cg, "); free(__hset_ks); ");
                        if ($key_needs_cleanup == 1) {
                            emit($cg, "strada_decref(__hset_k); ");
                        }
                        emit($cg, "})");
                    }
                }
                return;
            }
            # Special case: array subscript assignment @arr[idx] = value
            if ($target_type == NODE_SUBSCRIPT()) {
                emit($cg, "strada_array_set(strada_deref_array(");
                gen_expression($cg, $target->{"array"});
                emit($cg, "), strada_to_int(");
                gen_expression($cg, $target->{"index"});
                emit($cg, "), ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")");
                return;
            }
            # Special case: array deref assignment $ref->[idx] = value
            if ($target_type == NODE_DEREF_ARRAY()) {
                emit($cg, "strada_array_set(strada_deref_array(");
                gen_expression($cg, $target->{"ref"});
                emit($cg, "), strada_to_int(");
                gen_expression($cg, $target->{"index"});
                emit($cg, "), ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")");
                return;
            }
            # Special case: scalar deref assignment $$ref = value
            if ($target_type == NODE_DEREF_SCALAR()) {
                emit($cg, "strada_deref_set(");
                gen_expression($cg, $target->{"ref"});
                emit($cg, ", ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")");
                return;
            }
            # Special case: assigning scalar to array variable @arr = ($x)
            if ($target_type == NODE_VARIABLE() && $target->{"sigil"} eq "@") {
                my scalar $val = $expr->{"value"};
                my int $val_type = $val->{"type"};
                if ($val_type == NODE_READLINE()) {
                    # Diamond operator in array context - read all lines
                    my str $varname = $val->{"varname"};
                    gen_expression($cg, $target);
                    emit($cg, " = strada_read_all_lines(" . escape_c_keyword($varname) . ")");
                } elsif ($val_type == NODE_ANON_HASH() && $val->{"pair_count"} == 0) {
                    # Empty () - clear and reset array
                    gen_expression($cg, $target);
                    emit($cg, " = strada_new_array()");
                } elsif ($val_type == NODE_ANON_ARRAY()) {
                    # Array literal [1, 2, 3] - assign directly
                    gen_expression($cg, $target);
                    emit($cg, " = ");
                    gen_expression($cg, $val);
                } elsif (is_scalar_expr($val)) {
                    # Single scalar - wrap in array
                    gen_expression($cg, $target);
                    emit($cg, " = strada_new_array(); strada_array_push(");
                    gen_expression($cg, $target);
                    emit($cg, "->value.av, ");
                    gen_expression($cg, $val);
                    emit($cg, ")");
                } else {
                    # Assume value returns an array
                    gen_expression($cg, $target);
                    emit($cg, " = ");
                    gen_expression($cg, $val);
                }
                return;
            }
            # Normal assignment with reference counting
            # Runtime returns owned references, so we just decref the old value
            # For variable-to-variable copy and borrowed references (hash/array access),
            # we need to incref since we're sharing the reference
            my scalar $rhs = $expr->{"value"};
            my int $rhs_type = $rhs->{"type"};
            my int $needs_incref = 0;
            # Variable assignment shares reference
            if ($rhs_type == NODE_VARIABLE()) {
                $needs_incref = 1;
            }
            # Hash/array access returns borrowed reference - must incref to own it
            if ($rhs_type == NODE_HASH_ACCESS() || $rhs_type == NODE_SUBSCRIPT() ||
                $rhs_type == NODE_DEREF_HASH() || $rhs_type == NODE_DEREF_ARRAY()) {
                $needs_incref = 1;
            }
            # Ternary and other complex expressions - use return_needs_incref() for proper analysis
            if ($rhs_type == NODE_TERNARY()) {
                $needs_incref = return_needs_incref($rhs);
            }
            if ($target_type == NODE_VARIABLE() && $cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__old = ");
                gen_expression($cg, $target);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = ");
                gen_expression($cg, $rhs);
                emit($cg, "; ");
                # Incref for shared references (variables, hash/array access)
                if ($needs_incref == 1) {
                    emit($cg, "strada_incref(");
                    gen_expression($cg, $target);
                    emit($cg, "); ");
                }
                emit($cg, "strada_decref(__old); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = ");
                gen_expression($cg, $rhs);
            }
        } elsif ($op eq "+=") {
            if ($target_type == NODE_VARIABLE() && $cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__old = ");
                gen_expression($cg, $target);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(__old) + strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")); strada_decref(__old); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(");
                gen_expression($cg, $target);
                emit($cg, ") + strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, "))");
            }
        } elsif ($op eq "-=") {
            if ($target_type == NODE_VARIABLE() && $cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__old = ");
                gen_expression($cg, $target);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(__old) - strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")); strada_decref(__old); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(");
                gen_expression($cg, $target);
                emit($cg, ") - strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, "))");
            }
        } elsif ($op eq ".=") {
            if ($target_type == NODE_VARIABLE() && $cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__old = ");
                gen_expression($cg, $target);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = strada_concat_sv(__old, ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, "); strada_decref(__old); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = strada_concat_sv(");
                gen_expression($cg, $target);
                emit($cg, ", ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")");
            }
        }
        return;
    }
    
    # Array subscript - use strada_deref_array to handle both direct arrays and refs
    if ($type == NODE_SUBSCRIPT()) {
        emit($cg, "strada_array_get(strada_deref_array(");
        gen_expression($cg, $expr->{"array"});
        emit($cg, "), strada_to_int(");
        gen_expression($cg, $expr->{"index"});
        emit($cg, "))");
        return;
    }
    
    # Hash access - use strada_deref_hash to handle both direct hashes and refs
    if ($type == NODE_HASH_ACCESS()) {
        my scalar $key_expr = $expr->{"key"};
        my int $key_is_literal = $key_expr->{"type"} == NODE_STR_LITERAL();
        if ($key_is_literal == 1) {
            # Literal key - use directly without allocation
            emit($cg, "strada_hash_get(strada_deref_hash(");
            gen_expression($cg, $expr->{"hash"});
            emit($cg, "), ");
            gen_str_literal_c($cg, $key_expr->{"value"});
            emit($cg, ")");
        } else {
            # Expression key - wrap in statement expression for cleanup
            my int $key_needs_cleanup = needs_temp_cleanup($key_expr);
            emit($cg, "({ StradaValue *__hget_k = ");
            gen_expression($cg, $key_expr);
            emit($cg, "; char *__hget_ks = strada_to_str(__hget_k); ");
            emit($cg, "StradaValue *__hget_r = strada_hash_get(strada_deref_hash(");
            gen_expression($cg, $expr->{"hash"});
            emit($cg, "), __hget_ks); ");
            emit($cg, "free(__hget_ks); ");
            if ($key_needs_cleanup == 1) {
                emit($cg, "strada_decref(__hget_k); ");
            }
            emit($cg, "__hget_r; })");
        }
        return;
    }

    # Reference
    if ($type == NODE_REF()) {
        my str $ref_type = $expr->{"ref_type"};
        if ($ref_type eq "&") {
            # Function reference - use strada_cpointer_new
            emit($cg, "strada_cpointer_new((void*)");
            gen_expression($cg, $expr->{"target"});
            emit($cg, ")");
        } else {
            emit($cg, "strada_new_ref(");
            gen_expression($cg, $expr->{"target"});
            emit($cg, ", '");
            emit($cg, $ref_type);
            emit($cg, "')");
        }
        return;
    }
    
    # Hash dereference
    if ($type == NODE_DEREF_HASH()) {
        my scalar $key_expr = $expr->{"key"};
        my int $key_is_literal = $key_expr->{"type"} == NODE_STR_LITERAL();
        if ($key_is_literal == 1) {
            # Literal key - use directly without allocation
            emit($cg, "strada_hash_get(strada_deref_hash(");
            gen_expression($cg, $expr->{"ref"});
            emit($cg, "), ");
            gen_str_literal_c($cg, $key_expr->{"value"});
            emit($cg, ")");
        } else {
            # Expression key - wrap in statement expression for cleanup
            my int $key_needs_cleanup = needs_temp_cleanup($key_expr);
            emit($cg, "({ StradaValue *__hget_k = ");
            gen_expression($cg, $key_expr);
            emit($cg, "; char *__hget_ks = strada_to_str(__hget_k); ");
            emit($cg, "StradaValue *__hget_r = strada_hash_get(strada_deref_hash(");
            gen_expression($cg, $expr->{"ref"});
            emit($cg, "), __hget_ks); ");
            emit($cg, "free(__hget_ks); ");
            if ($key_needs_cleanup == 1) {
                emit($cg, "strada_decref(__hget_k); ");
            }
            emit($cg, "__hget_r; })");
        }
        return;
    }

    # Array dereference
    if ($type == NODE_DEREF_ARRAY()) {
        emit($cg, "strada_array_get(strada_deref_array(");
        gen_expression($cg, $expr->{"ref"});
        emit($cg, "), strada_to_int(");
        gen_expression($cg, $expr->{"index"});
        emit($cg, "))");
        return;
    }
    
    # Scalar/Array/Hash dereference (@{}, %{}, $$)
    if ($type == NODE_DEREF_SCALAR()) {
        my str $sigil = $expr->{"sigil"};
        if ($sigil eq "@") {
            emit($cg, "strada_deref_array_value(");
        } elsif ($sigil eq "%") {
            emit($cg, "strada_deref_hash_value(");
        } else {
            emit($cg, "strada_deref(");
        }
        gen_expression($cg, $expr->{"ref"});
        emit($cg, ")");
        return;
    }
    
    # Field access (obj->field)
    if ($type == NODE_FIELD_ACCESS()) {
        gen_expression($cg, $expr->{"object"});
        emit($cg, "->" . $expr->{"field"});
        return;
    }
    
    # Function reference (&func_name)
    if ($type == NODE_FUNC_REF()) {
        emit($cg, "&" . $expr->{"name"});
        return;
    }
    
    # Method call ($obj->method(args)) - Perl-style blessed reference method dispatch
    # OR struct function pointer call ($struct->funcptr(args))
    if ($type == NODE_METHOD_CALL()) {
        my int $arg_count = $expr->{"arg_count"};
        my str $method = $expr->{"method"};
        my scalar $obj = $expr->{"object"};

        # Check if this is a struct function pointer call
        # The object will be a FIELD_ACCESS node (e.g., $calc->operation)
        # whose object is a VAR_REF to a struct variable
        my int $is_funcptr_call = 0;
        my int $funcptr_return_type = -1;  # -1 = unknown, TYPE_VOID() = void
        if ($obj->{"type"} == NODE_FIELD_ACCESS()) {
            my scalar $struct_obj = $obj->{"object"};
            if ($struct_obj->{"type"} == NODE_VARIABLE()) {
                my str $var_name = $struct_obj->{"name"};
                my scalar $struct_vars = $cg->{"struct_vars"};
                if ($struct_vars->{$var_name}) {
                    my str $struct_type = $struct_vars->{$var_name};
                    my scalar $struct_defs = $cg->{"struct_defs"};
                    if ($struct_defs->{$struct_type}) {
                        my scalar $struct_info = $struct_defs->{$struct_type};
                        my scalar $field_info = $struct_info->{"fields"}->{$method};
                        if ($field_info && $field_info->{"is_funcptr"}) {
                            $is_funcptr_call = 1;
                            $funcptr_return_type = $field_info->{"funcptr_return"};
                        }
                    }
                }
            }
        }

        if ($is_funcptr_call) {
            # Generate direct function pointer call with proper cast
            # Use correct return type based on funcptr_return_type
            my int $is_void_return = $funcptr_return_type == TYPE_VOID();
            my scalar $args = $expr->{"args"};

            # Check if any arguments need cleanup (produce temp values)
            my int $needs_arg_cleanup = 0;
            if ($cg->{"cleanup_enabled"} == 1 && $arg_count > 0) {
                for (my int $ca = 0; $ca < $arg_count; $ca = $ca + 1) {
                    if (needs_temp_cleanup($args->[$ca]) == 1) {
                        $needs_arg_cleanup = 1;
                    }
                }
            }

            if ($needs_arg_cleanup == 1) {
                # Wrap in statement expression to capture and cleanup args
                emit($cg, "({ ");

                # Capture each argument
                for (my int $ca = 0; $ca < $arg_count; $ca = $ca + 1) {
                    emit($cg, "StradaValue *__fpa" . $ca . " = ");
                    gen_expression($cg, $args->[$ca]);
                    emit($cg, "; ");
                }

                # Generate the call
                if ($is_void_return) {
                    emit($cg, "((void(*)(");
                } else {
                    emit($cg, "StradaValue *__fpret = ((StradaValue*(*)(");
                }
                if ($arg_count == 0) {
                    emit($cg, "void");
                } else {
                    my int $p = 0;
                    while ($p < $arg_count) {
                        if ($p > 0) {
                            emit($cg, ", ");
                        }
                        emit($cg, "StradaValue*");
                        $p = $p + 1;
                    }
                }
                emit($cg, "))");
                gen_expression($cg, $obj);
                emit($cg, ")(");
                for (my int $pa = 0; $pa < $arg_count; $pa = $pa + 1) {
                    if ($pa > 0) {
                        emit($cg, ", ");
                    }
                    emit($cg, "__fpa" . $pa);
                }
                emit($cg, "); ");

                # Cleanup captured arguments
                for (my int $da = 0; $da < $arg_count; $da = $da + 1) {
                    emit($cg, "strada_decref(__fpa" . $da . "); ");
                }

                # Return result (for non-void returns)
                if ($is_void_return) {
                    emit($cg, "})");
                } else {
                    emit($cg, "__fpret; })");
                }
            } else {
                # No argument cleanup needed - simple call
                if ($is_void_return) {
                    emit($cg, "((void(*)(");
                } else {
                    emit($cg, "((StradaValue*(*)(");
                }
                if ($arg_count == 0) {
                    emit($cg, "void");
                } else {
                    my int $p = 0;
                    while ($p < $arg_count) {
                        if ($p > 0) {
                            emit($cg, ", ");
                        }
                        emit($cg, "StradaValue*");
                        $p = $p + 1;
                    }
                }
                emit($cg, "))");
                gen_expression($cg, $obj);
                emit($cg, ")(");
                my int $i = 0;
                while ($i < $arg_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    gen_expression($cg, $args->[$i]);
                    $i = $i + 1;
                }
                emit($cg, ")");
            }
        } else {
            # OOP method call - use base_object (the original object, not field access)
            # Generate: strada_method_call(obj, "method", strada_pack_args(count, arg1, arg2, ...))

            my scalar $args = $expr->{"args"};

            # Check if any argument has spread operator
            my int $has_spread = 0;
            for (my int $sa = 0; $sa < $arg_count; $sa = $sa + 1) {
                if ($args->[$sa]->{"type"} == NODE_SPREAD()) {
                    $has_spread = 1;
                }
            }

            if ($has_spread == 1) {
                # Build args array dynamically with spread support
                emit($cg, "({ StradaValue *__method_args = strada_new_array(); ");

                my int $a = 0;
                while ($a < $arg_count) {
                    my scalar $arg = $args->[$a];
                    if ($arg->{"type"} == NODE_SPREAD()) {
                        # Spread: iterate array and push elements
                        emit($cg, "{ StradaValue *__spread = ");
                        gen_expression($cg, $arg->{"target"});
                        emit($cg, "; StradaArray *__sa = strada_deref_array(__spread); ");
                        emit($cg, "if (__sa) { for (size_t __si = 0; __si < __sa->size; __si++) { ");
                        emit($cg, "strada_array_push(strada_deref_array(__method_args), __sa->elements[__si]); ");
                        emit($cg, "strada_incref(__sa->elements[__si]); } } } ");
                    } else {
                        # Regular arg: push to array
                        emit($cg, "strada_array_push(strada_deref_array(__method_args), ");
                        gen_expression($cg, $arg);
                        emit($cg, "); ");
                    }
                    $a = $a + 1;
                }

                emit($cg, "strada_method_call(");
                my scalar $base_obj = $expr->{"base_object"};
                if ($base_obj) {
                    gen_expression($cg, $base_obj);
                } else {
                    gen_expression($cg, $obj);
                }
                emit($cg, ", \"" . $method . "\", __method_args); })");
            } else {
                # No spread - use regular strada_pack_args
                # Check if any args need temp cleanup
                my int $needs_arg_cleanup = 0;
                if ($cg->{"cleanup_enabled"} == 1) {
                    my int $c = 0;
                    while ($c < $arg_count) {
                        if (needs_temp_cleanup($args->[$c]) == 1) {
                            $needs_arg_cleanup = 1;
                        }
                        $c = $c + 1;
                    }
                }

                if ($needs_arg_cleanup == 1) {
                    # Capture temp args, call method, decref temps
                    emit($cg, "({ ");
                    my int $a = 0;
                    while ($a < $arg_count) {
                        if (needs_temp_cleanup($args->[$a]) == 1) {
                            emit($cg, "StradaValue *__meth_arg_" . $a . " = ");
                            gen_expression($cg, $args->[$a]);
                            emit($cg, "; ");
                        }
                        $a = $a + 1;
                    }
                    emit($cg, "StradaValue *__meth_res = strada_method_call(");
                    my scalar $base_obj = $expr->{"base_object"};
                    if ($base_obj) {
                        gen_expression($cg, $base_obj);
                    } else {
                        gen_expression($cg, $obj);
                    }
                    emit($cg, ", \"" . $method . "\", strada_pack_args(" . $arg_count);
                    my int $i = 0;
                    while ($i < $arg_count) {
                        emit($cg, ", ");
                        if (needs_temp_cleanup($args->[$i]) == 1) {
                            emit($cg, "__meth_arg_" . $i);
                        } else {
                            gen_expression($cg, $args->[$i]);
                        }
                        $i = $i + 1;
                    }
                    emit($cg, ")); ");
                    my int $d = 0;
                    while ($d < $arg_count) {
                        if (needs_temp_cleanup($args->[$d]) == 1) {
                            emit($cg, "strada_decref(__meth_arg_" . $d . "); ");
                        }
                        $d = $d + 1;
                    }
                    emit($cg, "__meth_res; })");
                } else {
                    # No temp cleanup needed - simple case
                    emit($cg, "strada_method_call(");
                    my scalar $base_obj = $expr->{"base_object"};
                    if ($base_obj) {
                        gen_expression($cg, $base_obj);
                    } else {
                        gen_expression($cg, $obj);
                    }
                    emit($cg, ", \"" . $method . "\", strada_pack_args(" . $arg_count);
                    my int $i = 0;
                    while ($i < $arg_count) {
                        emit($cg, ", ");
                        gen_expression($cg, $args->[$i]);
                        $i = $i + 1;
                    }
                    emit($cg, "))");
                }
            }
        }
        return;
    }

    # SUPER::method($self, args...) - calls parent method
    if ($type == NODE_SUPER_CALL()) {
        my int $arg_count = $expr->{"arg_count"};
        my str $method = $expr->{"method"};
        my scalar $args = $expr->{"args"};

        # SUPER::method requires at least one argument (the object/self)
        if ($arg_count < 1) {
            emit($cg, "strada_new_undef() /* SUPER call requires self argument */");
            return;
        }

        # Generate: strada_super_call(self, __PACKAGE__, "method", strada_pack_args(remaining...))
        emit($cg, "strada_super_call(");

        # First argument is self/object
        gen_expression($cg, $args->[0]);

        # Use compile-time package for SUPER resolution (not runtime strada_current_package())
        my str $fn_pkg = $cg->{"current_fn_package"};
        emit($cg, ", \"" . $fn_pkg . "\", \"" . $method . "\", strada_pack_args(");

        # Remaining arguments (skip first which is $self)
        my int $remaining = $arg_count - 1;
        emit($cg, "" . $remaining);

        my int $i = 1;
        while ($i < $arg_count) {
            emit($cg, ", ");
            gen_expression($cg, $args->[$i]);
            $i = $i + 1;
        }
        emit($cg, "))");
        return;
    }

    # __PACKAGE__ - returns current package name
    if ($type == NODE_DUNDER_PACKAGE()) {
        emit($cg, "strada_new_str(strada_current_package() ? strada_current_package() : \"\")");
        return;
    }

    # __FILE__ - returns current file name
    if ($type == NODE_DUNDER_FILE()) {
        my str $filename = $cg->{"filename"};
        emit($cg, "strada_new_str(\"" . $filename . "\")");
        return;
    }

    # __LINE__ - returns current line number
    if ($type == NODE_DUNDER_LINE()) {
        my int $line = $expr->{"line_value"};
        emit($cg, "strada_new_int(" . $line . ")");
        return;
    }

    # Anonymous hash
    if ($type == NODE_ANON_HASH()) {
        my scalar $keys = $expr->{"keys"};
        my scalar $values = $expr->{"values"};
        my scalar $key_exprs = $expr->{"key_exprs"};
        my int $pair_count = $expr->{"pair_count"};

        # Check if any keys are expressions (dynamic keys)
        my int $has_expr_keys = 0;
        my int $check_k = 0;
        while ($check_k < $pair_count) {
            if ($key_exprs && $key_exprs->[$check_k]) {
                $has_expr_keys = 1;
            }
            $check_k = $check_k + 1;
        }

        # Check if any values need temp cleanup (newly created values)
        my int $needs_val_cleanup = 0;
        my int $check_i = 0;
        while ($check_i < $pair_count) {
            if (needs_temp_cleanup($values->[$check_i]) == 1) {
                $needs_val_cleanup = 1;
            }
            $check_i = $check_i + 1;
        }

        if ($has_expr_keys == 1) {
            # Has expression keys - build hash manually
            emit($cg, "({ StradaValue *__ah_hash = strada_new_hash(); ");
            my int $e = 0;
            while ($e < $pair_count) {
                if ($key_exprs && $key_exprs->[$e]) {
                    # Expression key - use strada_to_str
                    emit($cg, "{ char *__ah_k" . $e . " = strada_to_str(");
                    gen_expression($cg, $key_exprs->[$e]);
                    emit($cg, "); strada_hash_set(__ah_hash->value.hv, __ah_k" . $e . ", ");
                    gen_expression($cg, $values->[$e]);
                    emit($cg, "); free(__ah_k" . $e . "); } ");
                } else {
                    # String key
                    emit($cg, "strada_hash_set(__ah_hash->value.hv, \"" . $keys->[$e] . "\", ");
                    gen_expression($cg, $values->[$e]);
                    emit($cg, "); ");
                }
                $e = $e + 1;
            }
            emit($cg, "__ah_hash; })");
        } elsif ($needs_val_cleanup == 1 && $cg->{"cleanup_enabled"} == 1) {
            # Generate block with temps for values that need cleanup
            emit($cg, "({ ");

            # Create temps for values that need cleanup
            my int $t = 0;
            while ($t < $pair_count) {
                if (needs_temp_cleanup($values->[$t]) == 1) {
                    emit($cg, "StradaValue *__ah_val" . $t . " = ");
                    gen_expression($cg, $values->[$t]);
                    emit($cg, "; ");
                }
                $t = $t + 1;
            }

            # Create the hash
            emit($cg, "StradaValue *__ah_hash = strada_anon_hash(" . $pair_count);
            my int $a = 0;
            while ($a < $pair_count) {
                emit($cg, ", \"" . $keys->[$a] . "\", ");
                if (needs_temp_cleanup($values->[$a]) == 1) {
                    emit($cg, "__ah_val" . $a);
                } else {
                    gen_expression($cg, $values->[$a]);
                }
                $a = $a + 1;
            }
            emit($cg, "); ");

            # Decref temps to balance the incref from strada_hash_set
            my int $d = 0;
            while ($d < $pair_count) {
                if (needs_temp_cleanup($values->[$d]) == 1) {
                    emit($cg, "strada_decref(__ah_val" . $d . "); ");
                }
                $d = $d + 1;
            }

            # Return the hash
            emit($cg, "__ah_hash; })");
        } else {
            # Simple generation - no cleanup needed
            emit($cg, "strada_anon_hash(" . $pair_count);
            my int $i = 0;
            while ($i < $pair_count) {
                emit($cg, ", \"" . $keys->[$i] . "\", ");
                gen_expression($cg, $values->[$i]);
                $i = $i + 1;
            }
            emit($cg, ")");
        }
        return;
    }
    
    # Anonymous array
    if ($type == NODE_ANON_ARRAY()) {
        my scalar $elems = $expr->{"elements"};
        my int $elem_count = $expr->{"element_count"};

        # Check if any elements need temp cleanup (newly created values)
        my int $needs_elem_cleanup = 0;
        my int $check_i = 0;
        while ($check_i < $elem_count) {
            if (needs_temp_cleanup($elems->[$check_i]) == 1) {
                $needs_elem_cleanup = 1;
            }
            $check_i = $check_i + 1;
        }

        if ($needs_elem_cleanup == 1 && $cg->{"cleanup_enabled"} == 1) {
            # Generate block with temps for elements that need cleanup
            # This ensures newly created values are decreffed after array creation
            # since strada_array_push increfs them (to handle existing variables)
            emit($cg, "({ ");

            # Create temps for elements that need cleanup
            my int $t = 0;
            while ($t < $elem_count) {
                if (needs_temp_cleanup($elems->[$t]) == 1) {
                    emit($cg, "StradaValue *__aa_el" . $t . " = ");
                    gen_expression($cg, $elems->[$t]);
                    emit($cg, "; ");
                }
                $t = $t + 1;
            }

            # Create the array
            emit($cg, "StradaValue *__aa_arr = strada_anon_array(" . $elem_count);
            my int $a = 0;
            while ($a < $elem_count) {
                emit($cg, ", ");
                if (needs_temp_cleanup($elems->[$a]) == 1) {
                    emit($cg, "__aa_el" . $a);
                } else {
                    gen_expression($cg, $elems->[$a]);
                }
                $a = $a + 1;
            }
            emit($cg, "); ");

            # Decref temps to balance the incref from strada_array_push
            my int $d = 0;
            while ($d < $elem_count) {
                if (needs_temp_cleanup($elems->[$d]) == 1) {
                    emit($cg, "strada_decref(__aa_el" . $d . "); ");
                }
                $d = $d + 1;
            }

            # Return the array
            emit($cg, "__aa_arr; })");
        } else {
            # Simple generation - no cleanup needed
            emit($cg, "strada_anon_array(" . $elem_count);
            my int $i = 0;
            while ($i < $elem_count) {
                emit($cg, ", ");
                gen_expression($cg, $elems->[$i]);
                $i = $i + 1;
            }
            emit($cg, ")");
        }
        return;
    }

    # Map expression: map { block } @array
    if ($type == NODE_MAP()) {
        my scalar $block = $expr->{"block"};
        my scalar $array_expr = $expr->{"array"};
        my int $map_id = $cg->{"map_counter"};
        $cg->{"map_counter"} = $map_id + 1;

        emit($cg, "({ ");
        emit($cg, "StradaArray *__map_input_" . $map_id . " = strada_deref_array(");
        gen_expression($cg, $array_expr);
        emit($cg, "); ");
        emit($cg, "StradaValue *__map_result_" . $map_id . " = strada_new_array(); ");
        emit($cg, "int __map_len_" . $map_id . " = strada_array_length(__map_input_" . $map_id . "); ");
        emit($cg, "for (int __map_i_" . $map_id . " = 0; __map_i_" . $map_id . " < __map_len_" . $map_id . "; __map_i_" . $map_id . "++) { ");
        emit($cg, "StradaValue *__elem_ = strada_array_get(__map_input_" . $map_id . ", __map_i_" . $map_id . "); ");

        # Set flag to enable $_ magic variable
        $cg->{"in_map_block"} = 1;

        # Generate block - the last statement's expression is the result
        my scalar $stmts = $block->{"statements"};
        my int $stmt_count = $block->{"statement_count"};
        if ($stmt_count > 0) {
            # Handle all but last statement normally
            my int $i = 0;
            while ($i < $stmt_count - 1) {
                gen_statement($cg, $stmts->[$i]);
                $i = $i + 1;
            }
            # Last statement - extract its expression for the result
            # Flatten arrays for map { $_ => 1 } idiom
            my scalar $last_stmt = $stmts->[$stmt_count - 1];
            if ($last_stmt->{"type"} == NODE_EXPR_STMT()) {
                emit($cg, "{ StradaValue *__map_elem_" . $map_id . " = ");
                gen_expression($cg, $last_stmt->{"expr"});
                emit($cg, "; ");
                # Handle both STRADA_ARRAY and STRADA_REF to array (from strada_anon_array)
                emit($cg, "StradaValue *__flat_val_" . $map_id . " = __map_elem_" . $map_id . "; ");
                emit($cg, "if (__flat_val_" . $map_id . " && __flat_val_" . $map_id . "->type == STRADA_REF) { ");
                emit($cg, "__flat_val_" . $map_id . " = __flat_val_" . $map_id . "->value.rv; } ");
                emit($cg, "if (__flat_val_" . $map_id . " && __flat_val_" . $map_id . "->type == STRADA_ARRAY) { ");
                emit($cg, "StradaArray *__flat_arr_" . $map_id . " = __flat_val_" . $map_id . "->value.av; ");
                emit($cg, "for (size_t __flat_j_" . $map_id . " = 0; __flat_j_" . $map_id . " < __flat_arr_" . $map_id . "->size; __flat_j_" . $map_id . "++) { ");
                emit($cg, "strada_array_push(__map_result_" . $map_id . "->value.av, __flat_arr_" . $map_id . "->elements[__flat_j_" . $map_id . "]); } ");
                emit($cg, "strada_decref(__map_elem_" . $map_id . "); ");
                emit($cg, "} else { ");
                emit($cg, "strada_array_push(__map_result_" . $map_id . "->value.av, __map_elem_" . $map_id . "); } } ");
            }
        }

        # Reset flag
        $cg->{"in_map_block"} = 0;

        emit($cg, "} ");
        emit($cg, "__map_result_" . $map_id . "; })");
        return;
    }

    # Sort expression: sort { $a <=> $b } @array
    if ($type == NODE_SORT()) {
        my scalar $block = $expr->{"block"};
        my scalar $array_expr = $expr->{"array"};

        # Default sort (no block)
        if (!$block) {
            emit($cg, "strada_sort(");
            gen_expression($cg, $array_expr);
            emit($cg, ")");
            return;
        }

        # Custom sort with comparator block
        my int $sort_id = $cg->{"sort_counter"};
        $cg->{"sort_counter"} = $sort_id + 1;

        emit($cg, "({ ");
        emit($cg, "StradaArray *__sort_input_" . $sort_id . " = strada_deref_array(");
        gen_expression($cg, $array_expr);
        emit($cg, "); ");
        emit($cg, "int __sort_len_" . $sort_id . " = strada_array_length(__sort_input_" . $sort_id . "); ");
        emit($cg, "StradaValue *__sort_result_" . $sort_id . " = strada_new_array(); ");
        # Copy elements to result
        emit($cg, "for (int __si_" . $sort_id . " = 0; __si_" . $sort_id . " < __sort_len_" . $sort_id . "; __si_" . $sort_id . "++) { ");
        emit($cg, "strada_array_push(strada_deref_array(__sort_result_" . $sort_id . "), strada_array_get(__sort_input_" . $sort_id . ", __si_" . $sort_id . ")); } ");
        # Bubble sort with custom comparator (simple implementation)
        emit($cg, "for (int __i_" . $sort_id . " = 0; __i_" . $sort_id . " < __sort_len_" . $sort_id . " - 1; __i_" . $sort_id . "++) { ");
        emit($cg, "for (int __j_" . $sort_id . " = 0; __j_" . $sort_id . " < __sort_len_" . $sort_id . " - __i_" . $sort_id . " - 1; __j_" . $sort_id . "++) { ");
        emit($cg, "StradaValue *__sort_a_ = strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . "); ");
        emit($cg, "StradaValue *__sort_b_ = strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . " + 1); ");
        emit($cg, "int __cmp_" . $sort_id . " = strada_to_int(");

        # Set flag to enable $a/$b magic variables
        $cg->{"in_sort_block"} = 1;

        # Generate comparator block - extract the comparison expression
        my scalar $stmts = $block->{"statements"};
        my int $stmt_count = $block->{"statement_count"};
        if ($stmt_count > 0) {
            my scalar $last_stmt = $stmts->[$stmt_count - 1];
            if ($last_stmt->{"type"} == NODE_EXPR_STMT()) {
                gen_expression($cg, $last_stmt->{"expr"});
            }
        }

        # Reset flag
        $cg->{"in_sort_block"} = 0;

        emit($cg, "); ");
        emit($cg, "if (__cmp_" . $sort_id . " > 0) { ");
        emit($cg, "StradaValue *__tmp_" . $sort_id . " = strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . "); ");
        emit($cg, "strada_array_set(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . ", strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . " + 1)); ");
        emit($cg, "strada_array_set(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . " + 1, __tmp_" . $sort_id . "); ");
        emit($cg, "} } } ");
        emit($cg, "__sort_result_" . $sort_id . "; })");
        return;
    }

    # Grep expression: grep { block } @array
    if ($type == NODE_GREP()) {
        my scalar $block = $expr->{"block"};
        my scalar $array_expr = $expr->{"array"};
        my int $grep_id = $cg->{"grep_counter"};
        $cg->{"grep_counter"} = $grep_id + 1;

        emit($cg, "({ ");
        emit($cg, "StradaArray *__grep_input_" . $grep_id . " = strada_deref_array(");
        gen_expression($cg, $array_expr);
        emit($cg, "); ");
        emit($cg, "StradaValue *__grep_result_" . $grep_id . " = strada_new_array(); ");
        emit($cg, "int __grep_len_" . $grep_id . " = strada_array_length(__grep_input_" . $grep_id . "); ");
        emit($cg, "for (int __grep_i_" . $grep_id . " = 0; __grep_i_" . $grep_id . " < __grep_len_" . $grep_id . "; __grep_i_" . $grep_id . "++) { ");
        emit($cg, "StradaValue *__elem_ = strada_array_get(__grep_input_" . $grep_id . ", __grep_i_" . $grep_id . "); ");
        emit($cg, "if (strada_to_bool(");

        # Set flag to enable $_ magic variable
        $cg->{"in_grep_block"} = 1;

        # Generate block - evaluate to boolean
        my scalar $stmts = $block->{"statements"};
        my int $stmt_count = $block->{"statement_count"};
        if ($stmt_count > 0) {
            my scalar $last_stmt = $stmts->[$stmt_count - 1];
            if ($last_stmt->{"type"} == NODE_EXPR_STMT()) {
                gen_expression($cg, $last_stmt->{"expr"});
            }
        }

        # Reset flag
        $cg->{"in_grep_block"} = 0;

        emit($cg, ")) { ");
        emit($cg, "strada_array_push(strada_deref_array(__grep_result_" . $grep_id . "), __elem_); } ");
        emit($cg, "} ");
        emit($cg, "__grep_result_" . $grep_id . "; })");
        return;
    }

    # Anonymous function
    if ($type == NODE_ANON_FUNC()) {
        my int $id = $cg->{"anon_func_counter"};
        $cg->{"anon_func_counter"} = $id + 1;
        my str $func_name = "__anon_func_" . $id;

        my scalar $params = $expr->{"params"};
        my int $param_count = $expr->{"param_count"};

        # Save current capture state (for nested closures)
        my int $saved_in_anon = $cg->{"in_anon_func"};
        my str $saved_param_str = $cg->{"anon_param_str"};
        my str $saved_local_str = $cg->{"anon_local_str"};
        my str $saved_capture_str = $cg->{"anon_capture_str"};
        my int $saved_capture_count = $cg->{"anon_capture_count"};

        # Set up capture context for this closure
        $cg->{"in_anon_func"} = 1;
        $cg->{"anon_local_str"} = "";
        $cg->{"anon_capture_str"} = "";
        $cg->{"anon_capture_count"} = 0;

        # Build param string from parameters
        my str $param_str = "";
        my int $i = 0;
        while ($i < $param_count) {
            my scalar $p = $params->[$i];
            if ($param_str eq "") {
                $param_str = $p->{"name"};
            } else {
                $param_str = $param_str . "," . $p->{"name"};
            }
            $i = $i + 1;
        }
        $cg->{"anon_param_str"} = $param_str;

        # Generate forward declaration (triple pointer for capture-by-reference)
        my str $decl = "StradaValue* " . $func_name . "(StradaValue ***__captures";
        $i = 0;
        while ($i < $param_count) {
            my scalar $p = $params->[$i];
            $decl = $decl . ", StradaValue *" . $p->{"name"};
            $i = $i + 1;
        }
        $decl = $decl . ")";
        $cg->{"anon_func_decls"} = $cg->{"anon_func_decls"} . $decl . ";\n";

        my str $def = $decl . " {\n";

        # Save current output (using StringBuilder)
        my str $saved_output = sb_to_string($cg->{"output_sb"});
        my int $saved_indent = $cg->{"indent"};
        my int $saved_in_main = $cg->{"in_main"};

        # Save scope state (closures are separate functions with their own scope)
        my scalar $saved_scope_vars = $cg->{"scope_vars"};
        my scalar $saved_scope_counts = $cg->{"scope_counts"};
        my int $saved_scope_depth = $cg->{"scope_depth"};

        # Save function parameter state (closures have their own parameters)
        my scalar $saved_func_params = $cg->{"func_params"};
        my scalar $saved_func_param_names = $cg->{"func_param_names"};
        my int $saved_func_param_count = $cg->{"func_param_count"};

        # Start fresh for function body (closures are NOT main)
        sb_clear($cg->{"output_sb"});
        $cg->{"indent"} = 1;
        $cg->{"in_main"} = 0;

        # Reset scope for closure (it's a new function)
        my array @new_scope_vars = ();
        my array @new_scope_counts = ();
        $cg->{"scope_vars"} = \@new_scope_vars;
        $cg->{"scope_counts"} = \@new_scope_counts;
        $cg->{"scope_depth"} = 0;

        # Reset function parameter tracking for closure (no param incref in closures)
        $cg->{"func_params"} = {};
        $cg->{"func_param_names"} = [];
        $cg->{"func_param_count"} = 0;

        # Generate body (this will populate capture_str as variables are accessed)
        my scalar $body = $expr->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $stmt_count = $body->{"statement_count"};
        $i = 0;
        while ($i < $stmt_count) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Get body content
        my str $body_content = sb_to_string($cg->{"output_sb"});
        $def = $def . $body_content;
        $def = $def . "}\n\n";

        # Capture the capture info before restoring state
        my str $capture_str = $cg->{"anon_capture_str"};
        my int $capture_count = $cg->{"anon_capture_count"};

        # Restore output (using StringBuilder)
        sb_clear($cg->{"output_sb"});
        sb_append($cg->{"output_sb"}, $saved_output);
        $cg->{"indent"} = $saved_indent;
        $cg->{"in_main"} = $saved_in_main;

        # Restore scope state
        $cg->{"scope_vars"} = $saved_scope_vars;
        $cg->{"scope_counts"} = $saved_scope_counts;
        $cg->{"scope_depth"} = $saved_scope_depth;

        # Restore function parameter state
        $cg->{"func_params"} = $saved_func_params;
        $cg->{"func_param_names"} = $saved_func_param_names;
        $cg->{"func_param_count"} = $saved_func_param_count;

        # Restore capture state
        $cg->{"in_anon_func"} = $saved_in_anon;
        $cg->{"anon_param_str"} = $saved_param_str;
        $cg->{"anon_local_str"} = $saved_local_str;
        $cg->{"anon_capture_str"} = $saved_capture_str;
        $cg->{"anon_capture_count"} = $saved_capture_count;

        $cg->{"anon_func_defs"} = $cg->{"anon_func_defs"} . $def;

        # Emit closure creation with captures (using double pointers for capture-by-reference)
        if ($capture_count == 0) {
            emit($cg, "strada_closure_new((void*)&" . $func_name . ", " . $param_count . ", 0, NULL)");
        } else {
            # Build capture array inline with addresses for capture-by-reference
            emit($cg, "strada_closure_new((void*)&" . $func_name . ", " . $param_count . ", " . $capture_count . ", ");
            emit($cg, "(StradaValue**[]){");
            # Parse capture_str to emit address of each captured variable
            my int $cap_idx = 0;
            my int $start = 0;
            my int $len = length($capture_str);
            $i = 0;
            while ($i <= $len) {
                my str $ch = "";
                if ($i < $len) { $ch = substr($capture_str, $i, 1); }
                if ($ch eq "," || $i == $len) {
                    if ($cap_idx > 0) { emit($cg, ", "); }
                    my str $cap_name = substr($capture_str, $start, $i - $start);
                    emit($cg, "&" . $cap_name);
                    $cap_idx = $cap_idx + 1;
                    $start = $i + 1;
                }
                $i = $i + 1;
            }
            emit($cg, "})");
        }
        return;
    }

    # Closure call
    if ($type == NODE_CLOSURE_CALL()) {
        emit($cg, "strada_closure_call(");
        gen_expression($cg, $expr->{"closure"});
        my scalar $args = $expr->{"args"};
        my int $arg_count = $expr->{"arg_count"};
        emit($cg, ", " . $arg_count);
        my int $i = 0;
        while ($i < $arg_count) {
            emit($cg, ", ");
            gen_expression($cg, $args->[$i]);
            $i = $i + 1;
        }
        emit($cg, ")");
        return;
    }

    # Ternary expression: cond ? true_expr : false_expr
    # FIX: When branches return borrowed references (hash/array access), we need
    # to incref the result so it becomes an owned reference. This prevents the
    # "double hash access in ternary" bug where:
    #   defined($h->{"key"}) ? $h->{"key"} : ""
    # would cause memory corruption because the ternary result is a borrowed
    # reference that might be incorrectly decref'd by callers.
    if ($type == NODE_TERNARY()) {
        my int $true_needs = return_needs_incref($expr->{"true_expr"});
        my int $false_needs = return_needs_incref($expr->{"false_expr"});

        if (($true_needs == 1 || $false_needs == 1) && $cg->{"cleanup_enabled"} == 1) {
            # Wrap in statement expression to incref the borrowed reference
            emit($cg, "({ StradaValue *__tern_tmp = (");
            emit_condition($cg, $expr->{"condition"});
            emit($cg, " ? ");
            gen_expression($cg, $expr->{"true_expr"});
            emit($cg, " : ");
            gen_expression($cg, $expr->{"false_expr"});
            emit($cg, "); strada_incref(__tern_tmp); __tern_tmp; })");
        } else {
            emit($cg, "(");
            emit_condition($cg, $expr->{"condition"});
            emit($cg, " ? ");
            gen_expression($cg, $expr->{"true_expr"});
            emit($cg, " : ");
            gen_expression($cg, $expr->{"false_expr"});
            emit($cg, ")");
        }
        return;
    }

    # Range expression: start..end
    if ($type == NODE_RANGE()) {
        emit($cg, "strada_range(");
        gen_expression($cg, $expr->{"start"});
        emit($cg, ", ");
        gen_expression($cg, $expr->{"end"});
        emit($cg, ")");
        return;
    }

    # Await expression: await $future
    if ($type == NODE_AWAIT()) {
        emit($cg, "strada_future_await(");
        gen_expression($cg, $expr->{"expr"});
        emit($cg, ")");
        return;
    }

    # Readline expression (diamond operator): <$fh>
    if ($type == NODE_READLINE()) {
        my str $varname = $expr->{"varname"};
        emit($cg, "strada_read_line(" . escape_c_keyword($varname) . ")");
        return;
    }

    # Spread operator - only valid inside function call arguments
    # If we reach here, the spread is being used incorrectly
    if ($type == NODE_SPREAD()) {
        die("error: spread operator (...) is only valid in function call arguments");
        return;
    }
}

# ============================================================
# Statement Code Generation
# ============================================================

func gen_block(scalar $cg, scalar $block) void {
    emit($cg, "{\n");
    indent($cg);
    scope_push($cg);

    my scalar $stmts = $block->{"statements"};
    my int $i = 0;
    while ($i < $block->{"statement_count"}) {
        gen_statement($cg, $stmts->[$i]);
        $i = $i + 1;
    }

    scope_pop($cg);
    dedent($cg);
    emit_indent($cg);
    emit($cg, "}");
}

func gen_statement(scalar $cg, scalar $stmt) void {
    # Emit #line directive for source-level debugging
    emit_line_for_stmt($cg, $stmt);

    my int $type = $stmt->{"type"};

    # Variable declaration
    if ($type == NODE_VAR_DECL()) {
        emit_indent($cg);

        # Track local variables when inside anonymous function
        if ($cg->{"in_anon_func"}) {
            my str $var_name = $stmt->{"name"};
            my str $local_str = $cg->{"anon_local_str"};
            if ($local_str eq "") {
                $cg->{"anon_local_str"} = $var_name;
            } else {
                $cg->{"anon_local_str"} = $local_str . "," . $var_name;
            }
        }

        my str $sigil = $stmt->{"sigil"};
        my int $var_type = $stmt->{"var_type"};
        # Escape C keywords in variable names (e.g., $for -> v_for)
        my str $c_name = escape_c_keyword($stmt->{"name"});

        # Struct type
        if ($var_type == TYPE_STRUCT()) {
            my str $type_name = $stmt->{"type_name"};
            # Register this variable as a struct type for function pointer detection
            $cg->{"struct_vars"}->{$stmt->{"name"}} = $type_name;
            # Track struct variable for scope-based cleanup
            scope_track_struct_var($cg, $c_name, $type_name);
            emit($cg, $type_name . " *" . $c_name);
            if ($stmt->{"init"}) {
                my scalar $init = $stmt->{"init"};
                # Handle clone() for structs specially
                if ($init->{"type"} == NODE_CALL() && $init->{"name"} eq "clone") {
                    emit($cg, " = malloc(sizeof(" . $type_name . ")); memcpy(" . $c_name . ", ");
                    my scalar $args = $init->{"args"};
                    gen_expression($cg, $args->[0]);
                    emit($cg, ", sizeof(" . $type_name . "))");
                } else {
                    emit($cg, " = ");
                    gen_expression($cg, $init);
                }
            } else {
                emit($cg, " = malloc(sizeof(" . $type_name . "))");
            }
        } elsif ($sigil eq "%" || $var_type == TYPE_HASH()) {
            emit($cg, "StradaValue *" . $c_name);
            if ($stmt->{"init"}) {
                emit($cg, " = ");
                # Handle empty () which parser returns as anon_hash
                my scalar $init = $stmt->{"init"};
                if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                    emit($cg, "strada_new_hash()");
                } else {
                    my int $init_type = $init->{"type"};
                    # If init is a map expression, convert flat array to hash
                    if ($init_type == NODE_MAP()) {
                        emit($cg, "strada_hash_from_flat_array(");
                        gen_expression($cg, $init);
                        emit($cg, ")");
                    } else {
                        gen_expression($cg, $init);
                        # If initializing from a variable or deref, incref to share ownership properly
                        if ($init_type == NODE_VARIABLE()) {
                            emit($cg, "; strada_incref(" . $c_name . ")");
                        } elsif ($init_type == NODE_DEREF_SCALAR() && $init->{"sigil"} eq "%") {
                            # Hash deref like %{$ref} returns borrowed reference - need to incref
                            emit($cg, "; strada_incref(" . $c_name . ")");
                        }
                    }
                }
            } else {
                emit($cg, " = strada_new_hash()");
            }
            # Handle initial capacity: my hash %name{size};
            if ($stmt->{"initial_capacity"}) {
                emit($cg, "; strada_hash_reserve_sv(" . $c_name . ", strada_to_int(");
                gen_expression($cg, $stmt->{"initial_capacity"});
                emit($cg, "))");
            }
        } elsif ($sigil eq "@" || $var_type == TYPE_ARRAY()) {
            emit($cg, "StradaValue *" . $c_name);
            if ($stmt->{"init"}) {
                emit($cg, " = ");
                # Handle empty () which parser returns as anon_hash
                my scalar $init = $stmt->{"init"};
                my int $init_type = $init->{"type"};
                if ($init_type == NODE_READLINE()) {
                    # Diamond operator in array context - read all lines
                    my str $varname = $init->{"varname"};
                    emit($cg, "strada_read_all_lines(" . escape_c_keyword($varname) . ")");
                } elsif ($init_type == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                    emit($cg, "strada_new_array()");
                } elsif ($init_type == NODE_ANON_ARRAY()) {
                    # Array literal like [1, 2, 3] - generate directly
                    gen_expression($cg, $init);
                } elsif (is_scalar_expr($init)) {
                    # Single scalar expression like ($x) - wrap in array
                    # Create array and push the element
                    emit($cg, "strada_new_array(); strada_array_push(" . $c_name . "->value.av, ");
                    gen_expression($cg, $init);
                    emit($cg, ")");
                } else {
                    # Could be array/hash/function returning array - assign directly
                    gen_expression($cg, $init);
                    # If initializing from a variable or deref, incref to share ownership properly
                    # This is needed because the local variable will be decref'd at end of scope
                    if ($init_type == NODE_VARIABLE()) {
                        emit($cg, "; strada_incref(" . $c_name . ")");
                    } elsif ($init_type == NODE_DEREF_SCALAR() && $init->{"sigil"} eq "@") {
                        # Array deref like @{$ref} returns borrowed reference - need to incref
                        emit($cg, "; strada_incref(" . $c_name . ")");
                    }
                }
            } else {
                emit($cg, " = strada_new_array()");
            }
            # Handle initial capacity: my array @name[size];
            if ($stmt->{"initial_capacity"}) {
                emit($cg, "; strada_reserve_sv(" . $c_name . ", strada_to_int(");
                gen_expression($cg, $stmt->{"initial_capacity"});
                emit($cg, "))");
            }
        } else {
            emit($cg, "StradaValue *" . $c_name);
            if ($stmt->{"init"}) {
                emit($cg, " = ");
                gen_expression($cg, $stmt->{"init"});
                # If initializing from borrowed reference, incref to share ownership properly
                # This prevents the original value from being freed when this one goes out of scope
                my scalar $init = $stmt->{"init"};
                my int $init_type = $init->{"type"};
                if ($init_type == NODE_VARIABLE()) {
                    emit($cg, "; strada_incref(" . $c_name . ")");
                } elsif ($init_type == NODE_HASH_ACCESS()) {
                    # Hash access returns borrowed reference - need to incref
                    emit($cg, "; strada_incref(" . $c_name . ")");
                } elsif ($init_type == NODE_SUBSCRIPT()) {
                    # Array subscript also returns borrowed reference
                    emit($cg, "; strada_incref(" . $c_name . ")");
                } elsif ($init_type == NODE_DEREF_ARRAY()) {
                    # Arrow array dereference $ref->[idx] returns borrowed reference
                    emit($cg, "; strada_incref(" . $c_name . ")");
                } elsif ($init_type == NODE_DEREF_HASH()) {
                    # Arrow hash dereference $ref->{key} returns borrowed reference
                    emit($cg, "; strada_incref(" . $c_name . ")");
                } elsif ($init_type == NODE_TERNARY()) {
                    # Ternary expression may contain borrowed references in branches
                    if (return_needs_incref($init) == 1) {
                        emit($cg, "; strada_incref(" . $c_name . ")");
                    }
                }
            } else {
                emit($cg, " = strada_new_undef()");
            }
        }
        emit($cg, ";\n");
        # Track variable for scope cleanup (only StradaValue*, not structs)
        # Use escaped name for C code generation
        if ($var_type != TYPE_STRUCT()) {
            scope_track_var($cg, $c_name);
        }
        return;
    }

    # Destructuring assignment: my ($a, $b, $c) = @arr;
    if ($type == NODE_DESTRUCTURE()) {
        my scalar $vars = $stmt->{"vars"};
        my int $var_count = $stmt->{"var_count"};
        my scalar $init = $stmt->{"init"};
        my int $is_decl = $stmt->{"is_decl"};

        # If declaration, first declare all variables at outer scope
        if ($is_decl == 1) {
            my int $i = 0;
            while ($i < $var_count) {
                my scalar $var = $vars->[$i];
                my str $name = escape_c_keyword($var->{"name"});
                emit_indent($cg);
                emit($cg, "StradaValue *" . $name . " = strada_new_undef();\n");
                scope_track_var($cg, $name);
                $i = $i + 1;
            }
        }

        # Wrap assignment in a block for the temporary
        emit_indent($cg);
        emit($cg, "{\n");
        indent($cg);

        # Evaluate source expression once
        emit_indent($cg);
        emit($cg, "StradaValue *__destruct_src = ");
        gen_expression($cg, $init);
        emit($cg, ";\n");

        # Check if source is a variable (needs incref since we're borrowing)
        my int $init_type = $init->{"type"};
        if ($init_type == NODE_VARIABLE()) {
            emit_indent($cg);
            emit($cg, "strada_incref(__destruct_src);\n");
        }

        # Assign each variable
        my int $i = 0;
        while ($i < $var_count) {
            my scalar $var = $vars->[$i];
            my str $name = escape_c_keyword($var->{"name"});

            # Decref old value if already assigned
            emit_indent($cg);
            emit($cg, "strada_decref(" . $name . ");\n");

            # Get element from array
            emit_indent($cg);
            emit($cg, $name . " = strada_array_get_safe(__destruct_src, " . $i . ");\n");

            # Incref the extracted value since array_get returns borrowed reference
            emit_indent($cg);
            emit($cg, "strada_incref(" . $name . ");\n");

            $i = $i + 1;
        }

        # Release source
        emit_indent($cg);
        emit($cg, "strada_decref(__destruct_src);\n");

        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");
        return;
    }

    # Bare block { ... }
    if ($type == NODE_BLOCK()) {
        emit_indent($cg);
        gen_block($cg, $stmt);
        emit($cg, "\n");
        return;
    }

    # If statement
    if ($type == NODE_IF_STMT()) {
        emit_indent($cg);
        emit($cg, "if (");
        emit_condition($cg, $stmt->{"condition"});
        emit($cg, ") ");
        gen_block($cg, $stmt->{"then_block"});

        # Elsif clauses
        my scalar $elsif_conds = $stmt->{"elsif_conditions"};
        my scalar $elsif_blocks = $stmt->{"elsif_blocks"};
        my int $i = 0;
        while ($i < $stmt->{"elsif_count"}) {
            emit($cg, " else if (");
            emit_condition($cg, $elsif_conds->[$i]);
            emit($cg, ") ");
            gen_block($cg, $elsif_blocks->[$i]);
            $i = $i + 1;
        }
        
        # Else clause
        if ($stmt->{"else_block"}) {
            emit($cg, " else ");
            gen_block($cg, $stmt->{"else_block"});
        }
        
        emit($cg, "\n");
        return;
    }
    
    # While statement
    if ($type == NODE_WHILE_STMT()) {
        my str $label = $stmt->{"label"};
        # Register label depth BEFORE scope_push so cleanup covers loop body
        if (length($label) > 0) {
            my scalar $label_depths = $cg->{"label_depths"};
            $label_depths->{$label} = $cg->{"scope_depth"};
        }
        emit_indent($cg);
        emit($cg, "while (");
        emit_condition($cg, $stmt->{"condition"});
        emit($cg, ") {\n");
        indent($cg);
        scope_push($cg);

        my scalar $body = $stmt->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Add continue label at end of loop body if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_continue: ;\n");
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Add break label after loop if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_break: ;\n");
        }
        return;
    }

    # Do-while statement
    if ($type == NODE_DO_WHILE_STMT()) {
        my str $label = $stmt->{"label"};
        # Register label depth BEFORE scope_push so cleanup covers loop body
        if (length($label) > 0) {
            my scalar $label_depths = $cg->{"label_depths"};
            $label_depths->{$label} = $cg->{"scope_depth"};
        }
        emit_indent($cg);
        emit($cg, "do {\n");
        indent($cg);
        scope_push($cg);

        my scalar $body = $stmt->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Add continue label at end of loop body if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_continue: ;\n");
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "} while (");
        emit_condition($cg, $stmt->{"condition"});
        emit($cg, ");\n");

        # Add break label after loop if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_break: ;\n");
        }
        return;
    }

    # For statement
    if ($type == NODE_FOR_STMT()) {
        my str $label = $stmt->{"label"};
        # Register label depth BEFORE any blocks so cleanup covers everything
        if (length($label) > 0) {
            my scalar $label_depths = $cg->{"label_depths"};
            $label_depths->{$label} = $cg->{"scope_depth"};
        }
        my str $loop_var_name = "";
        my int $has_var_decl = 0;

        # Check if init declares a variable that needs cleanup
        if ($stmt->{"init"}) {
            my scalar $init = $stmt->{"init"};
            if ($init->{"type"} == NODE_VAR_DECL()) {
                $has_var_decl = 1;
                $loop_var_name = escape_c_keyword($init->{"name"});
                # Wrap in a block for proper scoping
                emit_indent($cg);
                emit($cg, "{\n");
                indent($cg);
                emit_indent($cg);
                emit($cg, "StradaValue *" . $loop_var_name . " = ");
                if ($init->{"init"}) {
                    gen_expression($cg, $init->{"init"});
                } else {
                    emit($cg, "strada_new_undef()");
                }
                emit($cg, ";\n");
            }
        }

        emit_indent($cg);
        emit($cg, "for (");

        if ($stmt->{"init"} && $has_var_decl == 0) {
            gen_expression($cg, $stmt->{"init"});
        }
        emit($cg, "; ");

        if ($stmt->{"condition"}) {
            emit_condition($cg, $stmt->{"condition"});
        }
        emit($cg, "; ");

        if ($stmt->{"update"}) {
            my scalar $update = $stmt->{"update"};
            # Check if update is an increment/decrement - its return value must be freed
            if ($update->{"type"} == NODE_INCREMENT()) {
                emit($cg, "({ StradaValue *__upd_tmp = ");
                gen_expression($cg, $update);
                emit($cg, "; strada_decref(__upd_tmp); })");
            } else {
                gen_expression($cg, $update);
            }
        }

        emit($cg, ") {\n");
        indent($cg);
        scope_push($cg);

        my scalar $body = $stmt->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Add continue label at end of loop body if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_continue: ;\n");
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Clean up loop variable if we declared one
        if ($has_var_decl == 1) {
            emit_indent($cg);
            emit($cg, "strada_decref(" . $loop_var_name . ");\n");
            dedent($cg);
            emit_indent($cg);
            emit($cg, "}\n");
        }

        # Add break label after loop if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_break: ;\n");
        }
        return;
    }

    # Foreach statement
    if ($type == NODE_FOREACH_STMT()) {
        my str $label = $stmt->{"label"};
        # Register label depth BEFORE any blocks so cleanup covers everything
        if (length($label) > 0) {
            my scalar $label_depths = $cg->{"label_depths"};
            $label_depths->{$label} = $cg->{"scope_depth"};
        }
        my scalar $var_decl = $stmt->{"var_decl"};
        my str $var_name = escape_c_keyword($stmt->{"var_name"});
        my scalar $array_expr = $stmt->{"array"};
        my scalar $body = $stmt->{"body"};

        my int $foreach_id = $cg->{"foreach_counter"};
        $cg->{"foreach_counter"} = $foreach_id + 1;

        # Open a block scope
        emit_indent($cg);
        emit($cg, "{\n");
        indent($cg);
        scope_push($cg);

        # Get the array and iterate
        emit_indent($cg);
        emit($cg, "StradaValue *__foreach_arr_" . $foreach_id . " = ");
        gen_expression($cg, $array_expr);
        emit($cg, ";\n");

        emit_indent($cg);
        emit($cg, "StradaArray *__foreach_av_" . $foreach_id . " = strada_deref_array(__foreach_arr_" . $foreach_id . ");\n");

        emit_indent($cg);
        emit($cg, "int __foreach_len_" . $foreach_id . " = strada_array_length(__foreach_av_" . $foreach_id . ");\n");

        emit_indent($cg);
        emit($cg, "for (int __foreach_i_" . $foreach_id . " = 0; __foreach_i_" . $foreach_id . " < __foreach_len_" . $foreach_id . "; __foreach_i_" . $foreach_id . "++) {\n");
        indent($cg);
        scope_push($cg);

        # Declare or assign the loop variable
        emit_indent($cg);
        if ($var_decl) {
            # New variable declaration
            emit($cg, "StradaValue *" . $var_name . " = strada_array_get(__foreach_av_" . $foreach_id . ", __foreach_i_" . $foreach_id . ");\n");
        } else {
            # Existing variable - assign to it
            emit($cg, $var_name . " = strada_array_get(__foreach_av_" . $foreach_id . ", __foreach_i_" . $foreach_id . ");\n");
        }

        # Generate body statements
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Add continue label at end of loop body if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_continue: ;\n");
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Close block scope
        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Add break label after loop if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_break: ;\n");
        }
        return;
    }

    # Return statement
    if ($type == NODE_RETURN_STMT()) {
        my int $in_main = $cg->{"in_main"};
        my int $returns_struct = $cg->{"returns_struct"};
        my int $cleanup_enabled = $cg->{"cleanup_enabled"};
        my int $profiling = $cg->{"enable_profiling"};
        my str $func_name = $cg->{"current_func_name"};
        my int $in_extern = $cg->{"in_extern"};

        # extern functions - simple return with raw C types
        if ($in_extern == 1) {
            emit_indent($cg);
            emit($cg, "return");
            if ($stmt->{"value"}) {
                emit($cg, " ");
                gen_expression($cg, $stmt->{"value"});
            }
            emit($cg, ";\n");
            return;
        }

        # main() and struct-returning functions - evaluate return value, cleanup, then return
        if ($in_main == 1 || $returns_struct == 1) {
            if ($stmt->{"value"}) {
                # Evaluate return expression BEFORE cleanup to avoid use-after-free
                emit_indent($cg);
                if ($in_main == 1) {
                    if ($stmt->{"value"}->{"type"} == NODE_INT_LITERAL()) {
                        # Simple literal - can emit directly after cleanup
                        if ($cleanup_enabled == 1) {
                            scope_emit_all_cleanup($cg);
                        }
                        emit_try_cleanup($cg);
                        emit_indent($cg);
                        emit($cg, "return " . $stmt->{"value"}->{"value"} . ";\n");
                    } else {
                        # Complex expression - evaluate first, then cleanup
                        emit($cg, "{ int __main_ret = strada_to_int(");
                        gen_expression($cg, $stmt->{"value"});
                        emit($cg, ");\n");
                        indent($cg);
                        if ($cleanup_enabled == 1) {
                            scope_emit_all_cleanup($cg);
                        }
                        emit_try_cleanup($cg);
                        emit_indent($cg);
                        emit($cg, "return __main_ret; }\n");
                        dedent($cg);
                    }
                } else {
                    # Struct return - evaluate first
                    # If returning a struct variable, exclude it from cleanup
                    my str $skip_struct_var = "";
                    my scalar $ret_val = $stmt->{"value"};
                    if ($ret_val->{"type"} == NODE_VARIABLE()) {
                        my str $vname = $ret_val->{"name"};
                        my scalar $sv = $cg->{"struct_vars"};
                        if ($sv->{$vname}) {
                            $skip_struct_var = escape_c_keyword($vname);
                        }
                    }
                    $cg->{"skip_struct_cleanup"} = $skip_struct_var;

                    emit($cg, "{ ");
                    my str $ret_type = $cg->{"current_func_return_type_str"};
                    if (length($ret_type) == 0) {
                        $ret_type = "void*";
                    }
                    emit($cg, $ret_type . " __struct_ret = ");
                    gen_expression($cg, $stmt->{"value"});
                    emit($cg, ";\n");
                    indent($cg);
                    if ($cleanup_enabled == 1) {
                        scope_emit_all_cleanup($cg);
                    }
                    emit_try_cleanup($cg);
                    emit_indent($cg);
                    emit($cg, "return __struct_ret; }\n");
                    dedent($cg);
                    $cg->{"skip_struct_cleanup"} = "";
                }
            } else {
                # No return value - cleanup then return
                if ($cleanup_enabled == 1) {
                    scope_emit_all_cleanup($cg);
                }
                emit_try_cleanup($cg);
                emit_indent($cg);
                emit($cg, "return;\n");
            }
        } elsif ($cleanup_enabled == 0) {
            # Cleanup disabled - simple return
            # Still need to pop try blocks even if cleanup is disabled
            emit_try_cleanup($cg);
            # Add profiling exit if enabled (for non-main)
            if ($profiling == 1 && $in_main == 0 && length($func_name) > 0) {
                if ($stmt->{"value"}) {
                    # Save return value, call profile_exit, then return
                    emit_indent($cg);
                    emit($cg, "{ StradaValue *__retval = ");
                    gen_expression($cg, $stmt->{"value"});
                    emit($cg, "; strada_profile_exit(\"" . $func_name . "\"); return __retval; }\n");
                } else {
                    emit_indent($cg);
                    emit($cg, "strada_profile_exit(\"" . $func_name . "\");\n");
                    emit_indent($cg);
                    emit($cg, "return;\n");
                }
            } else {
                emit_indent($cg);
                emit($cg, "return");
                if ($stmt->{"value"}) {
                    emit($cg, " ");
                    gen_expression($cg, $stmt->{"value"});
                }
                emit($cg, ";\n");
            }
        } elsif ($stmt->{"value"}) {
            # Non-main function with return value - save, cleanup, return
            emit_indent($cg);
            emit($cg, "{ StradaValue *__retval = ");
            gen_expression($cg, $stmt->{"value"});
            emit($cg, ";\n");
            indent($cg);
            # Only incref if returning a variable/borrowed ref (not for new values)
            if (return_needs_incref($stmt->{"value"}) == 1) {
                emit_indent($cg);
                emit($cg, "strada_incref(__retval);\n");
            }
            scope_emit_all_cleanup($cg);
            # Pop any active try blocks before returning
            emit_try_cleanup($cg);
            # Add profiling exit if enabled
            if ($profiling == 1 && length($func_name) > 0) {
                emit_indent($cg);
                emit($cg, "strada_profile_exit(\"" . $func_name . "\");\n");
            }
            emit_indent($cg);
            emit($cg, "return __retval; }\n");
            dedent($cg);
        } else {
            # Void return - cleanup then return
            scope_emit_all_cleanup($cg);
            # Pop any active try blocks before returning
            emit_try_cleanup($cg);
            # Add profiling exit if enabled
            if ($profiling == 1 && length($func_name) > 0) {
                emit_indent($cg);
                emit($cg, "strada_profile_exit(\"" . $func_name . "\");\n");
            }
            emit_indent($cg);
            emit($cg, "return;\n");
        }
        return;
    }
    
    # Expression statement
    if ($type == NODE_EXPR_STMT()) {
        emit_indent($cg);
        my scalar $expr = $stmt->{"expr"};

        # Check if this is a void-returning struct function pointer call
        my int $is_void_funcptr = 0;
        if ($expr->{"type"} == NODE_METHOD_CALL()) {
            my scalar $obj = $expr->{"object"};
            my str $method = $expr->{"method"};
            if ($obj->{"type"} == NODE_FIELD_ACCESS()) {
                my scalar $struct_obj = $obj->{"object"};
                if ($struct_obj->{"type"} == NODE_VARIABLE()) {
                    my str $var_name = $struct_obj->{"name"};
                    my scalar $struct_vars = $cg->{"struct_vars"};
                    if ($struct_vars->{$var_name}) {
                        my str $struct_type = $struct_vars->{$var_name};
                        my scalar $struct_defs = $cg->{"struct_defs"};
                        if ($struct_defs->{$struct_type}) {
                            my scalar $struct_info = $struct_defs->{$struct_type};
                            my scalar $field_info = $struct_info->{"fields"}->{$method};
                            if ($field_info && $field_info->{"is_funcptr"}) {
                                if ($field_info->{"funcptr_return"} == TYPE_VOID()) {
                                    $is_void_funcptr = 1;
                                }
                            }
                        }
                    }
                }
            }
        }

        # Check if expression produces owned value that must be freed
        # This includes increment/decrement, method calls, and other temp values
        # But NOT void-returning struct function pointer calls
        if ($is_void_funcptr == 0 && ($expr->{"type"} == NODE_INCREMENT() ||
            ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($expr) == 1))) {
            emit($cg, "({ StradaValue *__expr_tmp = ");
            gen_expression($cg, $expr);
            emit($cg, "; strada_decref(__expr_tmp); });\n");
        } else {
            gen_expression($cg, $expr);
            emit($cg, ";\n");
        }
        return;
    }
    
    # Last (break)
    if ($type == 100) {
        my str $label = $stmt->{"label"};
        if (length($label) > 0) {
            # Emit cleanup for all scopes between current and target label's scope
            my scalar $label_depths = $cg->{"label_depths"};
            my int $target_depth = $label_depths->{$label} + 0;
            scope_emit_cleanup_to_depth($cg, $target_depth);
            emit_indent($cg);
            emit($cg, "goto ");
            emit($cg, $label);
            emit($cg, "_break;\n");
        } else {
            emit_indent($cg);
            emit($cg, "break;\n");
        }
        return;
    }

    # Next (continue)
    if ($type == 101) {
        my str $label = $stmt->{"label"};
        if (length($label) > 0) {
            # Emit cleanup for scopes between current and target label's BODY scope
            # Note: For next, we use label_depth + 1 because the _continue label is
            # placed before scope_pop, so the loop body's cleanup still runs normally
            my scalar $label_depths = $cg->{"label_depths"};
            my int $target_depth = $label_depths->{$label} + 1;
            scope_emit_cleanup_to_depth($cg, $target_depth);
            emit_indent($cg);
            emit($cg, "goto ");
            emit($cg, $label);
            emit($cg, "_continue;\n");
        } else {
            emit_indent($cg);
            emit($cg, "continue;\n");
        }
        return;
    }

    # Try/Catch statement with typed exceptions
    if ($type == NODE_TRY_CATCH()) {
        emit_indent($cg);
        emit($cg, "if (setjmp(*STRADA_TRY_PUSH()) == 0) {\n");
        indent($cg);
        scope_push($cg);

        # Track that we're inside a try block (for proper cleanup on return)
        my int $try_depth = $cg->{"try_depth"};
        $cg->{"try_depth"} = $try_depth + 1;

        # Generate try block
        my scalar $try_block = $stmt->{"try_block"};
        my scalar $stmts = $try_block->{"statements"};
        my int $i = 0;
        while ($i < $try_block->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Decrement try_depth before we emit the pop
        $cg->{"try_depth"} = $try_depth;

        emit_indent($cg);
        emit($cg, "STRADA_TRY_POP();\n");
        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "} else {\n");
        indent($cg);
        scope_push($cg);
        emit_indent($cg);
        emit($cg, "STRADA_TRY_POP();\n");

        # Get the exception into a temporary variable
        emit_indent($cg);
        emit($cg, "StradaValue *__strada_exc = strada_get_exception();\n");

        # Generate catch clauses
        my scalar $catch_clauses = $stmt->{"catch_clauses"};
        my int $catch_count = $stmt->{"catch_count"};
        my int $has_catchall = 0;

        my int $c = 0;
        while ($c < $catch_count) {
            my scalar $clause = $catch_clauses->[$c];
            my str $catch_type = $clause->{"catch_type"};
            my str $catch_var = $clause->{"catch_var"};
            my scalar $catch_block = $clause->{"catch_block"};

            emit_indent($cg);

            if (length($catch_type) > 0) {
                # Typed catch clause
                if ($c == 0) {
                    emit($cg, "if (strada_isa(__strada_exc, \"");
                } else {
                    emit($cg, "} else if (strada_isa(__strada_exc, \"");
                }
                emit($cg, $catch_type);
                emit($cg, "\")) {\n");
            } else {
                # Catch-all clause
                $has_catchall = 1;
                if ($c == 0) {
                    emit($cg, "{\n");
                } else {
                    emit($cg, "} else {\n");
                }
            }

            indent($cg);
            scope_push($cg);

            # Declare catch variable and assign exception
            emit_indent($cg);
            emit($cg, "StradaValue *");
            emit($cg, $catch_var);
            emit($cg, " = __strada_exc;\n");
            scope_track_var($cg, $catch_var);

            # Generate catch block statements
            my scalar $catch_stmts = $catch_block->{"statements"};
            my int $j = 0;
            while ($j < $catch_block->{"statement_count"}) {
                gen_statement($cg, $catch_stmts->[$j]);
                $j = $j + 1;
            }

            scope_pop($cg);
            dedent($cg);

            $c = $c + 1;
        }

        # If no catch-all, add a re-throw for unmatched exceptions
        if ($has_catchall == 0) {
            emit_indent($cg);
            emit($cg, "} else {\n");
            indent($cg);
            emit_indent($cg);
            emit($cg, "strada_throw_value(__strada_exc);\n");
            dedent($cg);
        }

        emit_indent($cg);
        emit($cg, "}\n");

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");
        return;
    }

    # Throw statement
    if ($type == NODE_THROW()) {
        emit_indent($cg);
        emit($cg, "strada_throw_value(");
        gen_expression($cg, $stmt->{"expr"});
        emit($cg, ");\n");
        return;
    }

    # Label statement
    if ($type == NODE_LABEL()) {
        emit($cg, $stmt->{"name"} . ":;\n");
        return;
    }

    # Goto statement
    if ($type == NODE_GOTO()) {
        emit_indent($cg);
        emit($cg, "goto " . $stmt->{"target"} . ";\n");
        return;
    }

    # Switch statement
    if ($type == NODE_SWITCH()) {
        # Generate a unique variable to hold the switch expression
        my int $switch_id = $cg->{"switch_counter"};
        $cg->{"switch_counter"} = $switch_id + 1;
        my str $switch_var = "_switch_val_" . $switch_id;

        emit_indent($cg);
        emit($cg, "{\n");
        indent($cg);

        # Evaluate switch expression once
        emit_indent($cg);
        emit($cg, "StradaValue *" . $switch_var . " = ");
        gen_expression($cg, $stmt->{"expr"});
        emit($cg, ";\n");

        my scalar $cases = $stmt->{"cases"};
        my scalar $blocks = $stmt->{"blocks"};
        my int $case_count = $stmt->{"case_count"};
        my int $i = 0;

        while ($i < $case_count) {
            emit_indent($cg);
            if ($i == 0) {
                emit($cg, "if (strcmp(strada_to_str(" . $switch_var . "), strada_to_str(");
            } else {
                emit($cg, "} else if (strcmp(strada_to_str(" . $switch_var . "), strada_to_str(");
            }
            gen_expression($cg, $cases->[$i]);
            emit($cg, ")) == 0) {\n");
            indent($cg);

            # Generate the block body (statements only, not the braces)
            my scalar $block = $blocks->[$i];
            my scalar $stmts = $block->{"statements"};
            my int $j = 0;
            while ($j < $block->{"statement_count"}) {
                gen_statement($cg, $stmts->[$j]);
                $j = $j + 1;
            }

            dedent($cg);
            $i = $i + 1;
        }

        # Default block
        my int $has_default = $stmt->{"has_default"};
        if ($has_default) {
            my scalar $default_block = $stmt->{"default_block"};
            emit_indent($cg);
            if ($case_count > 0) {
                emit($cg, "} else {\n");
            } else {
                emit($cg, "{\n");
            }
            indent($cg);

            my scalar $def_stmts = $default_block->{"statements"};
            my int $k = 0;
            while ($k < $default_block->{"statement_count"}) {
                gen_statement($cg, $def_stmts->[$k]);
                $k = $k + 1;
            }

            dedent($cg);
        }

        if ($case_count > 0 || $has_default) {
            emit_indent($cg);
            emit($cg, "}\n");
        }

        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");
        return;
    }

    # __C__ { ... } - raw C code block
    if ($type == NODE_C_BLOCK()) {
        my str $code = $stmt->{"code"};
        emit($cg, "/* Begin __C__ block */\n");
        emit($cg, $code);
        emit($cg, "\n/* End __C__ block */\n");
        return;
    }
}

# ============================================================
# Function and Program Code Generation
# ============================================================

func gen_function(scalar $cg, scalar $fn) void {
    my str $ret_type = type_to_c($fn->{"return_type"});
    my str $name = sanitize_name($fn->{"name"});
    my int $ret_type_id = $fn->{"return_type"};

    # Reset function parameter tracking for each new function
    $cg->{"func_params"} = {};
    $cg->{"func_param_names"} = [];
    $cg->{"func_param_count"} = 0;

    # Check if this is a DESTROY method - these should NOT have parameter incref/decref
    # because DESTROY is called during object destruction when refcount is already 0
    my int $is_destroy = 0;
    if ($name eq "DESTROY") {
        $is_destroy = 1;
    } else {
        my int $name_len = length($name);
        if ($name_len > 8) {
            my str $suffix = substr($name, $name_len - 8, 8);
            if ($suffix eq "_DESTROY") {
                $is_destroy = 1;
            }
        }
    }
    $cg->{"is_destroy_method"} = $is_destroy;

    # Track if function returns a struct (for return statement handling)
    if ($ret_type_id == TYPE_STRUCT()) {
        $cg->{"returns_struct"} = 1;
    } else {
        $cg->{"returns_struct"} = 0;
    }

    # Special case for main
    if ($name eq "main") {
        $cg->{"in_main"} = 1;
        emit($cg, "int main(int _argc, char **_argv) {\n");
        emit($cg, "    /* Initialize proctitle support */\n");
        emit($cg, "    strada_init_proctitle(_argc, _argv);\n\n");

        # Initialize profiling if enabled
        if ($cg->{"enable_profiling"} == 1) {
            emit($cg, "    /* Initialize function profiling */\n");
            emit($cg, "    strada_profile_init();\n");
            emit($cg, "    atexit(strada_profile_report);\n\n");
        }
        emit($cg, "    /* Populate global ARGV array */\n");
        emit($cg, "    ARGV = strada_new_array();\n");
        emit($cg, "    for (int i = 0; i < _argc; i++) {\n");
        emit($cg, "        strada_array_push(ARGV->value.av, strada_new_str(_argv[i]));\n");
        emit($cg, "    }\n");
        emit($cg, "    ARGC = strada_new_int(_argc);\n\n");

        # Set package if declared at file level
        my str $pkg = $cg->{"package"};
        if ($pkg ne "") {
            emit($cg, "    /* Set package from file-level declaration */\n");
            emit($cg, "    strada_set_package(\"" . $pkg . "\");\n\n");
        }

        # Set up inheritance from file-level declarations
        my scalar $inherits = $cg->{"inherits"};
        my int $inherit_count = $cg->{"inherit_count"};
        if ($inherit_count > 0) {
            emit($cg, "    /* Set up inheritance from file-level declarations */\n");
            my int $inh = 0;
            while ($inh < $inherit_count) {
                my str $parent = $inherits->[$inh];
                emit($cg, "    strada_inherit_from(\"" . $parent . "\");\n");
                $inh = $inh + 1;
            }
            emit($cg, "\n");
        }

        # Initialize OOP method registration for all packages that have methods
        my int $num_oop_pkgs = get_oop_pkg_count($cg);
        if ($num_oop_pkgs > 0) {
            my scalar $oop_pkgs = get_oop_packages($cg);
            emit($cg, "    /* Initialize OOP method registration */\n");
            my int $oop_i = 0;
            while ($oop_i < $num_oop_pkgs) {
                my str $oop_pkg = $oop_pkgs->[$oop_i];
                emit($cg, "    __" . $oop_pkg . "_oop_init();\n");
                $oop_i = $oop_i + 1;
            }
            emit($cg, "\n");
        }

        # If main has parameters, bind argc/argv to them
        my scalar $params = $fn->{"params"};
        my int $param_count = $fn->{"param_count"};
        if ($param_count >= 1) {
            # First parameter gets argc
            my scalar $p1 = $params->[0];
            emit($cg, "    StradaValue* " . $p1->{"name"} . " = ARGC;\n");
        }
        if ($param_count >= 2) {
            # Second parameter gets argv array
            my scalar $p2 = $params->[1];
            emit($cg, "    StradaValue* " . $p2->{"name"} . " = ARGV;\n");
        }
        if ($param_count > 0) {
            emit($cg, "\n");
        }

        # Initialize global variables
        my int $global_count = $cg->{"global_count"};
        if ($global_count > 0) {
            emit($cg, "    /* Initialize global variables */\n");
            my scalar $globals = $cg->{"globals"};
            my int $g = 0;
            while ($g < $global_count) {
                my scalar $gvar = $globals->[$g];
                my int $var_type = $gvar->{"var_type"};
                my str $sigil = $gvar->{"sigil"};
                my str $name = $gvar->{"name"};
                my scalar $init = $gvar->{"init"};

                emit($cg, "    " . $name . " = ");
                if ($var_type == TYPE_STRUCT()) {
                    my str $type_name = $gvar->{"type_name"};
                    if ($init) {
                        gen_expression($cg, $init);
                    } else {
                        emit($cg, "malloc(sizeof(" . $type_name . "))");
                    }
                } elsif ($sigil eq "%" || $var_type == TYPE_HASH()) {
                    if ($init) {
                        # Handle empty () which parser returns as anon_hash
                        if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                            emit($cg, "strada_new_hash()");
                        } else {
                            gen_expression($cg, $init);
                        }
                    } else {
                        emit($cg, "strada_new_hash()");
                    }
                } elsif ($sigil eq "@" || $var_type == TYPE_ARRAY()) {
                    if ($init) {
                        # Handle empty () which parser returns as anon_hash
                        if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                            emit($cg, "strada_new_array()");
                        } else {
                            gen_expression($cg, $init);
                        }
                    } else {
                        emit($cg, "strada_new_array()");
                    }
                } else {
                    if ($init) {
                        gen_expression($cg, $init);
                    } else {
                        emit($cg, "strada_new_undef()");
                    }
                }
                emit($cg, ";\n");
                $g = $g + 1;
            }
            emit($cg, "\n");
        }

        # Generate the body statements directly (without the outer braces)
        # Push scope for main's local variables
        scope_push($cg);
        my scalar $body = $fn->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }
        scope_pop($cg);
        emit($cg, "}\n\n");
        $cg->{"in_main"} = 0;
    } else {
        # Private functions get static prefix (file-scope only)
        my str $static_prefix = "";
        if ($fn->{"is_private"} == 1) {
            $static_prefix = "static ";
        }
        emit($cg, $static_prefix . $ret_type . " " . $name . "(");
        
        my scalar $params = $fn->{"params"};
        my int $i = 0;
        while ($i < $fn->{"param_count"}) {
            if ($i > 0) {
                emit($cg, ", ");
            }
            my scalar $param = $params->[$i];
            my int $ptype = $param->{"param_type"};
            my str $c_param_name = escape_c_keyword($param->{"name"});
            if ($ptype == TYPE_STRUCT()) {
                # Register struct-typed parameter for function pointer detection
                $cg->{"struct_vars"}->{$param->{"name"}} = $param->{"type_name"};
                emit($cg, $param->{"type_name"} . " *" . $c_param_name);
            } else {
                emit($cg, type_to_c($ptype) . " " . $c_param_name);
            }
            $i = $i + 1;
        }

        if ($fn->{"param_count"} == 0) {
            emit($cg, "void");
        }

        emit($cg, ") {\n");

        # Add profiling entry if enabled
        if ($cg->{"enable_profiling"} == 1) {
            emit($cg, "    strada_profile_enter(\"" . $name . "\");\n");
        }

        # Store current function name for profiling exit in return statements
        $cg->{"current_func_name"} = $name;

        # Store current function's package for SUPER:: calls
        $cg->{"current_fn_package"} = $fn->{"package"};

        # Generate the function body (without the outer braces, we handle them)
        scope_push($cg);

        # Track function parameters and their C names for proper reference counting
        # We incref each parameter at entry so the function "owns" its reference
        # This allows safe reassignment without affecting the caller's copy
        # EXCEPTION: DESTROY methods should NOT have parameter incref/decref because
        # they are called during object destruction when refcount is already 0
        $cg->{"func_params"} = {};
        $cg->{"func_param_names"} = [];
        $cg->{"func_param_count"} = 0;
        if ($cg->{"is_destroy_method"} != 1) {
            my int $param_i = 0;
            while ($param_i < $fn->{"param_count"}) {
                my scalar $param = $params->[$param_i];
                my int $ptype = $param->{"param_type"};
                if ($ptype != TYPE_STRUCT()) {
                    my str $c_param_name = escape_c_keyword($param->{"name"});
                    $cg->{"func_params"}->{$param->{"name"}} = 1;
                    my int $pc = $cg->{"func_param_count"};
                    $cg->{"func_param_names"}->[$pc] = $c_param_name;
                    $cg->{"func_param_count"} = $pc + 1;
                    emit($cg, "strada_incref(" . $c_param_name . ");\n");
                }
                $param_i = $param_i + 1;
            }
        }

        my scalar $body = $fn->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $stmt_i = 0;
        while ($stmt_i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$stmt_i]);
            $stmt_i = $stmt_i + 1;
        }
        scope_pop($cg);

        # Decref function parameters for void functions that fall through
        # (functions with return statements handle this in scope_emit_all_cleanup)
        if ($ret_type_id == TYPE_VOID()) {
            my int $pn_count = $cg->{"func_param_count"} + 0;
            if ($pn_count > 0) {
                my scalar $param_names = $cg->{"func_param_names"};
                my int $pn_i = 0;
                while ($pn_i < $pn_count) {
                    my str $pname = $param_names->[$pn_i];
                    emit($cg, "strada_decref(" . $pname . ");\n");
                    $pn_i = $pn_i + 1;
                }
            }
        }

        # Add implicit profiling exit for void functions (no explicit return)
        if ($cg->{"enable_profiling"} == 1 && $ret_type_id == TYPE_VOID()) {
            emit($cg, "    strada_profile_exit(\"" . $name . "\");\n");
        }
        emit($cg, "}\n");

        $cg->{"current_func_name"} = "";
        $cg->{"current_fn_package"} = "";

        # Clear func_params
        $cg->{"func_params"} = {};

        # Clear struct_vars for parameters (they go out of scope)
        $i = 0;
        while ($i < $fn->{"param_count"}) {
            my scalar $param = $params->[$i];
            if ($param->{"param_type"} == TYPE_STRUCT()) {
                $cg->{"struct_vars"}->{$param->{"name"}} = "";
            }
            $i = $i + 1;
        }
        emit($cg, "\n\n");
    }
}

# Generate async function (creates inner closure + outer wrapper)
func gen_async_function(scalar $cg, scalar $fn) void {
    my str $name = sanitize_name($fn->{"name"});
    my str $inner_name = "__async_" . $name . "_inner";
    my scalar $params = $fn->{"params"};
    my int $param_count = $fn->{"param_count"};

    # Private functions get static prefix
    my str $static_prefix = "";
    if ($fn->{"is_private"} == 1) {
        $static_prefix = "static ";
    }

    # --- Generate inner closure function ---
    emit($cg, "/* Async inner: " . $name . " */\n");
    emit($cg, "static StradaValue* " . $inner_name . "(StradaValue ***__captures) {\n");

    # Unpack captured parameters
    my int $i = 0;
    while ($i < $param_count) {
        my scalar $p = $params->[$i];
        my str $pname = escape_c_keyword($p->{"name"});
        emit($cg, "    StradaValue *" . $pname . " = (*__captures[" . $i . "]);\n");
        $i = $i + 1;
    }
    if ($param_count > 0) {
        emit($cg, "\n");
    }

    # Generate body
    scope_push($cg);
    my scalar $body = $fn->{"body"};
    my scalar $stmts = $body->{"statements"};
    my int $stmt_i = 0;
    while ($stmt_i < $body->{"statement_count"}) {
        gen_statement($cg, $stmts->[$stmt_i]);
        $stmt_i = $stmt_i + 1;
    }
    scope_pop($cg);

    emit($cg, "    return strada_undef_static();\n");
    emit($cg, "}\n\n");

    # --- Generate outer wrapper ---
    emit($cg, "/* Async wrapper: " . $name . " */\n");
    emit($cg, $static_prefix . "StradaValue* " . $name . "(");
    $i = 0;
    while ($i < $param_count) {
        if ($i > 0) { emit($cg, ", "); }
        my scalar $p = $params->[$i];
        my str $c_param_name = escape_c_keyword($p->{"name"});
        my int $ptype = $p->{"param_type"};
        if ($ptype == TYPE_STRUCT()) {
            emit($cg, $p->{"type_name"} . " *" . $c_param_name);
        } else {
            emit($cg, type_to_c($ptype) . " " . $c_param_name);
        }
        $i = $i + 1;
    }
    if ($param_count == 0) { emit($cg, "void"); }
    emit($cg, ") {\n");

    # Build closure with captures
    if ($param_count > 0) {
        emit($cg, "    StradaValue *__closure = strada_closure_new((void*)&" . $inner_name);
        emit($cg, ", 0, " . $param_count . ", (StradaValue**[]){");
        $i = 0;
        while ($i < $param_count) {
            if ($i > 0) { emit($cg, ", "); }
            my str $c_param_name = escape_c_keyword($params->[$i]->{"name"});
            emit($cg, "&" . $c_param_name);
            $i = $i + 1;
        }
        emit($cg, "});\n");
    } else {
        emit($cg, "    StradaValue *__closure = strada_closure_new((void*)&" . $inner_name);
        emit($cg, ", 0, 0, NULL);\n");
    }

    emit($cg, "    return strada_future_new(__closure);\n");
    emit($cg, "}\n\n");
}

func gen_program(scalar $cg, scalar $program) void {
    # First pass: register all functions for default parameter handling
    my scalar $funcs = $program->{"functions"};
    my int $i = 0;
    my int $reg = 0;
    while ($reg < $program->{"function_count"}) {
        codegen_register_function($cg, $funcs->[$reg]);
        $reg = $reg + 1;
    }
    
    # Store package name in codegen context for later use
    $cg->{"package"} = $program->{"package"};

    # Store inherits in codegen context for later use
    $cg->{"inherits"} = $program->{"inherits"};
    $cg->{"inherit_count"} = $program->{"inherit_count"};

    # Header
    emit($cg, "/* Generated by Strada Self-Hosting Compiler */\n");

    # Package name
    if ($program->{"package"} ne "") {
        emit($cg, "/* Package: " . $program->{"package"} . " */\n");
    }
    
    emit($cg, "#include \"strada_runtime.h\"\n");
    emit($cg, "#include <string.h>\n");
    emit($cg, "#include <stdint.h>\n");
    emit($cg, "#include <stdbool.h>\n");
    emit($cg, "#include <dlfcn.h>\n");
    emit($cg, "#include <math.h>\n\n");

    # Emit top-level C blocks (includes, typedefs, etc.)
    my int $c_block_count = $program->{"c_block_count"};
    if ($c_block_count > 0) {
        emit($cg, "/* Top-level C code blocks */\n");
        my scalar $c_blocks = $program->{"c_blocks"};
        my int $cb = 0;
        while ($cb < $c_block_count) {
            emit($cg, $c_blocks->[$cb]);
            emit($cg, "\n");
            $cb = $cb + 1;
        }
        emit($cg, "\n");
    }

    # Check if there's a main function
    my int $has_main = 0;
    $i = 0;
    while ($i < $program->{"function_count"}) {
        if ($funcs->[$i]->{"name"} eq "main") {
            $has_main = 1;
            last;
        }
        $i = $i + 1;
    }
    
    # Global ARGV and ARGC (only for files with main)
    if ($has_main == 1) {
        emit($cg, "/* Global command-line argument variables */\n");
        emit($cg, "StradaValue *ARGV = NULL;\n");
        emit($cg, "StradaValue *ARGC = NULL;\n\n");
    } else {
        emit($cg, "/* External globals from main module */\n");
        emit($cg, "extern StradaValue *ARGV;\n");
        emit($cg, "extern StradaValue *ARGC;\n\n");
    }

    # Emit global variable declarations
    my int $global_count = $program->{"global_count"};
    if ($global_count > 0) {
        my scalar $globals = $program->{"globals"};
        emit($cg, "/* Global variables */\n");
        my int $g = 0;
        while ($g < $global_count) {
            my scalar $gvar = $globals->[$g];
            my int $var_type = $gvar->{"var_type"};
            my str $name = $gvar->{"name"};

            if ($var_type == TYPE_STRUCT()) {
                my str $type_name = $gvar->{"type_name"};
                emit($cg, $type_name . " *" . $name . " = NULL;\n");
            } else {
                emit($cg, "StradaValue *" . $name . " = NULL;\n");
            }
            $g = $g + 1;
        }
        emit($cg, "\n");
    }

    # Store globals in codegen context for initialization in main
    $cg->{"globals"} = $program->{"globals"};
    $cg->{"global_count"} = $program->{"global_count"};

    # Build struct definitions map for later use (function pointer detection)
    my scalar $structs = $program->{"structs"};
    my int $s = 0;
    while ($s < $program->{"struct_count"}) {
        my scalar $st = $structs->[$s];
        my str $struct_name = $st->{"name"};
        my hash %struct_info = ();
        $struct_info{"fields"} = {};

        my scalar $fields = $st->{"fields"};
        my array @field_names = ();
        my int $f = 0;
        while ($f < $st->{"field_count"}) {
            my scalar $field = $fields->[$f];
            my int $ftype = $field->{"field_type"};
            my str $fname = $field->{"name"};
            my hash %field_info = ();
            $field_info{"is_funcptr"} = $ftype == TYPE_FUNCPTR();
            $field_info{"funcptr_return"} = $field->{"funcptr_return"};
            $field_info{"field_type"} = $ftype;
            $struct_info{"fields"}->{$fname} = \%field_info;
            push(@field_names, $fname);
            $f = $f + 1;
        }
        $struct_info{"field_names"} = \@field_names;
        $struct_info{"field_count"} = $st->{"field_count"};
        $cg->{"struct_defs"}->{$struct_name} = \%struct_info;
        $s = $s + 1;
    }

    # Generate struct definitions
    $s = 0;
    while ($s < $program->{"struct_count"}) {
        my scalar $st = $structs->[$s];
        emit($cg, "typedef struct {\n");

        my scalar $fields = $st->{"fields"};
        my int $f = 0;
        while ($f < $st->{"field_count"}) {
            my scalar $field = $fields->[$f];
            my int $ftype = $field->{"field_type"};

            if ($ftype == TYPE_FUNCPTR()) {
                # Function pointer field - generate as void pointer for now
                # In a full implementation, we'd track the exact signature
                emit($cg, "    void *" . $field->{"name"} . ";\n");
            } else {
                emit($cg, "    StradaValue *" . $field->{"name"} . ";\n");
            }
            $f = $f + 1;
        }

        emit($cg, "} " . $st->{"name"} . ";\n\n");
        $s = $s + 1;
    }

    # Generate enum definitions
    my scalar $enums = $program->{"enums"};
    my int $e = 0;
    while ($e < $program->{"enum_count"}) {
        my scalar $en = $enums->[$e];
        my str $enum_name = $en->{"name"};

        emit($cg, "/* enum " . $enum_name . " */\n");

        # Generate #define constants for enum values
        # This allows Color::RED to be used (converted to Color_RED by parser)
        my scalar $members = $en->{"members"};
        my int $m = 0;
        while ($m < $en->{"member_count"}) {
            my scalar $member = $members->[$m];
            my str $member_name = $member->{"name"};
            my int $member_value = $member->{"value"};
            emit($cg, "#define " . $enum_name . "_" . $member_name . " " . $member_value . "\n");
            $m = $m + 1;
        }
        emit($cg, "\n");
        $e = $e + 1;
    }

    # Generate extern declarations for imported functions
    my int $imp_count = $program->{"import_count"};
    if ($imp_count > 0) {
        emit($cg, "/* Imported function declarations */\n");
        my scalar $imports = $program->{"imports"};
        my int $imp = 0;
        while ($imp < $imp_count) {
            my str $imp_name = $imports->[$imp];
            # Generate generic extern declaration (assume StradaValue* return and variadic params)
            emit($cg, "extern StradaValue* " . $imp_name . "();\n");
            $imp = $imp + 1;
        }
        emit($cg, "\n");
    }
    
    # Generate extern declarations for qualified module function calls
    my int $use_count = $program->{"use_count"};
    if ($use_count > 0) {
        my scalar $uses = $program->{"uses"};
        my int $u = 0;
        while ($u < $use_count) {
            my str $mod_name = $uses->[$u];
            # Skip "lib" pseudo-module
            if ($mod_name ne "lib") {
                # Convert :: to __ for C identifier prefix
                my str $prefix = "";
                my int $p = 0;
                my int $plen = length($mod_name);
                while ($p < $plen) {
                    my str $ch = substr($mod_name, $p, 1);
                    if ($ch eq ":") {
                        $prefix = $prefix . "_";
                    } else {
                        $prefix = $prefix . $ch;
                    }
                    $p = $p + 1;
                }
                $prefix = $prefix . "__";
                
                # Generate extern declarations for imported funcs with qualified names
                emit($cg, "/* Qualified imports from " . $mod_name . " */\n");
                my scalar $imports = $program->{"imports"};
                my int $imp = 0;
                while ($imp < $program->{"import_count"}) {
                    my str $imp_name = $imports->[$imp];
                    emit($cg, "extern StradaValue* " . $prefix . $imp_name . "();\n");
                    $imp = $imp + 1;
                }
                emit($cg, "\n");
            }
            $u = $u + 1;
        }
    }

    # Generate import_lib wrapper infrastructure
    my int $import_lib_count = $program->{"import_lib_count"};
    if ($import_lib_count > 0) {
        my scalar $import_libs = $program->{"import_libs"};

        emit($cg, "/* import_lib: static library handles and function pointers */\n");

        my int $lib_idx = 0;
        while ($lib_idx < $import_lib_count) {
            my scalar $lib_info = $import_libs->[$lib_idx];
            my str $lib_name = $lib_info->{"lib_name"};
            my str $safe_lib = sanitize_name($lib_name);

            # Static handle for the library
            emit($cg, "static void *__import_lib_" . $safe_lib . "_handle = NULL;\n");

            # Static function pointers for each function
            my scalar $lib_funcs = $lib_info->{"functions"};
            my int $fn_idx = 0;
            my int $fn_count = $lib_info->{"function_count"};
            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $lib_funcs->[$fn_idx];
                my str $fn_name = sanitize_name($fn_info->{"name"});
                emit($cg, "static void *__import_lib_" . $safe_lib . "_fn_" . $fn_name . " = NULL;\n");
                $fn_idx = $fn_idx + 1;
            }

            $lib_idx = $lib_idx + 1;
        }
        emit($cg, "\n");

        # Forward declarations for wrapper functions
        emit($cg, "/* import_lib: wrapper function forward declarations */\n");
        $lib_idx = 0;
        while ($lib_idx < $import_lib_count) {
            my scalar $lib_info = $import_libs->[$lib_idx];
            my scalar $lib_funcs = $lib_info->{"functions"};
            my int $fn_idx = 0;
            my int $fn_count = $lib_info->{"function_count"};

            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $lib_funcs->[$fn_idx];
                my str $fn_name = sanitize_name($fn_info->{"name"});
                my int $ret_type = $fn_info->{"return_type"};
                my int $param_count = $fn_info->{"param_count"};
                my scalar $params = $fn_info->{"params"};

                emit($cg, type_to_c($ret_type) . " " . $fn_name . "(");

                my int $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$p];
                    my int $ptype = $param->{"param_type"};
                    emit($cg, type_to_c($ptype) . " " . escape_c_keyword($param->{"name"}));
                    $p = $p + 1;
                }

                if ($param_count == 0) {
                    emit($cg, "void");
                }

                emit($cg, ");\n");

                # Register in functions context so calls work correctly
                my hash %func_info = ();
                $func_info{"name"} = $fn_name;
                $func_info{"return_type"} = $ret_type;
                $func_info{"param_count"} = $param_count;
                $func_info{"params"} = $params;
                $func_info{"is_import_lib"} = 1;
                $func_info{"is_variadic"} = $fn_info->{"is_variadic"};
                $func_info{"variadic_param_idx"} = $fn_info->{"variadic_param_idx"};
                $cg->{"functions"}->{$fn_name} = \%func_info;

                $fn_idx = $fn_idx + 1;
            }

            $lib_idx = $lib_idx + 1;
        }
        emit($cg, "\n");
    }

    # Generate import_object extern declarations (for statically linked object files)
    my int $import_object_count = $program->{"import_object_count"};
    if ($import_object_count > 0) {
        my scalar $import_objects = $program->{"import_objects"};

        emit($cg, "/* import_object: extern declarations for statically linked functions */\n");
        my int $obj_idx = 0;
        while ($obj_idx < $import_object_count) {
            my scalar $obj_info = $import_objects->[$obj_idx];
            my str $obj_name = $obj_info->{"obj_name"};
            my scalar $functions = $obj_info->{"functions"};
            my int $fn_count = $obj_info->{"function_count"};

            emit($cg, "/* Functions from " . $obj_name . ".o */\n");

            my int $fn_idx = 0;
            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $functions->[$fn_idx];
                my str $fn_name = $fn_info->{"name"};
                my int $ret_type = $fn_info->{"return_type"};
                my int $param_count = $fn_info->{"param_count"};
                my scalar $params = $fn_info->{"params"};

                # Generate extern declaration
                emit($cg, "extern " . type_to_c($ret_type) . " " . $fn_name . "(");

                my int $pi = 0;
                while ($pi < $param_count) {
                    if ($pi > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$pi];
                    my int $ptype = $param->{"type"};
                    emit($cg, type_to_c($ptype));
                    $pi = $pi + 1;
                }
                if ($param_count == 0) {
                    emit($cg, "void");
                }
                emit($cg, ");\n");

                # Register in functions context so calls work
                my hash %func_info = ();
                $func_info{"name"} = $fn_name;
                $func_info{"return_type"} = $ret_type;
                $func_info{"param_count"} = $param_count;
                $func_info{"params"} = $params;
                $func_info{"is_import_object"} = 1;
                $func_info{"is_variadic"} = $fn_info->{"is_variadic"};
                $func_info{"variadic_param_idx"} = $fn_info->{"variadic_param_idx"};
                $cg->{"functions"}->{$fn_name} = \%func_info;

                $fn_idx = $fn_idx + 1;
            }

            $obj_idx = $obj_idx + 1;
        }
        emit($cg, "\n");
    }

    # Generate import_archive extern declarations (for statically linked archive files)
    my int $import_archive_count = $program->{"import_archive_count"};
    if ($import_archive_count > 0) {
        my scalar $import_archives = $program->{"import_archives"};

        emit($cg, "/* import_archive: extern declarations for statically linked functions */\n");
        my int $arch_idx = 0;
        while ($arch_idx < $import_archive_count) {
            my scalar $arch_info = $import_archives->[$arch_idx];
            my str $arch_name = $arch_info->{"lib_name"};
            my scalar $functions = $arch_info->{"functions"};
            my int $fn_count = $arch_info->{"function_count"};

            emit($cg, "/* Functions from " . $arch_name . ".a */\n");

            my int $fn_idx = 0;
            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $functions->[$fn_idx];
                my str $fn_name = $fn_info->{"name"};
                my int $ret_type = $fn_info->{"return_type"};
                my int $param_count = $fn_info->{"param_count"};
                my scalar $params = $fn_info->{"params"};

                # Generate extern declaration
                emit($cg, "extern " . type_to_c($ret_type) . " " . $fn_name . "(");

                my int $pi = 0;
                while ($pi < $param_count) {
                    if ($pi > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$pi];
                    my int $ptype = $param->{"type"};
                    emit($cg, type_to_c($ptype));
                    $pi = $pi + 1;
                }
                if ($param_count == 0) {
                    emit($cg, "void");
                }
                emit($cg, ");\n");

                # Register in functions context so calls work
                my hash %func_info = ();
                $func_info{"name"} = $fn_name;
                $func_info{"return_type"} = $ret_type;
                $func_info{"param_count"} = $param_count;
                $func_info{"params"} = $params;
                $func_info{"is_import_archive"} = 1;
                $func_info{"is_variadic"} = $fn_info->{"is_variadic"};
                $func_info{"variadic_param_idx"} = $fn_info->{"variadic_param_idx"};
                $cg->{"functions"}->{$fn_name} = \%func_info;

                $fn_idx = $fn_idx + 1;
            }

            $arch_idx = $arch_idx + 1;
        }
        emit($cg, "\n");
    }

    # Forward declarations
    $i = 0;
    while ($i < $program->{"function_count"}) {
        my scalar $fn = $funcs->[$i];
        my str $name = sanitize_name($fn->{"name"});
        my int $fn_type = $fn->{"type"};

        # Skip extern functions (they're declared elsewhere)
        if ($fn_type == NODE_EXTERN_FUNC()) {
            # Generate extern declaration
            emit($cg, "extern ");
            gen_extern_decl($cg, $fn);
            $i = $i + 1;
            next;
        }

        if ($name eq "main") {
            emit($cg, "int main(int _argc, char **_argv);\n");
        } else {
            # Private functions get static prefix
            my str $static_prefix = "";
            if ($fn->{"is_private"} == 1) {
                $static_prefix = "static ";
            }
            emit($cg, $static_prefix . type_to_c($fn->{"return_type"}) . " " . $name . "(");
            
            my scalar $params = $fn->{"params"};
            my int $j = 0;
            while ($j < $fn->{"param_count"}) {
                if ($j > 0) {
                    emit($cg, ", ");
                }
                my scalar $param = $params->[$j];
                my int $ptype = $param->{"param_type"};
                my str $c_pname = escape_c_keyword($param->{"name"});
                if ($ptype == TYPE_STRUCT()) {
                    emit($cg, $param->{"type_name"} . " *" . $c_pname);
                } else {
                    emit($cg, type_to_c($ptype) . " " . $c_pname);
                }
                $j = $j + 1;
            }

            if ($fn->{"param_count"} == 0) {
                emit($cg, "void");
            }

            emit($cg, ");\n");
        }
        $i = $i + 1;
    }

    # NOTE: OOP init forward declarations are generated after methods are tracked
    # and stored in oop_fwd_decls for insertion in get_output()

    emit($cg, "\n");

    # Save preamble content and start fresh for function definitions
    $cg->{"preamble_content"} = sb_to_string($cg->{"output_sb"});
    sb_clear($cg->{"output_sb"});

    # Function definitions (skip extern declarations without bodies)
    $i = 0;
    while ($i < $program->{"function_count"}) {
        my scalar $fn = $funcs->[$i];
        my int $fn_type = $fn->{"type"};

        if ($fn_type == NODE_EXTERN_FUNC()) {
            # Extern with body - generate the function
            if ($fn->{"has_body"} == 1) {
                gen_extern_function($cg, $fn);
            }
        } elsif ($fn_type == NODE_ASYNC_FUNC()) {
            gen_async_function($cg, $fn);
        } else {
            gen_function($cg, $fn);
        }

        # Track method for OOP registration using the function's stored package
        # (check package string directly - parser always sets it)
        my str $fn_pkg = $fn->{"package"};
        if (length($fn_pkg) > 0 && $fn_pkg ne "main") {
            codegen_track_method($cg, $fn, $fn_pkg);
        }

        $i = $i + 1;
    }

    # Generate OOP init forward declarations (now that methods are tracked)
    my int $num_fwd_pkgs = get_oop_pkg_count($cg);
    if ($num_fwd_pkgs > 0) {
        my scalar $fwd_pkgs = get_oop_packages($cg);
        my str $fwd_decls = "\n/* OOP method registration forward declarations */\n";
        my int $fwd_i = 0;
        while ($fwd_i < $num_fwd_pkgs) {
            my str $fwd_pkg = $fwd_pkgs->[$fwd_i];
            $fwd_decls = $fwd_decls . "void __" . $fwd_pkg . "_oop_init(void);\n";
            $fwd_i = $fwd_i + 1;
        }
        $cg->{"oop_fwd_decls"} = $fwd_decls;
    }

    # Emit anonymous function definitions
    my str $anon_defs = $cg->{"anon_func_defs"};
    if (length($anon_defs) > 0) {
        emit($cg, "\n/* Anonymous function definitions */\n");
        emit($cg, $anon_defs);
    }

    # Emit OOP method wrappers for all packages
    my str $wrappers = gen_all_method_wrappers($cg);
    if (length($wrappers) > 0) {
        emit($cg, "\n");
        emit($cg, $wrappers);
    }

    # Generate import_lib wrapper function implementations
    if ($import_lib_count > 0) {
        my scalar $import_libs = $program->{"import_libs"};
        emit($cg, "\n/* import_lib: wrapper function implementations */\n");

        my int $lib_idx = 0;
        while ($lib_idx < $import_lib_count) {
            my scalar $lib_info = $import_libs->[$lib_idx];
            my str $lib_name = $lib_info->{"lib_name"};
            my str $safe_lib = sanitize_name($lib_name);
            my str $so_path = $lib_info->{"so_path"};

            my scalar $lib_funcs = $lib_info->{"functions"};
            my int $fn_idx = 0;
            my int $fn_count = $lib_info->{"function_count"};

            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $lib_funcs->[$fn_idx];
                my str $fn_name = sanitize_name($fn_info->{"name"});
                my int $ret_type = $fn_info->{"return_type"};
                my int $param_count = $fn_info->{"param_count"};
                my scalar $params = $fn_info->{"params"};

                # Function signature
                emit($cg, type_to_c($ret_type) . " " . $fn_name . "(");

                my int $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$p];
                    my int $ptype = $param->{"param_type"};
                    emit($cg, type_to_c($ptype) . " " . escape_c_keyword($param->{"name"}));
                    $p = $p + 1;
                }

                if ($param_count == 0) {
                    emit($cg, "void");
                }

                emit($cg, ") {\n");

                # Lazy load the library
                emit($cg, "    if (__import_lib_" . $safe_lib . "_handle == NULL) {\n");
                emit($cg, "        __import_lib_" . $safe_lib . "_handle = dlopen(\"" . $so_path . "\", RTLD_LAZY);\n");
                emit($cg, "        if (__import_lib_" . $safe_lib . "_handle == NULL) {\n");
                emit($cg, "            fprintf(stderr, \"import_lib: failed to load " . $so_path . ": %s\\n\", dlerror());\n");
                emit($cg, "            exit(1);\n");
                emit($cg, "        }\n");
                emit($cg, "    }\n");

                # Lazy lookup the function pointer
                emit($cg, "    if (__import_lib_" . $safe_lib . "_fn_" . $fn_name . " == NULL) {\n");
                emit($cg, "        __import_lib_" . $safe_lib . "_fn_" . $fn_name . " = dlsym(__import_lib_" . $safe_lib . "_handle, \"" . $fn_name . "\");\n");
                emit($cg, "        if (__import_lib_" . $safe_lib . "_fn_" . $fn_name . " == NULL) {\n");
                emit($cg, "            fprintf(stderr, \"import_lib: symbol not found: " . $fn_name . ": %s\\n\", dlerror());\n");
                emit($cg, "            exit(1);\n");
                emit($cg, "        }\n");
                emit($cg, "    }\n");

                # Generate typedef for the function pointer type
                emit($cg, "    typedef " . type_to_c($ret_type) . " (*__fn_type_" . $fn_name . ")(");
                $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    emit($cg, "StradaValue*");
                    $p = $p + 1;
                }
                if ($param_count == 0) {
                    emit($cg, "void");
                }
                emit($cg, ");\n");

                # Cast and call the function directly
                emit($cg, "    __fn_type_" . $fn_name . " __fn = (__fn_type_" . $fn_name . ")__import_lib_" . $safe_lib . "_fn_" . $fn_name . ";\n");
                if ($ret_type == TYPE_VOID()) {
                    emit($cg, "    __fn(");
                } else {
                    emit($cg, "    return __fn(");
                }
                $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$p];
                    emit($cg, escape_c_keyword($param->{"name"}));
                    $p = $p + 1;
                }
                emit($cg, ");\n");

                emit($cg, "}\n\n");
                $fn_idx = $fn_idx + 1;
            }

            $lib_idx = $lib_idx + 1;
        }
    }

    # Generate import_object: object file list comment (for strada wrapper to parse)
    # NOTE: extern declarations are generated earlier with other forward declarations
    my int $io_count = $program->{"import_object_count"};
    if ($io_count > 0) {
        my scalar $io_objs = $program->{"import_objects"};

        # Emit object file list as a comment for strada wrapper to parse
        emit($cg, "\n/* import_object: required object files\n");
        emit($cg, " * __STRADA_OBJECT_FILES__:");
        my int $io_idx = 0;
        while ($io_idx < $io_count) {
            my scalar $io_info = $io_objs->[$io_idx];
            my str $io_path = $io_info->{"o_path"};
            emit($cg, " " . $io_path);
            $io_idx = $io_idx + 1;
        }
        emit($cg, "\n */\n\n");
    }

    # Generate import_archive: archive file list comment (for strada wrapper to parse)
    my int $ia_count = $program->{"import_archive_count"};
    if ($ia_count > 0) {
        my scalar $ia_archs = $program->{"import_archives"};

        # Emit archive file list as a comment for strada wrapper to parse
        emit($cg, "\n/* import_archive: required archive files\n");
        emit($cg, " * __STRADA_ARCHIVE_FILES__:");
        my int $ia_idx = 0;
        while ($ia_idx < $ia_count) {
            my scalar $ia_info = $ia_archs->[$ia_idx];
            my str $ia_path = $ia_info->{"a_path"};
            emit($cg, " " . $ia_path);
            $ia_idx = $ia_idx + 1;
        }
        emit($cg, "\n * __STRADA_SKIP_RUNTIME__: archives include runtime\n");
        emit($cg, " */\n\n");
    }

    # Save funcs content and start fresh for remaining code
    $cg->{"funcs_content"} = sb_to_string($cg->{"output_sb"});
    sb_clear($cg->{"output_sb"});

    # Generate qualified name aliases if package is declared
    my str $pkg_alias = $program->{"package"};
    if ($pkg_alias ne "") {
        # Convert :: to __ for C identifier
        my str $prefix = "";
        my int $p = 0;
        my int $plen = length($pkg_alias);
        while ($p < $plen) {
            my str $ch = substr($pkg_alias, $p, 1);
            if ($ch eq ":") {
                $prefix = $prefix . "_";
            } else {
                $prefix = $prefix . $ch;
            }
            $p = $p + 1;
        }
        $prefix = $prefix . "__";

        emit($cg, "/* Qualified name aliases for package " . $pkg_alias . " */\n");
        $i = 0;
        while ($i < $program->{"function_count"}) {
            my scalar $fn = $funcs->[$i];
            my int $fn_type = $fn->{"type"};
            my str $name = sanitize_name($fn->{"name"});

            # Skip main and extern functions
            if ($name ne "main" && $fn_type != NODE_EXTERN_FUNC()) {
                my str $ret = type_to_c($fn->{"return_type"});
                my str $qname = sanitize_name($prefix . $fn->{"name"});

                # Generate: RetType QualifiedName(params) { return UnqualifiedName(params); }
                emit($cg, $ret . " " . $qname . "(");

                my scalar $params = $fn->{"params"};
                my int $j = 0;
                while ($j < $fn->{"param_count"}) {
                    if ($j > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$j];
                    my int $ptype = $param->{"param_type"};
                    my str $c_pname = escape_c_keyword($param->{"name"});
                    if ($ptype == TYPE_STRUCT()) {
                        emit($cg, $param->{"type_name"} . " *" . $c_pname);
                    } else {
                        emit($cg, type_to_c($ptype) . " " . $c_pname);
                    }
                    $j = $j + 1;
                }
                if ($fn->{"param_count"} == 0) {
                    emit($cg, "void");
                }
                emit($cg, ") { return " . $name . "(");

                $j = 0;
                while ($j < $fn->{"param_count"}) {
                    if ($j > 0) {
                        emit($cg, ", ");
                    }
                    emit($cg, escape_c_keyword($params->[$j]->{"name"}));
                    $j = $j + 1;
                }
                emit($cg, "); }\n");
            }
            $i = $i + 1;
        }
        emit($cg, "\n");
    }

    # Generate __strada_export_info function for shared library metadata
    # This allows import_lib to work without needing the .strada source file
    # Pass has_main flag - for executables (with main), make these static to avoid conflicts
    my int $has_main_fn = 0;
    my int $mi = 0;
    while ($mi < $program->{"function_count"}) {
        if ($funcs->[$mi]->{"name"} eq "main") {
            $has_main_fn = 1;
            last;
        }
        $mi = $mi + 1;
    }
    gen_export_info($cg, $program, $has_main_fn);

    # Generate global initialization constructor for shared libraries (no main)
    if ($has_main_fn == 0) {
        gen_global_constructor($cg);
    }
}

# Generate __strada_export_info function that returns metadata about exported functions
# Format: "func:name:return_type:param_count:param_types:variadic_idx\n" for each function
# variadic_idx: index of variadic param (-1 if not variadic)
# $has_main: if true, make functions static to avoid conflicts when linked with object files
func gen_export_info(scalar $cg, scalar $program, int $has_main) void {
    my str $static_prefix = "";
    if ($has_main == 1) {
        $static_prefix = "static ";
    }
    emit($cg, "\n/* Strada export metadata for import_lib */\n");
    emit($cg, $static_prefix . "const char* __strada_export_info(void) {\n");
    emit($cg, "    return \"");

    my scalar $funcs = $program->{"functions"};
    my int $i = 0;
    my int $count = $program->{"function_count"};

    while ($i < $count) {
        my scalar $fn = $funcs->[$i];
        my str $name = $fn->{"name"};
        my int $fn_type = $fn->{"type"};

        # Skip main function, extern functions, and private functions
        my int $is_private = $fn->{"is_private"};
        if ($name ne "main" && $fn_type != NODE_EXTERN_FUNC() && $is_private != 1) {
            my int $ret_type = $fn->{"return_type"};
            my int $param_count = $fn->{"param_count"};

            # func:name:return_type:param_count:param_types:variadic_idx
            emit($cg, "func:" . sanitize_name($name) . ":" . type_to_export($ret_type) . ":" . $param_count . ":");

            my scalar $params = $fn->{"params"};
            my int $j = 0;
            while ($j < $param_count) {
                if ($j > 0) {
                    emit($cg, ",");
                }
                my scalar $param = $params->[$j];
                emit($cg, type_to_export($param->{"param_type"}));
                $j = $j + 1;
            }

            # Add variadic index
            my int $variadic_idx = -1;
            if ($fn->{"is_variadic"} == 1) {
                my int $k = 0;
                while ($k < $param_count) {
                    if ($params->[$k]->{"is_variadic"} == 1) {
                        $variadic_idx = $k;
                    }
                    $k = $k + 1;
                }
            }
            emit($cg, ":" . $variadic_idx);

            emit($cg, "\\n");
        }
        $i = $i + 1;
    }

    emit($cg, "\";\n");
    emit($cg, "}\n");

    # Also generate version info if specified
    gen_version_info($cg, $program, $has_main);
}

# Generate __strada_version function that returns the module version
func gen_version_info(scalar $cg, scalar $program, int $has_main) void {
    my str $static_prefix = "";
    if ($has_main == 1) {
        $static_prefix = "static ";
    }
    my str $version = "";
    if ($program->{"version"} ne "") {
        $version = $program->{"version"};
    }

    emit($cg, "\n/* Strada module version */\n");
    emit($cg, $static_prefix . "const char* __strada_version(void) {\n");
    emit($cg, "    return \"" . $version . "\";\n");
    emit($cg, "}\n");
}

# Generate global variable initialization constructor for shared libraries
# This runs automatically when the library is loaded (dlopen)
func gen_global_constructor(scalar $cg) void {
    my int $global_count = $cg->{"global_count"};
    if ($global_count == 0) {
        return;
    }

    emit($cg, "\n/* Shared library global initialization */\n");
    emit($cg, "__attribute__((constructor))\n");
    emit($cg, "static void __strada_init_globals(void) {\n");

    my scalar $globals = $cg->{"globals"};
    my int $g = 0;
    while ($g < $global_count) {
        my scalar $gvar = $globals->[$g];
        my int $var_type = $gvar->{"var_type"};
        my str $sigil = $gvar->{"sigil"};
        my str $name = $gvar->{"name"};
        my scalar $init = $gvar->{"init"};

        # Skip if already initialized (non-NULL check for safety)
        emit($cg, "    if (" . $name . " == NULL) {\n");
        emit($cg, "        " . $name . " = ");

        if ($var_type == TYPE_STRUCT()) {
            my str $type_name = $gvar->{"type_name"};
            if ($init) {
                gen_expression($cg, $init);
            } else {
                emit($cg, "malloc(sizeof(" . $type_name . "))");
            }
        } elsif ($sigil eq "%" || $var_type == TYPE_HASH()) {
            if ($init) {
                # Handle empty () which parser returns as anon_hash
                if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                    emit($cg, "strada_new_hash()");
                } else {
                    gen_expression($cg, $init);
                }
            } else {
                emit($cg, "strada_new_hash()");
            }
        } elsif ($sigil eq "@" || $var_type == TYPE_ARRAY()) {
            if ($init) {
                # Handle empty () which parser returns as anon_hash
                if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                    emit($cg, "strada_new_array()");
                } else {
                    gen_expression($cg, $init);
                }
            } else {
                emit($cg, "strada_new_array()");
            }
        } else {
            if ($init) {
                gen_expression($cg, $init);
            } else {
                emit($cg, "strada_new_undef()");
            }
        }
        emit($cg, ";\n");
        emit($cg, "    }\n");
        $g = $g + 1;
    }

    emit($cg, "}\n");
}

# Convert type constant to export string
func type_to_export(int $type) str {
    if ($type == TYPE_INT()) { return "int"; }
    if ($type == TYPE_NUM()) { return "num"; }
    if ($type == TYPE_STR()) { return "str"; }
    if ($type == TYPE_BOOL()) { return "bool"; }
    if ($type == TYPE_ARRAY()) { return "array"; }
    if ($type == TYPE_HASH()) { return "hash"; }
    if ($type == TYPE_SCALAR()) { return "scalar"; }
    if ($type == TYPE_VOID()) { return "void"; }
    # Explicit sized types
    if ($type == TYPE_INT32()) { return "int32"; }
    if ($type == TYPE_INT64()) { return "int64"; }
    if ($type == TYPE_FLOAT32()) { return "float32"; }
    if ($type == TYPE_FLOAT64()) { return "float64"; }
    if ($type == TYPE_INT8()) { return "int8"; }
    if ($type == TYPE_INT16()) { return "int16"; }
    if ($type == TYPE_UINT8()) { return "uint8"; }
    if ($type == TYPE_UINT16()) { return "uint16"; }
    if ($type == TYPE_UINT32()) { return "uint32"; }
    if ($type == TYPE_UINT64()) { return "uint64"; }
    if ($type == TYPE_SIZE_T()) { return "size_t"; }
    if ($type == TYPE_CHAR()) { return "char"; }
    if ($type == TYPE_LONG_DOUBLE()) { return "long_double"; }
    return "scalar";
}

# Generate extern function with body
func gen_extern_function(scalar $cg, scalar $fn) void {
    my str $ret_type = type_to_c_raw($fn->{"return_type"});
    my str $name = sanitize_name($fn->{"name"});

    emit($cg, $ret_type . " " . $name . "(");

    my scalar $params = $fn->{"params"};
    my int $i = 0;
    while ($i < $fn->{"param_count"}) {
        if ($i > 0) {
            emit($cg, ", ");
        }
        my scalar $param = $params->[$i];
        emit($cg, type_to_c_raw($param->{"param_type"}) . " " . escape_c_keyword($param->{"name"}));
        $i = $i + 1;
    }

    if ($fn->{"param_count"} == 0) {
        emit($cg, "void");
    }

    emit($cg, ") ");
    $cg->{"in_extern"} = 1;  # Enable raw C code generation
    # Track extern function parameter types for string interpolation conversion
    # Use escaped names to match variable references
    my hash %extern_params = ();
    my int $p = 0;
    while ($p < $fn->{"param_count"}) {
        my scalar $param = $params->[$p];
        my str $c_pname = escape_c_keyword($param->{"name"});
        $extern_params{$c_pname} = $param->{"param_type"};
        $p = $p + 1;
    }
    $cg->{"extern_params"} = \%extern_params;
    gen_block($cg, $fn->{"body"});
    $cg->{"in_extern"} = 0;  # Disable raw C code generation
    $cg->{"extern_params"} = {};
    emit($cg, "\n\n");
}

# Generate extern function declaration
func gen_extern_decl(scalar $cg, scalar $fn) void {
    my str $ret_type = type_to_c_raw($fn->{"return_type"});
    emit($cg, $ret_type . " " . sanitize_name($fn->{"name"}) . "(");

    my scalar $params = $fn->{"params"};
    my int $i = 0;
    while ($i < $fn->{"param_count"}) {
        if ($i > 0) {
            emit($cg, ", ");
        }
        my scalar $param = $params->[$i];
        emit($cg, type_to_c_raw($param->{"param_type"}) . " " . escape_c_keyword($param->{"name"}));
        $i = $i + 1;
    }

    if ($fn->{"param_count"} == 0) {
        emit($cg, "void");
    }
    
    emit($cg, ");\n");
}

# Convert type to raw C type (for extern functions)
func type_to_c_raw(int $type) str {
    if ($type == TYPE_INT()) { return "int"; }
    if ($type == TYPE_BOOL()) { return "bool"; }
    if ($type == TYPE_NUM()) { return "double"; }
    if ($type == TYPE_STR()) { return "char*"; }
    if ($type == TYPE_VOID()) { return "void"; }
    # Explicit sized types
    if ($type == TYPE_INT32()) { return "int32_t"; }
    if ($type == TYPE_INT64()) { return "int64_t"; }
    if ($type == TYPE_FLOAT32()) { return "float"; }
    if ($type == TYPE_FLOAT64()) { return "double"; }
    if ($type == TYPE_INT8()) { return "int8_t"; }
    if ($type == TYPE_INT16()) { return "int16_t"; }
    if ($type == TYPE_UINT8()) { return "uint8_t"; }
    if ($type == TYPE_UINT16()) { return "uint16_t"; }
    if ($type == TYPE_UINT32()) { return "uint32_t"; }
    if ($type == TYPE_UINT64()) { return "uint64_t"; }
    if ($type == TYPE_SIZE_T()) { return "size_t"; }
    if ($type == TYPE_CHAR()) { return "char"; }
    if ($type == TYPE_LONG_DOUBLE()) { return "long double"; }
    return "void*";
}

# ============================================================
# Main Entry Point
# ============================================================

func generate(scalar $ast, str $filename, int $debug_info, int $enable_profiling) str {
    my scalar $cg = codegen_new($filename, $debug_info, $enable_profiling);
    gen_program($cg, $ast);
    return get_output($cg);  # Join array into final string
}
