# Parser.strada - Recursive Descent Parser for self-hosting Strada compiler
# Converts token stream to AST

# ============================================================
# Parser State
# ============================================================

func parser_new(scalar $tokens) scalar {
    my hash %parser = ();
    $parser{"tokens"} = $tokens;
    $parser{"pos"} = 0;
    $parser{"token_count"} = size($tokens);
    $parser{"filename"} = "";
    return \%parser;
}

func parser_set_filename(scalar $parser, str $filename) void {
    $parser->{"filename"} = $filename;
}

# Format and die with error message including file:line
func parser_error(scalar $parser, str $msg) void {
    my str $filename = $parser->{"filename"};
    my int $line = parser_current_line($parser);
    if (length($filename) > 0) {
        die($filename . ":" . $line . ": " . $msg);
    } else {
        die("line " . $line . ": " . $msg);
    }
}

func parser_current(scalar $parser) scalar {
    my scalar $tokens = $parser->{"tokens"};
    my int $pos = $parser->{"pos"};
    return $tokens->[$pos];
}

func parser_peek(scalar $parser) scalar {
    my scalar $tokens = $parser->{"tokens"};
    my int $pos = $parser->{"pos"} + 1;
    if ($pos >= $parser->{"token_count"}) {
        return parser_current($parser);
    }
    return $tokens->[$pos];
}

func parser_advance(scalar $parser) void {
    if ($parser->{"pos"} < $parser->{"token_count"} - 1) {
        $parser->{"pos"} = $parser->{"pos"} + 1;
    }
}

func parser_expect(scalar $parser, str $expected_type) void {
    my scalar $tok = parser_current($parser);
    if ($tok->{"type"} ne $expected_type) {
        parser_error($parser, "expected " . $expected_type . ", got " . $tok->{"type"});
    }
    parser_advance($parser);
}

func parser_match(scalar $parser, str $type) int {
    my scalar $tok = parser_current($parser);
    if ($tok->{"type"} eq $type) {
        parser_advance($parser);
        return 1;
    }
    return 0;
}

func parser_check(scalar $parser, str $type) int {
    my scalar $tok = parser_current($parser);
    return $tok->{"type"} eq $type;
}

# Get current token's line number
func parser_current_line(scalar $parser) int {
    my scalar $tok = parser_current($parser);
    return $tok->{"line"};
}

# Parse a variable name - allows type keywords as variable names
func parse_var_name(scalar $parser) str {
    my scalar $tok = parser_current($parser);
    my str $type_str = $tok->{"type"};
    
    # Regular identifier
    if ($type_str eq "IDENT") {
        parser_advance($parser);
        return $tok->{"value"};
    }
    
    # Type keywords can be used as variable names ($int, $num, etc.)
    if ($type_str eq "TYPE_INT") {
        parser_advance($parser);
        return "int";
    }
    if ($type_str eq "TYPE_NUM") {
        parser_advance($parser);
        return "num";
    }
    if ($type_str eq "TYPE_STR") {
        parser_advance($parser);
        return "str";
    }
    if ($type_str eq "TYPE_ARRAY") {
        parser_advance($parser);
        return "array";
    }
    if ($type_str eq "TYPE_HASH") {
        parser_advance($parser);
        return "hash";
    }
    if ($type_str eq "TYPE_SCALAR") {
        parser_advance($parser);
        return "scalar";
    }
    if ($type_str eq "TYPE_VOID") {
        parser_advance($parser);
        return "void";
    }

    # Other keywords that can be used as variable names
    if ($type_str eq "VERSION") {
        parser_advance($parser);
        return "version";
    }

    parser_error($parser, "expected variable name, got " . $type_str);
}

# ============================================================
# Type Parsing
# ============================================================

func parse_type(scalar $parser) int {
    my scalar $tok = parser_current($parser);
    my str $type_str = $tok->{"type"};
    
    # Clear last type name
    $parser->{"last_type_name"} = "";
    
    if ($type_str eq "TYPE_INT") {
        parser_advance($parser);
        return TYPE_INT();
    }
    if ($type_str eq "TYPE_NUM") {
        parser_advance($parser);
        return TYPE_NUM();
    }
    if ($type_str eq "TYPE_STR") {
        parser_advance($parser);
        return TYPE_STR();
    }
    if ($type_str eq "TYPE_ARRAY") {
        parser_advance($parser);
        return TYPE_ARRAY();
    }
    if ($type_str eq "TYPE_HASH") {
        parser_advance($parser);
        return TYPE_HASH();
    }
    if ($type_str eq "TYPE_SCALAR") {
        parser_advance($parser);
        return TYPE_SCALAR();
    }
    if ($type_str eq "TYPE_VOID") {
        parser_advance($parser);
        return TYPE_VOID();
    }
    
    # Struct name (IDENT) - return TYPE_STRUCT and store name
    if ($type_str eq "IDENT") {
        $parser->{"last_type_name"} = $tok->{"value"};
        parser_advance($parser);
        return TYPE_STRUCT();
    }
    
    # Function pointer type: func(...) ReturnType
    if ($type_str eq "FUNC") {
        parser_advance($parser);
        parser_expect($parser, "LPAREN");
        # Skip parameter types
        while (!parser_check($parser, "RPAREN")) {
            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
            } else {
                parse_type($parser);  # Parse and discard param type
            }
        }
        parser_expect($parser, "RPAREN");
        parse_type($parser);  # Parse and discard return type
        return TYPE_FUNCPTR();
    }
    
    parser_error($parser, "expected type, got " . $type_str);
}

# ============================================================
# Expression Parsing (Precedence Climbing)
# ============================================================

# Parse anonymous function: func (params) return_type { body }
# Called after 'func' and seeing LPAREN
func parse_anon_func(scalar $parser, int $line) scalar {
    parser_expect($parser, "LPAREN");

    my scalar $anon = ast_new_anon_func(TYPE_SCALAR());

    # Parse parameters
    if (!parser_check($parser, "RPAREN")) {
        # Parse first parameter
        my int $ptype = parse_type($parser);
        my str $sigil = "$";
        my str $pname = "";

        # Check for sigil
        if (parser_check($parser, "DOLLAR")) {
            parser_advance($parser);
            $sigil = "$";
        } elsif (parser_check($parser, "AT")) {
            parser_advance($parser);
            $sigil = "@";
        } elsif (parser_check($parser, "PERCENT")) {
            parser_advance($parser);
            $sigil = "%";
        }

        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $pname = $name_tok->{"value"};

        my scalar $param = ast_new_param($pname, $ptype, $sigil);
        ast_add_param($anon, $param);

        # Parse remaining parameters
        while (parser_check($parser, "COMMA")) {
            parser_advance($parser);

            $ptype = parse_type($parser);
            $sigil = "$";

            if (parser_check($parser, "DOLLAR")) {
                parser_advance($parser);
                $sigil = "$";
            } elsif (parser_check($parser, "AT")) {
                parser_advance($parser);
                $sigil = "@";
            } elsif (parser_check($parser, "PERCENT")) {
                parser_advance($parser);
                $sigil = "%";
            }

            $name_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            $pname = $name_tok->{"value"};

            $param = ast_new_param($pname, $ptype, $sigil);
            ast_add_param($anon, $param);
        }
    }

    parser_expect($parser, "RPAREN");

    # Optional return type
    if (parser_check($parser, "TYPE_INT")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_INT();
    } elsif (parser_check($parser, "TYPE_NUM")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_NUM();
    } elsif (parser_check($parser, "TYPE_STR")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_STR();
    } elsif (parser_check($parser, "TYPE_SCALAR")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_SCALAR();
    } elsif (parser_check($parser, "TYPE_VOID")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_VOID();
    }

    # Parse body
    $anon->{"body"} = parse_block($parser);

    ast_set_line($anon, $line);
    return $anon;
}

# Primary expressions: literals, variables, parenthesized, etc.
func parse_primary(scalar $parser) scalar {
    my scalar $tok = parser_current($parser);
    my str $type = $tok->{"type"};
    
    # Integer literal
    if ($type eq "INT_LITERAL") {
        parser_advance($parser);
        return ast_new_int_literal($tok->{"value"});
    }
    
    # Number literal
    if ($type eq "NUM_LITERAL") {
        parser_advance($parser);
        return ast_new_num_literal($tok->{"value"});
    }
    
    # String literal
    if ($type eq "STR_LITERAL") {
        parser_advance($parser);
        return ast_new_str_literal($tok->{"value"});
    }

    # Interpolated string - build concatenation chain
    if ($type eq "INTERP_STRING") {
        parser_advance($parser);
        my scalar $parts = $tok->{"parts"};
        my scalar $vars = $tok->{"vars"};
        my int $num_vars = $tok->{"var_count"};

        # Start with the first part
        my scalar $result = ast_new_str_literal($parts->[0]);

        # Alternate: variable, then next part
        my int $i = 0;
        while ($i < $num_vars) {
            # Concatenate variable
            my str $vname = $vars->[$i];
            my scalar $var_node = ast_new_variable($vname, "$");
            $result = ast_new_binary_op(".", $result, $var_node);

            # Concatenate next string part
            my scalar $part_node = ast_new_str_literal($parts->[$i + 1]);
            $result = ast_new_binary_op(".", $result, $part_node);

            $i = $i + 1;
        }

        return $result;
    }

    # qw() - quote words, returns anonymous array of strings
    if ($type eq "QW_LITERAL") {
        parser_advance($parser);
        my scalar $words = $tok->{"words"};
        my int $len = $tok->{"word_count"};
        my scalar $arr_node = ast_new_anon_array();
        my int $i = 0;
        while ($i < $len) {
            ast_add_array_elem($arr_node, ast_new_str_literal($words->[$i]));
            $i = $i + 1;
        }
        return $arr_node;
    }

    # undef literal
    if ($type eq "UNDEF") {
        parser_advance($parser);
        return ast_new_undef();
    }

    # __PACKAGE__ - returns current package name
    if ($type eq "DUNDER_PACKAGE") {
        parser_advance($parser);
        return ast_new_dunder_package();
    }

    # __FILE__ - returns current file name
    if ($type eq "DUNDER_FILE") {
        parser_advance($parser);
        return ast_new_dunder_file();
    }

    # __LINE__ - returns current line number
    if ($type eq "DUNDER_LINE") {
        my int $line = parser_current_line($parser);
        parser_advance($parser);
        return ast_new_dunder_line($line);
    }

    # Variable or function call
    if ($type eq "DOLLAR") {
        my int $var_line = parser_current_line($parser);
        parser_advance($parser);

        # Check for $$var or $${expr} scalar dereference syntax
        if (parser_check($parser, "DOLLAR")) {
            parser_advance($parser);

            # Check for $${expr} syntax
            if (parser_check($parser, "LBRACE")) {
                parser_advance($parser);
                my scalar $ref_expr = parse_expression($parser);
                parser_expect($parser, "RBRACE");
                my scalar $deref = ast_new_deref_scalar($ref_expr, "$");
                ast_set_line($deref, $var_line);
                return $deref;
            }

            # Simple $$var syntax
            my str $ref_name = parse_var_name($parser);
            my scalar $ref_var = ast_new_variable($ref_name, "$");
            ast_set_line($ref_var, $var_line);
            my scalar $deref = ast_new_deref_scalar($ref_var, "$");
            ast_set_line($deref, $var_line);
            return $deref;
        }

        my str $var_name = parse_var_name($parser);

        # Check for arrow dereference
        if (parser_check($parser, "ARROW")) {
            my scalar $var = ast_new_variable($var_name, "$");
            ast_set_line($var, $var_line);
            return parse_postfix($parser, $var);
        }

        # Check for hash access $var{key} - Perl style: accesses %var
        if (parser_check($parser, "LBRACE")) {
            parser_advance($parser);
            my scalar $key = parse_expression($parser);
            parser_expect($parser, "RBRACE");
            my scalar $var = ast_new_variable($var_name, "%");
            ast_set_line($var, $var_line);
            my scalar $access = ast_new_hash_access($var, $key);
            ast_set_line($access, $var_line);
            return $access;
        }

        # Check for array access $var[idx] - Perl style: accesses @var
        if (parser_check($parser, "LBRACKET")) {
            parser_advance($parser);
            my scalar $idx = parse_expression($parser);
            parser_expect($parser, "RBRACKET");
            my scalar $var = ast_new_variable($var_name, "@");
            ast_set_line($var, $var_line);
            my scalar $sub = ast_new_subscript($var, $idx);
            ast_set_line($sub, $var_line);
            return $sub;
        }

        my scalar $var = ast_new_variable($var_name, "$");
        ast_set_line($var, $var_line);
        return $var;
    }

    # Array variable or @{expr} dereference
    if ($type eq "AT") {
        my int $var_line = parser_current_line($parser);
        parser_advance($parser);

        # Check for @{expr} dereference syntax
        if (parser_check($parser, "LBRACE")) {
            parser_advance($parser);
            my scalar $ref_expr = parse_expression($parser);
            parser_expect($parser, "RBRACE");
            my scalar $deref = ast_new_deref_scalar($ref_expr, "@");
            ast_set_line($deref, $var_line);
            return $deref;
        }

        my str $arr_name = parse_var_name($parser);
        my scalar $var = ast_new_variable($arr_name, "@");
        ast_set_line($var, $var_line);
        return $var;
    }

    # Hash variable or %{expr} dereference
    if ($type eq "PERCENT") {
        my int $var_line = parser_current_line($parser);
        parser_advance($parser);

        # Check for %{expr} dereference syntax
        if (parser_check($parser, "LBRACE")) {
            parser_advance($parser);
            my scalar $ref_expr = parse_expression($parser);
            parser_expect($parser, "RBRACE");
            my scalar $deref = ast_new_deref_scalar($ref_expr, "%");
            ast_set_line($deref, $var_line);
            return $deref;
        }

        my str $hash_name = parse_var_name($parser);
        my scalar $var = ast_new_variable($hash_name, "%");
        ast_set_line($var, $var_line);
        return $var;
    }
    
    # Reference operator
    if ($type eq "BACKSLASH") {
        parser_advance($parser);
        my scalar $target = parse_primary($parser);

        # Determine reference type from target
        my str $ref_type = "$";
        if ($target->{"type"} == NODE_VARIABLE()) {
            $ref_type = $target->{"sigil"};
        } elsif ($target->{"type"} == NODE_FUNC_REF()) {
            $ref_type = "&";
        }

        return ast_new_ref($target, $ref_type);
    }
    
    # Anonymous hash { }
    if ($type eq "LBRACE") {
        parser_advance($parser);
        my scalar $anon = ast_new_anon_hash();
        
        # Empty hash check
        if (parser_check($parser, "RBRACE")) {
            parser_advance($parser);
            return $anon;
        }
        
        # Parse key => value pairs
        while (1) {
            # Key (string or bareword)
            my scalar $key_tok = parser_current($parser);
            my str $key = "";
            
            if ($key_tok->{"type"} eq "STR_LITERAL" || $key_tok->{"type"} eq "IDENT") {
                $key = $key_tok->{"value"};
                parser_advance($parser);
            } else {
                parser_error($parser, "expected hash key");
            }
            
            parser_expect($parser, "FAT_ARROW");
            
            my scalar $value = parse_expression($parser);
            ast_add_hash_pair($anon, $key, $value);
            
            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
                if (parser_check($parser, "RBRACE")) {
                    parser_advance($parser);
                    return $anon;
                }
            } else {
                parser_expect($parser, "RBRACE");
                return $anon;
            }
        }
    }
    
    # Anonymous array [ ]
    if ($type eq "LBRACKET") {
        parser_advance($parser);
        my scalar $anon = ast_new_anon_array();
        
        # Empty array check
        if (parser_check($parser, "RBRACKET")) {
            parser_advance($parser);
            return $anon;
        }
        
        # Parse elements
        while (1) {
            my scalar $elem = parse_expression($parser);
            ast_add_array_elem($anon, $elem);
            
            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
                if (parser_check($parser, "RBRACKET")) {
                    parser_advance($parser);
                    return $anon;
                }
            } else {
                parser_expect($parser, "RBRACKET");
                return $anon;
            }
        }
    }
    
    # Parenthesized expression, array literal (1, 2, 3), or empty ()
    if ($type eq "LPAREN") {
        parser_advance($parser);
        
        # Empty () - returns empty hash/array depending on context
        if (parser_check($parser, "RPAREN")) {
            parser_advance($parser);
            return ast_new_anon_hash();
        }
        
        my scalar $first = parse_expression($parser);
        
        # Check if this is an array literal (has comma)
        if (parser_check($parser, "COMMA")) {
            my scalar $arr = ast_new_anon_array();
            ast_add_array_elem($arr, $first);
            
            while (parser_check($parser, "COMMA")) {
                parser_advance($parser);
                if (parser_check($parser, "RPAREN")) {
                    # Trailing comma allowed
                    last;
                }
                my scalar $elem = parse_expression($parser);
                ast_add_array_elem($arr, $elem);
            }
            parser_expect($parser, "RPAREN");
            return $arr;
        }
        
        # Single expression in parens
        parser_expect($parser, "RPAREN");
        return $first;
    }
    
    # Function call (bareword)
    if ($type eq "IDENT") {
        my str $name = $tok->{"value"};
        my int $call_line = $tok->{"line"};
        parser_advance($parser);

        # Check for function call
        if (parser_check($parser, "LPAREN")) {
            parser_advance($parser);
            my scalar $call = ast_new_call($name);
            ast_set_line($call, $call_line);

            # Parse arguments
            if (!parser_check($parser, "RPAREN")) {
                my scalar $arg = parse_expression($parser);
                ast_add_arg($call, $arg);

                while (parser_check($parser, "COMMA")) {
                    parser_advance($parser);
                    my scalar $next_arg = parse_expression($parser);
                    ast_add_arg($call, $next_arg);
                }
            }

            parser_expect($parser, "RPAREN");
            return $call;
        }

        # Check for SUPER::method() call
        if ($name eq "SUPER" && parser_check($parser, "DOUBLE_COLON")) {
            parser_advance($parser);
            my scalar $method_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            my str $method_name = $method_tok->{"value"};

            # SUPER::method must be followed by ()
            if (!parser_check($parser, "LPAREN")) {
                parser_error($parser, "expected ( after SUPER::" . $method_name);
            }
            parser_advance($parser);
            my scalar $super_call = ast_new_super_call($method_name);
            ast_set_line($super_call, $call_line);

            # Parse arguments
            if (!parser_check($parser, "RPAREN")) {
                my scalar $arg = parse_expression($parser);
                ast_add_arg($super_call, $arg);

                while (parser_check($parser, "COMMA")) {
                    parser_advance($parser);
                    my scalar $next_arg = parse_expression($parser);
                    ast_add_arg($super_call, $next_arg);
                }
            }

            parser_expect($parser, "RPAREN");
            return $super_call;
        }

        # Check for qualified name (Package::func)
        if (parser_check($parser, "DOUBLE_COLON")) {
            while (parser_check($parser, "DOUBLE_COLON")) {
                parser_advance($parser);
                my scalar $next_tok = parser_current($parser);
                parser_expect($parser, "IDENT");
                $name = $name . "::" . $next_tok->{"value"};
            }

            # Check for function call
            if (parser_check($parser, "LPAREN")) {
                parser_advance($parser);
                my scalar $call = ast_new_call($name);
                ast_set_line($call, $call_line);

                if (!parser_check($parser, "RPAREN")) {
                    my scalar $arg = parse_expression($parser);
                    ast_add_arg($call, $arg);

                    while (parser_check($parser, "COMMA")) {
                        parser_advance($parser);
                        my scalar $next_arg = parse_expression($parser);
                        ast_add_arg($call, $next_arg);
                    }
                }

                parser_expect($parser, "RPAREN");
                return $call;
            }

            # Just a qualified name
            return ast_new_str_literal($name);
        }

        # Just an identifier (bareword string in some contexts)
        return ast_new_str_literal($name);
    }

    # inherit() function call when used inside a function body
    if ($type eq "INHERIT") {
        my int $call_line = parser_current_line($parser);
        parser_advance($parser);
        if (parser_check($parser, "LPAREN")) {
            parser_advance($parser);
            my scalar $call = ast_new_call("inherit");
            ast_set_line($call, $call_line);
            if (!parser_check($parser, "RPAREN")) {
                my scalar $arg = parse_expression($parser);
                ast_add_arg($call, $arg);
                while (parser_check($parser, "COMMA")) {
                    parser_advance($parser);
                    my scalar $next_arg = parse_expression($parser);
                    ast_add_arg($call, $next_arg);
                }
            }
            parser_expect($parser, "RPAREN");
            return $call;
        }
        parser_error($parser, "expected ( after inherit");
    }

    # scalar() function - TYPE_SCALAR followed by (
    if ($type eq "TYPE_SCALAR") {
        my int $call_line = parser_current_line($parser);
        parser_advance($parser);
        if (parser_check($parser, "LPAREN")) {
            parser_advance($parser);
            my scalar $call = ast_new_call("scalar");
            ast_set_line($call, $call_line);
            if (!parser_check($parser, "RPAREN")) {
                my scalar $arg = parse_expression($parser);
                ast_add_arg($call, $arg);
            }
            parser_expect($parser, "RPAREN");
            return $call;
        }
        parser_error($parser, "unexpected TYPE_SCALAR in expression");
    }
    
    # Unary minus
    if ($type eq "MINUS") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_unary_op("-", $operand);
    }
    
    # Logical not
    if ($type eq "NOT") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_unary_op("!", $operand);
    }
    
    # Function reference (&func_name)
    if ($type eq "AMPERSAND") {
        parser_advance($parser);
        my scalar $func_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        return ast_new_func_ref($func_tok->{"value"});
    }

    # map { block } @array - transforms each element using $_
    if ($type eq "MAP") {
        my int $map_line = parser_current_line($parser);
        parser_advance($parser);
        parser_expect($parser, "LBRACE");
        my scalar $block = ast_new_block();

        # Parse block body - can be multiple statements or a single expression
        while (!parser_check($parser, "RBRACE") && !parser_check($parser, "EOF")) {
            my scalar $stmt = parse_statement($parser);
            ast_add_statement($block, $stmt);
        }
        parser_expect($parser, "RBRACE");

        # Parse the array expression
        my scalar $array_expr = parse_unary($parser);
        my scalar $map_node = ast_new_map($block, $array_expr);
        ast_set_line($map_node, $map_line);
        return $map_node;
    }

    # sort { $a <=> $b } @array - sorts array using comparator block
    if ($type eq "SORT") {
        my int $sort_line = parser_current_line($parser);
        parser_advance($parser);

        # Check if there's a block or just an array (default sort)
        if (parser_check($parser, "LBRACE")) {
            parser_advance($parser);
            my scalar $block = ast_new_block();

            # Parse block body
            while (!parser_check($parser, "RBRACE") && !parser_check($parser, "EOF")) {
                my scalar $stmt = parse_statement($parser);
                ast_add_statement($block, $stmt);
            }
            parser_expect($parser, "RBRACE");

            # Parse the array expression
            my scalar $array_expr = parse_unary($parser);
            my scalar $sort_node = ast_new_sort($block, $array_expr);
            ast_set_line($sort_node, $sort_line);
            return $sort_node;
        } else {
            # Default sort (no block) - use empty block
            my scalar $array_expr = parse_unary($parser);
            my scalar $sort_node = ast_new_sort(0, $array_expr);
            ast_set_line($sort_node, $sort_line);
            return $sort_node;
        }
    }

    # grep { block } @array - filters array elements using $_
    if ($type eq "GREP") {
        my int $grep_line = parser_current_line($parser);
        parser_advance($parser);
        parser_expect($parser, "LBRACE");
        my scalar $block = ast_new_block();

        # Parse block body
        while (!parser_check($parser, "RBRACE") && !parser_check($parser, "EOF")) {
            my scalar $stmt = parse_statement($parser);
            ast_add_statement($block, $stmt);
        }
        parser_expect($parser, "RBRACE");

        # Parse the array expression
        my scalar $array_expr = parse_unary($parser);
        my scalar $grep_node = ast_new_grep($block, $array_expr);
        ast_set_line($grep_node, $grep_line);
        return $grep_node;
    }

    # Anonymous function: func (params) { body }
    if ($type eq "FUNC") {
        my int $anon_line = parser_current_line($parser);
        parser_advance($parser);  # Skip 'func'

        # Check for LPAREN - if present, this is an anonymous function
        if (parser_check($parser, "LPAREN")) {
            return parse_anon_func($parser, $anon_line);
        }
        # Otherwise it's a parse error (named func should be at statement level)
        parser_error($parser, "unexpected 'func' in expression context");
    }

    parser_error($parser, "unexpected token in expression: " . $type);
}

# Parse postfix operations (-> derefs, function calls, subscripts)
func parse_postfix(scalar $parser, scalar $left) scalar {
    while (1) {
        if (parser_check($parser, "ARROW")) {
            parser_advance($parser);

            # Closure call ->(args)
            if (parser_check($parser, "LPAREN")) {
                parser_advance($parser);
                my array @args = ();
                my int $arg_count = 0;

                # Parse arguments
                if (!parser_check($parser, "RPAREN")) {
                    push(@args, parse_expression($parser));
                    $arg_count = $arg_count + 1;

                    while (parser_check($parser, "COMMA")) {
                        parser_advance($parser);
                        push(@args, parse_expression($parser));
                        $arg_count = $arg_count + 1;
                    }
                }
                parser_expect($parser, "RPAREN");
                $left = ast_new_closure_call($left, \@args, $arg_count);
            }
            # Hash dereference ->{key}
            elsif (parser_check($parser, "LBRACE")) {
                parser_advance($parser);
                my scalar $key = parse_expression($parser);
                parser_expect($parser, "RBRACE");
                $left = ast_new_deref_hash($left, $key);
            }
            # Array dereference ->[idx]
            elsif (parser_check($parser, "LBRACKET")) {
                parser_advance($parser);
                my scalar $idx = parse_expression($parser);
                parser_expect($parser, "RBRACKET");
                $left = ast_new_deref_array($left, $idx);
            }
            # Struct field access ->field or method call ->method()
            elsif (parser_check($parser, "IDENT")) {
                my scalar $field_tok = parser_current($parser);
                parser_advance($parser);
                my scalar $field = ast_new_field_access($left, $field_tok->{"value"});

                # Check for method call
                if (parser_check($parser, "LPAREN")) {
                    parser_advance($parser);
                    # For method calls, store both:
                    # - field: the FIELD_ACCESS node (needed for struct funcptr detection)
                    # - base_object: the original object (needed for OOP method calls)
                    my scalar $call = ast_new_method_call($field, $field_tok->{"value"});
                    $call->{"base_object"} = $left;

                    # Parse arguments
                    if (!parser_check($parser, "RPAREN")) {
                        my scalar $arg = parse_expression($parser);
                        ast_add_arg($call, $arg);

                        while (parser_check($parser, "COMMA")) {
                            parser_advance($parser);
                            my scalar $next_arg = parse_expression($parser);
                            ast_add_arg($call, $next_arg);
                        }
                    }
                    parser_expect($parser, "RPAREN");
                    $left = $call;
                } else {
                    $left = $field;
                }
            }
            else {
                parser_error($parser, "expected {, [, or field name after ->");
            }
        }
        elsif (parser_check($parser, "LBRACE")) {
            # Check for invalid %hash{key} syntax - should use $hash{key}
            if ($left->{"type"} == NODE_VARIABLE()) {
                my str $sigil = $left->{"sigil"};
                if ($sigil eq "%") {
                    parser_error($parser, "use $hash{key} for hash element access (hash sigil not allowed here)");
                }
                if ($sigil eq "@") {
                    parser_error($parser, "cannot use hash subscript {key} on array variable");
                }
            }
            parser_advance($parser);
            my scalar $key = parse_expression($parser);
            parser_expect($parser, "RBRACE");
            $left = ast_new_hash_access($left, $key);
        }
        elsif (parser_check($parser, "LBRACKET")) {
            # Check for invalid %hash[idx] syntax (but allow @arr[idx] for compatibility)
            if ($left->{"type"} == NODE_VARIABLE()) {
                my str $sigil = $left->{"sigil"};
                if ($sigil eq "%") {
                    parser_error($parser, "cannot use array subscript [idx] on hash variable");
                }
            }
            parser_advance($parser);
            my scalar $idx = parse_expression($parser);
            parser_expect($parser, "RBRACKET");
            $left = ast_new_subscript($left, $idx);
        }
        elsif (parser_check($parser, "PLUSPLUS")) {
            parser_advance($parser);
            $left = ast_new_increment("++", $left, 0);
        }
        elsif (parser_check($parser, "MINUSMINUS")) {
            parser_advance($parser);
            $left = ast_new_increment("--", $left, 0);
        }
        else {
            return $left;
        }
    }
}

# Unary expressions
func parse_unary(scalar $parser) scalar {
    my scalar $tok = parser_current($parser);
    
    if ($tok->{"type"} eq "MINUS") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_unary_op("-", $operand);
    }
    
    if ($tok->{"type"} eq "NOT") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_unary_op("!", $operand);
    }

    if ($tok->{"type"} eq "TILDE") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_unary_op("~", $operand);
    }

    # Prefix increment/decrement
    if ($tok->{"type"} eq "PLUSPLUS") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_increment("++", $operand, 1);
    }

    if ($tok->{"type"} eq "MINUSMINUS") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_increment("--", $operand, 1);
    }

    my scalar $primary = parse_primary($parser);
    return parse_postfix($parser, $primary);
}

# Power: ** (right-associative, higher precedence than multiplicative)
func parse_power(scalar $parser) scalar {
    my scalar $left = parse_unary($parser);

    my scalar $tok = parser_current($parser);
    if ($tok->{"type"} eq "POWER") {
        my str $op = $tok->{"value"};
        parser_advance($parser);
        # Right-associative: recurse on right side
        my scalar $right = parse_power($parser);
        return ast_new_binary_op($op, $left, $right);
    }

    return $left;
}

# Multiplicative: * / %
func parse_multiplicative(scalar $parser) scalar {
    my scalar $left = parse_power($parser);

    while (1) {
        my scalar $tok = parser_current($parser);
        my str $type = $tok->{"type"};

        if ($type eq "MULT" || $type eq "DIV" || $type eq "MOD") {
            my str $op = $tok->{"value"};
            parser_advance($parser);
            my scalar $right = parse_power($parser);
            $left = ast_new_binary_op($op, $left, $right);
        } else {
            return $left;
        }
    }
}

# Additive: + - .
func parse_additive(scalar $parser) scalar {
    my scalar $left = parse_multiplicative($parser);
    
    while (1) {
        my scalar $tok = parser_current($parser);
        my str $type = $tok->{"type"};
        
        if ($type eq "PLUS" || $type eq "MINUS" || $type eq "DOT") {
            my str $op = $tok->{"value"};
            parser_advance($parser);
            my scalar $right = parse_multiplicative($parser);
            $left = ast_new_binary_op($op, $left, $right);
        } else {
            return $left;
        }
    }
}

# Shift: << >>
func parse_shift(scalar $parser) scalar {
    my scalar $left = parse_additive($parser);

    while (1) {
        my scalar $tok = parser_current($parser);
        my str $type = $tok->{"type"};

        if ($type eq "LSHIFT" || $type eq "RSHIFT") {
            my str $op = $tok->{"value"};
            parser_advance($parser);
            my scalar $right = parse_additive($parser);
            $left = ast_new_binary_op($op, $left, $right);
        } else {
            return $left;
        }
    }
}

# Range: ..
func parse_range(scalar $parser) scalar {
    my scalar $left = parse_shift($parser);

    if (parser_check($parser, "RANGE")) {
        parser_advance($parser);
        my scalar $right = parse_shift($parser);
        return ast_new_range($left, $right);
    }

    return $left;
}

# Relational: < > <= >= lt gt le ge
func parse_relational(scalar $parser) scalar {
    my scalar $left = parse_range($parser);

    while (1) {
        my scalar $tok = parser_current($parser);
        my str $type = $tok->{"type"};

        if ($type eq "LT" || $type eq "GT" || $type eq "LE" || $type eq "GE") {
            my str $op = $tok->{"value"};
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op($op, $left, $right);
        } elsif ($type eq "STR_LT") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("lt", $left, $right);
        } elsif ($type eq "STR_GT") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("gt", $left, $right);
        } elsif ($type eq "STR_LE") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("le", $left, $right);
        } elsif ($type eq "STR_GE") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("ge", $left, $right);
        } elsif ($type eq "SPACESHIP") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("<=>", $left, $right);
        } else {
            return $left;
        }
    }
}

# Regex match: =~ !~
func parse_regex_match(scalar $parser) scalar {
    my scalar $left = parse_relational($parser);

    my scalar $tok = parser_current($parser);
    my str $type = $tok->{"type"};

    if ($type eq "MATCH_OP" || $type eq "NOT_MATCH_OP") {
        my str $op = $tok->{"value"};
        parser_advance($parser);

        my scalar $right_tok = parser_current($parser);
        my str $right_type = $right_tok->{"type"};

        if ($right_type eq "REGEX_LITERAL") {
            parser_advance($parser);
            return ast_new_regex_match($op, $left, $right_tok->{"pattern"}, $right_tok->{"flags"});
        } elsif ($right_type eq "SUBST_LITERAL") {
            parser_advance($parser);
            if ($op eq "!~") {
                parser_error($parser, "cannot use !~ with substitution s///");
            }
            return ast_new_regex_subst($left, $right_tok->{"pattern"}, $right_tok->{"replacement"}, $right_tok->{"flags"});
        } else {
            # String expression as pattern: $foo =~ $pattern
            my scalar $right = parse_relational($parser);
            return ast_new_binary_op($op, $left, $right);
        }
    }

    return $left;
}

# Equality: == != eq ne
func parse_equality(scalar $parser) scalar {
    my scalar $left = parse_regex_match($parser);
    
    while (1) {
        my scalar $tok = parser_current($parser);
        my str $type = $tok->{"type"};
        
        if ($type eq "EQ" || $type eq "NE") {
            my str $op = $tok->{"value"};
            parser_advance($parser);
            my scalar $right = parse_relational($parser);
            $left = ast_new_binary_op($op, $left, $right);
        } elsif ($type eq "STR_EQ") {
            parser_advance($parser);
            my scalar $right = parse_relational($parser);
            $left = ast_new_binary_op("eq", $left, $right);
        } elsif ($type eq "STR_NE") {
            parser_advance($parser);
            my scalar $right = parse_relational($parser);
            $left = ast_new_binary_op("ne", $left, $right);
        } else {
            return $left;
        }
    }
}

# Bitwise AND: &
func parse_bitwise_and(scalar $parser) scalar {
    my scalar $left = parse_equality($parser);

    while (parser_check($parser, "AMPERSAND")) {
        parser_advance($parser);
        my scalar $right = parse_equality($parser);
        $left = ast_new_binary_op("&", $left, $right);
    }

    return $left;
}

# Bitwise XOR: ^
func parse_bitwise_xor(scalar $parser) scalar {
    my scalar $left = parse_bitwise_and($parser);

    while (parser_check($parser, "CARET")) {
        parser_advance($parser);
        my scalar $right = parse_bitwise_and($parser);
        $left = ast_new_binary_op("^", $left, $right);
    }

    return $left;
}

# Bitwise OR: |
func parse_bitwise_or(scalar $parser) scalar {
    my scalar $left = parse_bitwise_xor($parser);

    while (parser_check($parser, "PIPE")) {
        parser_advance($parser);
        my scalar $right = parse_bitwise_xor($parser);
        $left = ast_new_binary_op("|", $left, $right);
    }

    return $left;
}

# Logical AND: &&
func parse_logical_and(scalar $parser) scalar {
    my scalar $left = parse_bitwise_or($parser);

    while (parser_check($parser, "AND")) {
        parser_advance($parser);
        my scalar $right = parse_bitwise_or($parser);
        $left = ast_new_binary_op("&&", $left, $right);
    }

    return $left;
}

# Logical OR: ||
func parse_logical_or(scalar $parser) scalar {
    my scalar $left = parse_logical_and($parser);

    while (parser_check($parser, "OR")) {
        parser_advance($parser);
        my scalar $right = parse_logical_and($parser);
        $left = ast_new_binary_op("||", $left, $right);
    }

    return $left;
}

# Ternary expression: cond ? true_expr : false_expr
func parse_ternary(scalar $parser) scalar {
    my scalar $cond = parse_logical_or($parser);

    if (parser_check($parser, "QUESTION")) {
        parser_advance($parser);
        my scalar $true_expr = parse_expression($parser);
        parser_expect($parser, "COLON");
        my scalar $false_expr = parse_ternary($parser);
        return ast_new_ternary($cond, $true_expr, $false_expr);
    }

    return $cond;
}

# Assignment expression
func parse_assignment(scalar $parser) scalar {
    my scalar $left = parse_ternary($parser);
    
    my scalar $tok = parser_current($parser);
    my str $type = $tok->{"type"};
    
    if ($type eq "ASSIGN" || $type eq "PLUS_ASSIGN" || 
        $type eq "MINUS_ASSIGN" || $type eq "DOT_ASSIGN") {
        my str $op = $tok->{"value"};
        parser_advance($parser);
        my scalar $right = parse_assignment($parser);
        return ast_new_assign($op, $left, $right);
    }
    
    return $left;
}

# Top-level expression
func parse_expression(scalar $parser) scalar {
    return parse_assignment($parser);
}

# ============================================================
# Statement Parsing
# ============================================================

# Parse case value - handles literals and simple variables without hash access interpretation
func parse_case_value(scalar $parser) scalar {
    my scalar $tok = parser_current($parser);
    my str $type = $tok->{"type"};

    # Integer literal
    if ($type eq "INT_LITERAL") {
        parser_advance($parser);
        return ast_new_int_literal($tok->{"value"});
    }

    # Number literal
    if ($type eq "NUM_LITERAL") {
        parser_advance($parser);
        return ast_new_num_literal($tok->{"value"});
    }

    # String literal
    if ($type eq "STR_LITERAL") {
        parser_advance($parser);
        return ast_new_str_literal($tok->{"value"});
    }

    # Variable (without hash access interpretation)
    if ($type eq "DOLLAR") {
        my int $var_line = parser_current_line($parser);
        parser_advance($parser);
        my str $var_name = parse_var_name($parser);
        my scalar $var = ast_new_variable($var_name, "$");
        ast_set_line($var, $var_line);
        return $var;
    }

    # Bareword/identifier
    if ($type eq "IDENT") {
        my str $name = $tok->{"value"};
        parser_advance($parser);
        return ast_new_str_literal($name);
    }

    parser_error($parser, "expected case value");
}

func parse_block(scalar $parser) scalar {
    parser_expect($parser, "LBRACE");
    my scalar $block = ast_new_block();
    
    while (!parser_check($parser, "RBRACE") && !parser_check($parser, "EOF")) {
        my scalar $stmt = parse_statement($parser);
        ast_add_statement($block, $stmt);
    }
    
    parser_expect($parser, "RBRACE");
    return $block;
}

func parse_var_decl(scalar $parser) scalar {
    my int $decl_line = parser_current_line($parser);
    parser_expect($parser, "MY");

    my int $var_type = parse_type($parser);
    my str $type_name = $parser->{"last_type_name"};

    # Get sigil and name
    my scalar $sigil_tok = parser_current($parser);
    my str $sigil = "$";

    if ($sigil_tok->{"type"} eq "DOLLAR") {
        $sigil = "$";
        parser_advance($parser);
    } elsif ($sigil_tok->{"type"} eq "AT") {
        $sigil = "@";
        parser_advance($parser);
    } elsif ($sigil_tok->{"type"} eq "PERCENT") {
        $sigil = "%";
        parser_advance($parser);
    }

    my str $name = parse_var_name($parser);

    my scalar $decl = ast_new_var_decl($name, $var_type, $sigil);
    ast_set_line($decl, $decl_line);

    # Store struct type name if applicable
    if ($var_type == TYPE_STRUCT()) {
        $decl->{"type_name"} = $type_name;
    }

    # Optional initial capacity for arrays: my array @name[size];
    if ($sigil eq "@") {
        if (parser_check($parser, "LBRACKET")) {
            parser_advance($parser);
            $decl->{"initial_capacity"} = parse_expression($parser);
            parser_expect($parser, "RBRACKET");
        }
    }

    # Optional initial capacity for hashes: my hash %name[size];
    if ($sigil eq "%") {
        if (parser_check($parser, "LBRACKET")) {
            parser_advance($parser);
            $decl->{"initial_capacity"} = parse_expression($parser);
            parser_expect($parser, "RBRACKET");
        }
    }

    # Optional initialization
    if (parser_check($parser, "ASSIGN")) {
        parser_advance($parser);
        $decl->{"init"} = parse_expression($parser);
    }

    parser_expect($parser, "SEMI");
    return $decl;
}

func parse_if_stmt(scalar $parser) scalar {
    parser_expect($parser, "IF");
    parser_expect($parser, "LPAREN");
    my scalar $condition = parse_expression($parser);
    parser_expect($parser, "RPAREN");
    
    my scalar $then_block = parse_block($parser);
    my scalar $if_stmt = ast_new_if_stmt($condition, $then_block);
    
    # Handle elsif clauses
    while (parser_check($parser, "ELSIF")) {
        parser_advance($parser);
        parser_expect($parser, "LPAREN");
        my scalar $elsif_cond = parse_expression($parser);
        parser_expect($parser, "RPAREN");
        my scalar $elsif_block = parse_block($parser);
        ast_add_elsif($if_stmt, $elsif_cond, $elsif_block);
    }
    
    # Handle else clause
    if (parser_check($parser, "ELSE")) {
        parser_advance($parser);
        $if_stmt->{"else_block"} = parse_block($parser);
    }
    
    return $if_stmt;
}

func parse_while_stmt(scalar $parser, str $label) scalar {
    parser_expect($parser, "WHILE");
    parser_expect($parser, "LPAREN");
    my scalar $condition = parse_expression($parser);
    parser_expect($parser, "RPAREN");

    my scalar $body = parse_block($parser);
    return ast_new_while_stmt($condition, $body, $label);
}

# Parse array-style for loop: for my type $var (@array) or for $var (@array)
# This is syntactic sugar for foreach
func parse_for_array_style(scalar $parser, str $label) scalar {
    my scalar $var_decl = 0;
    my str $var_name = "";

    # Check if we have a variable declaration or existing variable
    if (parser_check($parser, "MY")) {
        # for my type $var (@array)
        parser_advance($parser);
        my int $var_type = parse_type($parser);

        my scalar $sigil_tok = parser_current($parser);
        my str $sigil = "$";
        if ($sigil_tok->{"type"} eq "DOLLAR") {
            $sigil = "$";
            parser_advance($parser);
        }

        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $var_name = $name_tok->{"value"};

        $var_decl = ast_new_var_decl($var_name, $var_type, $sigil);
    } else {
        # for $var (@array) - must be existing variable with $ sigil
        parser_expect($parser, "DOLLAR");
        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $var_name = $name_tok->{"value"};
    }

    parser_expect($parser, "LPAREN");
    my scalar $array_expr = parse_expression($parser);
    parser_expect($parser, "RPAREN");

    my scalar $body = parse_block($parser);
    return ast_new_foreach_stmt($var_decl, $var_name, $array_expr, $body, $label);
}

func parse_for_stmt(scalar $parser, str $label) scalar {
    parser_expect($parser, "FOR");

    # Check if this is array-style for (like foreach) or C-style for
    # for my type $var (@array) - array style
    # for $var (@array) - array style
    # for (init; cond; update) - C style
    if (parser_check($parser, "MY") || parser_check($parser, "DOLLAR")) {
        # Array-style for loop - delegate to foreach parsing logic
        return parse_for_array_style($parser, $label);
    }

    parser_expect($parser, "LPAREN");

    # Init (may be var decl or expression)
    my scalar $init = 0;
    if (parser_check($parser, "MY")) {
        # Variable declaration (without semicolon)
        parser_advance($parser);
        my int $var_type = parse_type($parser);

        my scalar $sigil_tok = parser_current($parser);
        my str $sigil = "$";
        if ($sigil_tok->{"type"} eq "DOLLAR") {
            $sigil = "$";
            parser_advance($parser);
        }

        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");

        $init = ast_new_var_decl($name_tok->{"value"}, $var_type, $sigil);

        if (parser_check($parser, "ASSIGN")) {
            parser_advance($parser);
            $init->{"init"} = parse_expression($parser);
        }
    } elsif (!parser_check($parser, "SEMI")) {
        $init = parse_expression($parser);
    }
    parser_expect($parser, "SEMI");

    # Condition
    my scalar $cond = 0;
    if (!parser_check($parser, "SEMI")) {
        $cond = parse_expression($parser);
    }
    parser_expect($parser, "SEMI");

    # Update
    my scalar $update = 0;
    if (!parser_check($parser, "RPAREN")) {
        $update = parse_expression($parser);
    }
    parser_expect($parser, "RPAREN");

    my scalar $body = parse_block($parser);
    return ast_new_for_stmt($init, $cond, $update, $body, $label);
}

func parse_foreach_stmt(scalar $parser, str $label) scalar {
    parser_expect($parser, "FOREACH");

    my scalar $var_decl = 0;
    my str $var_name = "";

    # Check if we have a variable declaration or existing variable
    if (parser_check($parser, "MY")) {
        # foreach my type $var (@array)
        parser_advance($parser);
        my int $var_type = parse_type($parser);

        my scalar $sigil_tok = parser_current($parser);
        my str $sigil = "$";
        if ($sigil_tok->{"type"} eq "DOLLAR") {
            $sigil = "$";
            parser_advance($parser);
        }

        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $var_name = $name_tok->{"value"};

        $var_decl = ast_new_var_decl($var_name, $var_type, $sigil);
    } else {
        # foreach $var (@array) - must be existing variable with $ sigil
        parser_expect($parser, "DOLLAR");
        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $var_name = $name_tok->{"value"};
    }

    parser_expect($parser, "LPAREN");
    my scalar $array_expr = parse_expression($parser);
    parser_expect($parser, "RPAREN");

    my scalar $body = parse_block($parser);
    return ast_new_foreach_stmt($var_decl, $var_name, $array_expr, $body, $label);
}

func parse_return_stmt(scalar $parser) scalar {
    parser_expect($parser, "RETURN");
    
    my scalar $value = 0;
    if (!parser_check($parser, "SEMI")) {
        $value = parse_expression($parser);
    }
    
    parser_expect($parser, "SEMI");
    return ast_new_return_stmt($value);
}

func parse_statement(scalar $parser) scalar {
    my scalar $tok = parser_current($parser);
    my str $type = $tok->{"type"};

    if ($type eq "MY") {
        return parse_var_decl($parser);
    }

    if ($type eq "IF") {
        return parse_if_stmt($parser);
    }

    # Check for labeled statement: LABEL: while/for
    if ($type eq "IDENT") {
        my scalar $peek_tok = parser_peek($parser);
        if ($peek_tok->{"type"} eq "COLON") {
            my str $label = $tok->{"value"};
            parser_advance($parser);
            parser_advance($parser);

            my scalar $loop_tok = parser_current($parser);
            my str $loop_type = $loop_tok->{"type"};

            if ($loop_type eq "WHILE") {
                return parse_while_stmt($parser, $label);
            } elsif ($loop_type eq "FOR") {
                return parse_for_stmt($parser, $label);
            } elsif ($loop_type eq "FOREACH") {
                return parse_foreach_stmt($parser, $label);
            } else {
                # Standalone label for goto
                return ast_new_label($label);
            }
        }
    }

    if ($type eq "WHILE") {
        return parse_while_stmt($parser, "");
    }

    if ($type eq "FOR") {
        return parse_for_stmt($parser, "");
    }

    if ($type eq "FOREACH") {
        return parse_foreach_stmt($parser, "");
    }

    if ($type eq "RETURN") {
        return parse_return_stmt($parser);
    }

    if ($type eq "LAST") {
        parser_advance($parser);
        my str $label = "";
        my scalar $label_tok = parser_current($parser);
        if ($label_tok->{"type"} eq "IDENT") {
            $label = $label_tok->{"value"};
            parser_advance($parser);
        }
        parser_expect($parser, "SEMI");
        return ast_new_last($label);
    }

    if ($type eq "NEXT") {
        parser_advance($parser);
        my str $label = "";
        my scalar $label_tok = parser_current($parser);
        if ($label_tok->{"type"} eq "IDENT") {
            $label = $label_tok->{"value"};
            parser_advance($parser);
        }
        parser_expect($parser, "SEMI");
        return ast_new_next($label);
    }

    # try { ... } catch ($e) { ... }
    if ($type eq "TRY") {
        parser_advance($parser);
        my scalar $try_block = parse_block($parser);

        parser_expect($parser, "CATCH");
        parser_expect($parser, "LPAREN");
        parser_expect($parser, "DOLLAR");
        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        my str $catch_var = $name_tok->{"value"};
        parser_expect($parser, "RPAREN");

        my scalar $catch_block = parse_block($parser);

        return ast_new_try_catch($try_block, $catch_var, $catch_block);
    }

    # throw $expr;
    if ($type eq "THROW") {
        parser_advance($parser);
        my scalar $expr = parse_expression($parser);
        parser_expect($parser, "SEMI");
        return ast_new_throw($expr);
    }

    # goto LABEL;
    if ($type eq "GOTO") {
        parser_advance($parser);
        my scalar $tok = parser_current($parser);
        my str $target = $tok->{"value"};
        parser_advance($parser);
        parser_expect($parser, "SEMI");
        return ast_new_goto($target);
    }

    # switch ($expr) { case val { ... } default { ... } }
    if ($type eq "SWITCH") {
        parser_advance($parser);
        parser_expect($parser, "LPAREN");
        my scalar $switch_expr = parse_expression($parser);
        parser_expect($parser, "RPAREN");
        parser_expect($parser, "LBRACE");

        my scalar $switch_node = ast_new_switch($switch_expr);

        while (!parser_check($parser, "RBRACE") && !parser_check($parser, "EOF")) {
            my scalar $case_tok = parser_current($parser);
            my str $case_type = $case_tok->{"type"};

            if ($case_type eq "CASE") {
                parser_advance($parser);
                my scalar $case_expr = parse_case_value($parser);
                my scalar $case_block = parse_block($parser);
                ast_add_case($switch_node, $case_expr, $case_block);
            } elsif ($case_type eq "DEFAULT") {
                parser_advance($parser);
                my scalar $default_block = parse_block($parser);
                $switch_node->{"default_block"} = $default_block;
                $switch_node->{"has_default"} = 1;
            } else {
                parser_error($parser, "expected 'case' or 'default' in switch statement");
            }
        }

        parser_expect($parser, "RBRACE");
        return $switch_node;
    }

    # Expression statement
    my scalar $expr = parse_expression($parser);
    parser_expect($parser, "SEMI");
    return ast_new_expr_stmt($expr);
}

# ============================================================
# Function and Program Parsing
# ============================================================

func parse_function(scalar $parser) scalar {
    my int $func_line = parser_current_line($parser);
    parser_expect($parser, "FUNC");

    my scalar $name_tok = parser_current($parser);
    parser_expect($parser, "IDENT");
    my str $func_name = $name_tok->{"value"};

    parser_expect($parser, "LPAREN");

    # Create function node with dummy return type for now
    my scalar $fn = ast_new_function($func_name, TYPE_VOID());
    ast_set_line($fn, $func_line);
    
    # Parse parameters
    if (!parser_check($parser, "RPAREN")) {
        while (1) {
            # Check for variadic parameter (...)
            my int $is_variadic = 0;
            if (parser_check($parser, "ELLIPSIS")) {
                parser_advance($parser);
                $is_variadic = 1;
                $fn->{"is_variadic"} = 1;
            }
            
            my int $param_type = parse_type($parser);
            my str $param_type_name = $parser->{"last_type_name"};
            
            # Get sigil
            my scalar $sigil_tok = parser_current($parser);
            my str $sigil = "$";
            if ($sigil_tok->{"type"} eq "DOLLAR") {
                $sigil = "$";
                parser_advance($parser);
            } elsif ($sigil_tok->{"type"} eq "AT") {
                $sigil = "@";
                parser_advance($parser);
            } elsif ($sigil_tok->{"type"} eq "PERCENT") {
                $sigil = "%";
                parser_advance($parser);
            }
            
            my scalar $pname_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            
            my scalar $param = ast_new_param($pname_tok->{"value"}, $param_type, $sigil);
            $param->{"is_variadic"} = $is_variadic;
            
            # Store struct type name if applicable
            if ($param_type == TYPE_STRUCT()) {
                $param->{"type_name"} = $param_type_name;
            }
            
            # Check for default value
            if (parser_check($parser, "ASSIGN")) {
                parser_advance($parser);
                my scalar $default_val = parse_expression($parser);
                $param->{"default"} = $default_val;
                $param->{"has_default"} = 1;
            } else {
                $param->{"has_default"} = 0;
            }
            
            ast_add_param($fn, $param);
            
            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
            } else {
                parser_expect($parser, "RPAREN");
                last;
            }
        }
    } else {
        parser_advance($parser);  # Skip )
    }
    
    # Parse return type
    my int $ret_type = parse_type($parser);
    $fn->{"return_type"} = $ret_type;
    
    # Parse body
    $fn->{"body"} = parse_block($parser);
    
    return $fn;
}

# Parse extern function declaration or definition
func parse_extern_function(scalar $parser) scalar {
    parser_expect($parser, "EXTERN");
    parser_expect($parser, "FUNC");
    
    my scalar $name_tok = parser_current($parser);
    parser_expect($parser, "IDENT");
    
    my scalar $fn = ast_new_extern_func($name_tok->{"value"});
    
    parser_expect($parser, "LPAREN");
    
    # Parse parameters
    if (!parser_check($parser, "RPAREN")) {
        while (1) {
            my int $param_type = parse_type($parser);
            
            # Get sigil
            my str $sigil = "$";
            if (parser_check($parser, "DOLLAR")) {
                parser_advance($parser);
            } elsif (parser_check($parser, "AT")) {
                $sigil = "@";
                parser_advance($parser);
            } elsif (parser_check($parser, "PERCENT")) {
                $sigil = "%";
                parser_advance($parser);
            }
            
            my scalar $pname_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            
            my scalar $param = ast_new_param($pname_tok->{"value"}, $param_type, $sigil);
            ast_add_param($fn, $param);
            
            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
            } else {
                parser_expect($parser, "RPAREN");
                last;
            }
        }
    } else {
        parser_advance($parser);
    }
    
    # Parse return type
    my int $ret_type = parse_type($parser);
    $fn->{"return_type"} = $ret_type;
    
    # Check if this is a declaration (;) or definition ({...})
    if (parser_check($parser, "SEMI")) {
        parser_advance($parser);
        $fn->{"has_body"} = 0;
    } else {
        # Has a body - parse it
        $fn->{"body"} = parse_block($parser);
        $fn->{"has_body"} = 1;
    }
    
    return $fn;
}

# Parse struct definition
func parse_struct(scalar $parser) scalar {
    my int $struct_line = parser_current_line($parser);
    parser_expect($parser, "STRUCT");

    my scalar $name_tok = parser_current($parser);
    parser_expect($parser, "IDENT");

    my scalar $st = ast_new_struct($name_tok->{"value"});
    ast_set_line($st, $struct_line);

    parser_expect($parser, "LBRACE");
    
    while (!parser_check($parser, "RBRACE")) {
        # Fields in structs don't have sigils: "int x;" not "int $x;"
        my int $field_type = parse_type($parser);
        
        my scalar $field_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        
        ast_add_field($st, $field_tok->{"value"}, $field_type, "$");
        
        parser_expect($parser, "SEMI");
    }
    
    parser_expect($parser, "RBRACE");
    
    return $st;
}

# Parse package declaration
func parse_package(scalar $parser, scalar $program) void {
    parser_expect($parser, "PACKAGE");
    
    my str $pkg_name = "";
    my scalar $tok = parser_current($parser);
    parser_expect($parser, "IDENT");
    $pkg_name = $tok->{"value"};
    
    # Handle Package::Name syntax
    while (parser_check($parser, "DOUBLE_COLON")) {
        parser_advance($parser);
        my scalar $next_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $pkg_name = $pkg_name . "::" . $next_tok->{"value"};
    }
    
    parser_expect($parser, "SEMI");

    $program->{"package"} = $pkg_name;
}

# Parse version declaration: version "x.y.z";
func parse_version(scalar $parser, scalar $program) void {
    parser_expect($parser, "VERSION");

    my scalar $tok = parser_current($parser);
    parser_expect($parser, "STR_LITERAL");
    my str $ver = $tok->{"value"};

    parser_expect($parser, "SEMI");

    $program->{"version"} = $ver;
}

# Parse inherit statement (top-level inheritance declaration)
# Supports: inherit Parent; or inherit Parent1, Parent2, Parent3;
func parse_inherit(scalar $parser, scalar $program) void {
    parser_expect($parser, "INHERIT");

    # Parse first parent
    my str $parent_name = "";
    my scalar $tok = parser_current($parser);
    parser_expect($parser, "IDENT");
    $parent_name = $tok->{"value"};

    # Handle Parent::Name syntax
    while (parser_check($parser, "DOUBLE_COLON")) {
        parser_advance($parser);
        my scalar $next_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $parent_name = $parent_name . "::" . $next_tok->{"value"};
    }

    ast_add_inherit($program, $parent_name);

    # Parse additional parents (comma-separated)
    while (parser_check($parser, "COMMA")) {
        parser_advance($parser);

        $parent_name = "";
        $tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $parent_name = $tok->{"value"};

        # Handle Parent::Name syntax
        while (parser_check($parser, "DOUBLE_COLON")) {
            parser_advance($parser);
            my scalar $next_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            $parent_name = $parent_name . "::" . $next_tok->{"value"};
        }

        ast_add_inherit($program, $parent_name);
    }

    parser_expect($parser, "SEMI");
}

# Convert module name to file path (POSIX -> POSIX.strada, File::IO -> File/IO.strada)
func module_to_path(str $mod_name) str {
    my str $path = "";
    my int $i = 0;
    my int $len = length($mod_name);
    while ($i < $len) {
        my str $ch = substr($mod_name, $i, 1);
        if ($ch eq ":") {
            # Skip the second colon
            $i = $i + 1;
            $path = $path . "/";
        } else {
            $path = $path . $ch;
        }
        $i = $i + 1;
    }
    return $path . ".strada";
}

# Find module file in lib paths
func find_module_file(scalar $program, str $mod_name) str {
    my str $rel_path = module_to_path($mod_name);
    my scalar $lib_paths = $program->{"lib_paths"};
    my int $i = 0;
    my int $count = $program->{"lib_path_count"};

    while ($i < $count) {
        my str $lib_path = $lib_paths->[$i];
        my str $full_path = $lib_path . "/" . $rel_path;
        # Try to read the file - if it works, file exists
        my str $content = slurp($full_path);
        if (length($content) > 0) {
            return $full_path;
        }
        $i = $i + 1;
    }

    return "";
}

# Load and parse a module, merging its functions into the program
func load_module(scalar $program, str $mod_name, str $file_path) void {
    # Read the module source
    my str $source = slurp($file_path);
    if (length($source) == 0) {
        return;
    }

    # Lex the module
    my scalar $tokens = lex_tokenize($source);

    # Parse the module
    my scalar $mod_parser = parser_new($tokens);
    my scalar $mod_program = ast_new_program();

    # Parse the module's contents
    while (!parser_check($mod_parser, "EOF")) {
        if (parser_check($mod_parser, "FUNC")) {
            my scalar $fn = parse_function($mod_parser);
            ast_add_function($mod_program, $fn);
        } elsif (parser_check($mod_parser, "PACKAGE")) {
            parse_package($mod_parser, $mod_program);
        } elsif (parser_check($mod_parser, "VERSION")) {
            parse_version($mod_parser, $mod_program);
        } elsif (parser_check($mod_parser, "STRUCT")) {
            my scalar $st = parse_struct($mod_parser);
            ast_add_struct($mod_program, $st);
        } elsif (parser_check($mod_parser, "HASH")) {
            # Skip comments that look like hash
            parser_advance($mod_parser);
        } else {
            # Skip other tokens (comments, etc)
            parser_advance($mod_parser);
        }
    }

    # Get the package name from the module (defaults to module name)
    my str $pkg_name = $mod_program->{"package"};
    if (length($pkg_name) == 0) {
        $pkg_name = $mod_name;
    }

    # Merge functions into main program with package prefix
    my scalar $mod_funcs = $mod_program->{"functions"};
    my int $i = 0;
    my int $count = $mod_program->{"function_count"};

    while ($i < $count) {
        my scalar $fn = $mod_funcs->[$i];
        my str $fn_name = $fn->{"name"};

        # Store original name and package
        $fn->{"original_name"} = $fn_name;
        $fn->{"package"} = $pkg_name;

        # Create qualified name version
        $fn->{"name"} = $pkg_name . "::" . $fn_name;

        # Add qualified version to main program
        ast_add_function($program, $fn);

        $i = $i + 1;
    }

    # Merge structs
    my scalar $mod_structs = $mod_program->{"structs"};
    $i = 0;
    $count = $mod_program->{"struct_count"};
    while ($i < $count) {
        my scalar $st = $mod_structs->[$i];
        ast_add_struct($program, $st);
        $i = $i + 1;
    }
}

# Parse use statement
func parse_use(scalar $parser, scalar $program) void {
    parser_expect($parser, "USE");

    my str $mod_name = "";
    my scalar $tok = parser_current($parser);

    # Check if it's a string path or identifier
    if ($tok->{"type"} eq "STR_LITERAL") {
        $mod_name = $tok->{"value"};
        parser_advance($parser);
    } else {
        parser_expect($parser, "IDENT");
        $mod_name = $tok->{"value"};

        # Check for "use lib" pattern followed by string
        if ($mod_name eq "lib") {
            if (parser_check($parser, "STR_LITERAL")) {
                my scalar $path_tok = parser_current($parser);
                my str $lib_path = $path_tok->{"value"};
                parser_advance($parser);
                # Store the lib path
                ast_add_lib_path($program, $lib_path);
            }
            parser_expect($parser, "SEMI");
            ast_add_use($program, "lib");
            return;
        }

        # Handle Module::Name syntax
        while (parser_check($parser, "DOUBLE_COLON")) {
            parser_advance($parser);
            my scalar $next_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            $mod_name = $mod_name . "::" . $next_tok->{"value"};
        }

        # Check for qw() import list
        if (parser_check($parser, "IDENT")) {
            my scalar $qw_tok = parser_current($parser);
            if ($qw_tok->{"value"} eq "qw") {
                parser_advance($parser);
                parser_expect($parser, "LPAREN");
                # Collect the import list
                while (!parser_check($parser, "RPAREN")) {
                    if (parser_check($parser, "IDENT")) {
                        my scalar $import_tok = parser_current($parser);
                        ast_add_import($program, $import_tok->{"value"});
                    }
                    parser_advance($parser);
                }
                parser_expect($parser, "RPAREN");
            }
        }
    }

    parser_expect($parser, "SEMI");

    # Check if module already loaded
    if (ast_is_module_loaded($program, $mod_name)) {
        ast_add_use($program, $mod_name);
        return;
    }

    # Try to find and load the module
    my str $file_path = find_module_file($program, $mod_name);
    if (length($file_path) > 0) {
        ast_mark_module_loaded($program, $mod_name);
        load_module($program, $mod_name, $file_path);
    }

    ast_add_use($program, $mod_name);
}

# Parse import_lib statement - import shared library as module
# import_lib "libname";  -> loads libname.so and reads metadata from __strada_export_info()
func parse_import_lib(scalar $parser, scalar $program) void {
    parser_expect($parser, "IMPORT_LIB");

    # Get the library name (must be a string)
    my scalar $tok = parser_current($parser);
    if ($tok->{"type"} ne "STR_LITERAL") {
        parser_error($parser, "import_lib requires a string library name");
    }
    my str $lib_name = $tok->{"value"};
    parser_advance($parser);

    parser_expect($parser, "SEMI");

    # Find the .so file in lib paths
    my str $so_path = find_so_file($program, $lib_name);
    if (length($so_path) == 0) {
        parser_error($parser, "cannot find shared library: " . $lib_name . ".so");
    }

    # Load the .so file and get metadata using runtime functions
    my scalar $lib_handle = strada_dl_open_raw($so_path);
    my int $lib_handle_int = $lib_handle;
    if ($lib_handle_int == 0) {
        parser_error($parser, "failed to load shared library: " . $so_path);
    }

    # Get the __strada_export_info function
    my scalar $export_fn = strada_dl_sym_raw($lib_handle, "__strada_export_info");
    my int $export_fn_int = $export_fn;
    if ($export_fn_int == 0) {
        strada_dl_close_raw($lib_handle);
        parser_error($parser, "library missing __strada_export_info: " . $so_path . " (was it compiled with a recent strada compiler?)");
    }

    # Call __strada_export_info to get metadata string
    my str $metadata = strada_dl_call_export_info($export_fn);
    strada_dl_close_raw($lib_handle);

    if (length($metadata) == 0) {
        parser_error($parser, "empty metadata from library: " . $so_path);
    }

    # Parse the metadata string to extract function signatures
    my scalar $lib_info = parse_export_metadata($lib_name, $so_path, $metadata);

    # Add to program
    ast_add_import_lib($program, $lib_info);
}

# Find .so file in lib paths
func find_so_file(scalar $program, str $lib_name) str {
    my str $so_name = $lib_name . ".so";
    my scalar $lib_paths = $program->{"lib_paths"};
    my int $i = 0;
    my int $count = $program->{"lib_path_count"};

    while ($i < $count) {
        my str $lib_path = $lib_paths->[$i];
        my str $full_path = $lib_path . "/" . $so_name;
        # Try to open the file to check if it exists
        my int $fd = sys::open_fd($full_path, "r");
        if ($fd > 0) {
            close_fd($fd);
            return $full_path;
        }
        $i = $i + 1;
    }

    return "";
}

# Parse export metadata string into lib_info structure
# Format: "func:name:return_type:param_count:param_types\n" for each function
# Note: Bootstrap compiler doesn't support scalar(@array), so we parse manually
func parse_export_metadata(str $lib_name, str $so_path, str $metadata) scalar {
    my hash %lib_info = ();
    $lib_info{"lib_name"} = $lib_name;
    $lib_info{"pkg_name"} = $lib_name;
    $lib_info{"so_path"} = $so_path;

    my array @functions = ();
    my int $fn_count = 0;

    # Parse metadata line by line manually (bootstrap doesn't support split well)
    my int $meta_len = length($metadata);
    my int $pos = 0;

    while ($pos < $meta_len) {
        # Extract one line
        my str $line = "";
        while ($pos < $meta_len) {
            my str $ch = substr($metadata, $pos, 1);
            $pos = $pos + 1;
            if ($ch eq "\n") {
                last;
            }
            $line = $line . $ch;
        }

        if (length($line) > 0) {
            # Parse: func:name:return_type:param_count:param_types
            my scalar $fn_info = parse_export_line($line);
            if ($fn_info != 0) {
                push(@functions, $fn_info);
                $fn_count = $fn_count + 1;
            }
        }
    }

    $lib_info{"functions"} = \@functions;
    $lib_info{"function_count"} = $fn_count;

    return \%lib_info;
}

# Parse a single export metadata line
# Format: func:name:return_type:param_count:param_types
func parse_export_line(str $line) scalar {
    # Extract fields by finding colons
    my int $len = length($line);
    my int $pos = 0;
    my int $field_num = 0;
    my str $kind = "";
    my str $fn_name = "";
    my str $ret_str = "";
    my str $param_count_str = "";
    my str $param_types_str = "";

    my str $current = "";
    while ($pos <= $len) {
        my str $ch = "";
        if ($pos < $len) {
            $ch = substr($line, $pos, 1);
        }
        if ($ch eq ":" || $pos == $len) {
            if ($field_num == 0) {
                $kind = $current;
            } elsif ($field_num == 1) {
                $fn_name = $current;
            } elsif ($field_num == 2) {
                $ret_str = $current;
            } elsif ($field_num == 3) {
                $param_count_str = $current;
            } elsif ($field_num == 4) {
                $param_types_str = $current;
            }
            $current = "";
            $field_num = $field_num + 1;
        } else {
            $current = $current . $ch;
        }
        $pos = $pos + 1;
    }

    # Only process "func" entries
    if ($kind ne "func") {
        return 0;
    }

    my int $param_count = 0;
    if (length($param_count_str) > 0) {
        $param_count = str_to_int($param_count_str);
    }

    my hash %fn_info = ();
    $fn_info{"name"} = $fn_name;
    $fn_info{"original_name"} = $fn_name;
    my int $ret_type = export_str_to_type($ret_str);
    $fn_info{"return_type"} = $ret_type;
    $fn_info{"param_count"} = $param_count;

    # Parse parameter types
    my array @params = ();
    if ($param_count > 0 && length($param_types_str) > 0) {
        my int $ppos = 0;
        my int $plen = length($param_types_str);
        my int $pnum = 0;
        my str $ptype = "";

        while ($ppos <= $plen && $pnum < $param_count) {
            my str $pch = "";
            if ($ppos < $plen) {
                $pch = substr($param_types_str, $ppos, 1);
            }
            if ($pch eq "," || $ppos == $plen) {
                my hash %param = ();
                $param{"name"} = "arg" . $pnum;
                $param{"param_type"} = export_str_to_type($ptype);
                $param{"sigil"} = "$";
                push(@params, \%param);
                $ptype = "";
                $pnum = $pnum + 1;
            } else {
                $ptype = $ptype . $pch;
            }
            $ppos = $ppos + 1;
        }
    }
    $fn_info{"params"} = \@params;

    return \%fn_info;
}

# Convert string to integer (bootstrap-compatible)
func str_to_int(str $s) int {
    my int $result = 0;
    my int $i = 0;
    my int $len = length($s);
    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        if ($ch ge "0" && $ch le "9") {
            $result = $result * 10 + (ord($ch) - ord("0"));
        }
        $i = $i + 1;
    }
    return $result;
}

# Convert export string to type constant
func export_str_to_type(str $type_str) int {
    if ($type_str eq "int") { return TYPE_INT(); }
    if ($type_str eq "num") { return TYPE_NUM(); }
    if ($type_str eq "str") { return TYPE_STR(); }
    if ($type_str eq "array") { return TYPE_ARRAY(); }
    if ($type_str eq "hash") { return TYPE_HASH(); }
    if ($type_str eq "scalar") { return TYPE_SCALAR(); }
    if ($type_str eq "void") { return TYPE_VOID(); }
    return TYPE_SCALAR();
}

func parse_program(scalar $parser, scalar $lib_paths, scalar $lib_paths_low) scalar {
    my scalar $program = ast_new_program();

    # Add command-line library paths first (high priority - before any use statements)
    my int $path_count = size($lib_paths);
    my int $path_i = 0;
    while ($path_i < $path_count) {
        my str $path = $lib_paths->[$path_i];
        ast_add_lib_path($program, $path);
        $path_i = $path_i + 1;
    }

    # Store low-priority paths to add after parsing
    my int $low_path_count = size($lib_paths_low);

    while (!parser_check($parser, "EOF")) {
        if (parser_check($parser, "FUNC")) {
            my scalar $fn = parse_function($parser);
            # Auto-prefix function names with package name when inside a simple package
            # (single-word packages like "Animal", not module-style "Math::Utils")
            my str $pkg = $program->{"package"};
            my str $fn_name = $fn->{"name"};
            # Store the package in the function node for OOP registration
            $fn->{"package"} = $pkg;
            # Only auto-prefix for simple single-word packages (no :: in name)
            my int $pkg_colon_idx = index($pkg, "::");
            if (length($pkg) > 0 && $pkg ne "main" && $fn_name ne "main" && $pkg_colon_idx < 0) {
                # Check if function already has the package prefix
                my str $prefix = $pkg . "_";
                my int $prefix_len = length($prefix);
                if (length($fn_name) < $prefix_len || substr($fn_name, 0, $prefix_len) ne $prefix) {
                    # Always prefix functions in a package
                    $fn->{"name"} = $pkg . "_" . $fn_name;
                }
            }
            ast_add_function($program, $fn);
        } elsif (parser_check($parser, "EXTERN")) {
            my scalar $fn = parse_extern_function($parser);
            ast_add_function($program, $fn);
        } elsif (parser_check($parser, "STRUCT")) {
            my scalar $st = parse_struct($parser);
            ast_add_struct($program, $st);
        } elsif (parser_check($parser, "PACKAGE")) {
            parse_package($parser, $program);
        } elsif (parser_check($parser, "VERSION")) {
            parse_version($parser, $program);
        } elsif (parser_check($parser, "INHERIT")) {
            parse_inherit($parser, $program);
        } elsif (parser_check($parser, "USE")) {
            parse_use($parser, $program);
        } elsif (parser_check($parser, "IMPORT_LIB")) {
            parse_import_lib($parser, $program);
        } elsif (parser_check($parser, "MY")) {
            my scalar $var = parse_var_decl($parser);
            ast_add_global($program, $var);
        } else {
            parser_error($parser, "expected function, extern, struct, package, inherit, use, import_lib, or variable declaration");
        }
    }

    # Add low-priority library paths last (after all use lib statements)
    $path_i = 0;
    while ($path_i < $low_path_count) {
        my str $path = $lib_paths_low->[$path_i];
        ast_add_lib_path($program, $path);
        $path_i = $path_i + 1;
    }

    return $program;
}

# ============================================================
# Main Entry Point
# ============================================================

func parse(scalar $tokens, str $filename) scalar {
    my scalar $parser = parser_new($tokens);
    parser_set_filename($parser, $filename);
    my array @empty_paths = ();
    my array @empty_paths_low = ();
    return parse_program($parser, \@empty_paths, \@empty_paths_low);
}

# Parse with pre-configured library paths (from -L and -LL command line options)
func parse_with_lib_paths(scalar $tokens, str $filename, scalar $lib_paths, scalar $lib_paths_low) scalar {
    my scalar $parser = parser_new($tokens);
    parser_set_filename($parser, $filename);
    return parse_program($parser, $lib_paths, $lib_paths_low);
}
