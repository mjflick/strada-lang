/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# Parser.strada - Recursive Descent Parser for self-hosting Strada compiler
# Converts token stream to AST

# ============================================================
# Parser State
# ============================================================

func parser_new(scalar $tokens) scalar {
    my hash %parser = ();
    $parser{"tokens"} = $tokens;
    $parser{"pos"} = 0;
    $parser{"token_count"} = size($tokens);
    $parser{"filename"} = "";
    $parser{"current_package"} = "";
    return \%parser;
}

func parser_set_filename(scalar $parser, str $filename) void {
    $parser->{"filename"} = $filename;
}

# Format and die with error message including file:line
func parser_error(scalar $parser, str $msg) void {
    my str $filename = $parser->{"filename"};
    my int $line = parser_current_line($parser);
    if (length($filename) > 0) {
        die($filename . ":" . $line . ": " . $msg);
    } else {
        die("line " . $line . ": " . $msg);
    }
}

func parser_current(scalar $parser) scalar {
    my scalar $tokens = $parser->{"tokens"};
    my int $pos = $parser->{"pos"};
    return $tokens->[$pos];
}

func parser_peek(scalar $parser) scalar {
    my scalar $tokens = $parser->{"tokens"};
    my int $pos = $parser->{"pos"} + 1;
    if ($pos >= $parser->{"token_count"}) {
        return parser_current($parser);
    }
    return $tokens->[$pos];
}

func parser_advance(scalar $parser) void {
    if ($parser->{"pos"} < $parser->{"token_count"} - 1) {
        $parser->{"pos"} = $parser->{"pos"} + 1;
    }
}

func parser_expect(scalar $parser, str $expected_type) void {
    my scalar $tok = parser_current($parser);
    if ($tok->{"type"} ne $expected_type) {
        parser_error($parser, "expected " . $expected_type . ", got " . $tok->{"type"});
    }
    parser_advance($parser);
}

func parser_match(scalar $parser, str $type) int {
    my scalar $tok = parser_current($parser);
    if ($tok->{"type"} eq $type) {
        parser_advance($parser);
        return 1;
    }
    return 0;
}

func parser_check(scalar $parser, str $type) int {
    my scalar $tok = parser_current($parser);
    return $tok->{"type"} eq $type;
}

# Get current token's line number
func parser_current_line(scalar $parser) int {
    my scalar $tok = parser_current($parser);
    return $tok->{"line"};
}

# Parse a variable name - allows type keywords as variable names
func parse_var_name(scalar $parser) str {
    my scalar $tok = parser_current($parser);
    my str $type_str = $tok->{"type"};
    
    # Regular identifier
    if ($type_str eq "IDENT") {
        parser_advance($parser);
        return $tok->{"value"};
    }
    
    # Type keywords can be used as variable names ($int, $num, etc.)
    if ($type_str eq "TYPE_INT") {
        parser_advance($parser);
        return "int";
    }
    if ($type_str eq "TYPE_NUM") {
        parser_advance($parser);
        return "num";
    }
    if ($type_str eq "TYPE_STR") {
        parser_advance($parser);
        return "str";
    }
    if ($type_str eq "TYPE_BOOL") {
        parser_advance($parser);
        return "bool";
    }
    if ($type_str eq "TYPE_ARRAY") {
        parser_advance($parser);
        return "array";
    }
    if ($type_str eq "TYPE_HASH") {
        parser_advance($parser);
        return "hash";
    }
    if ($type_str eq "TYPE_SCALAR") {
        parser_advance($parser);
        return "scalar";
    }
    if ($type_str eq "TYPE_VOID") {
        parser_advance($parser);
        return "void";
    }
    # Explicit sized types for extern functions (C interop)
    if ($type_str eq "TYPE_INT32") {
        parser_advance($parser);
        return "int32";
    }
    if ($type_str eq "TYPE_INT64") {
        parser_advance($parser);
        return "int64";
    }
    if ($type_str eq "TYPE_FLOAT32") {
        parser_advance($parser);
        return "float32";
    }
    if ($type_str eq "TYPE_FLOAT64") {
        parser_advance($parser);
        return "float64";
    }
    if ($type_str eq "TYPE_INT8") {
        parser_advance($parser);
        return "int8";
    }
    if ($type_str eq "TYPE_INT16") {
        parser_advance($parser);
        return "int16";
    }
    if ($type_str eq "TYPE_UINT8") {
        parser_advance($parser);
        return "uint8";
    }
    if ($type_str eq "TYPE_UINT16") {
        parser_advance($parser);
        return "uint16";
    }
    if ($type_str eq "TYPE_UINT32") {
        parser_advance($parser);
        return "uint32";
    }
    if ($type_str eq "TYPE_UINT64") {
        parser_advance($parser);
        return "uint64";
    }
    if ($type_str eq "TYPE_SIZE_T") {
        parser_advance($parser);
        return "size_t";
    }
    if ($type_str eq "TYPE_CHAR") {
        parser_advance($parser);
        return "char";
    }
    if ($type_str eq "TYPE_LONG_DOUBLE") {
        parser_advance($parser);
        return "long_double";
    }

    # Other keywords that can be used as variable names
    if ($type_str eq "VERSION") {
        parser_advance($parser);
        return "version";
    }

    # Loop control keywords
    if ($type_str eq "LAST") {
        parser_advance($parser);
        return "last";
    }
    if ($type_str eq "NEXT") {
        parser_advance($parser);
        return "next";
    }

    # String comparison operators (eq, ne, lt, gt, le, ge)
    if ($type_str eq "STR_EQ") {
        parser_advance($parser);
        return "eq";
    }
    if ($type_str eq "STR_NE") {
        parser_advance($parser);
        return "ne";
    }
    if ($type_str eq "STR_LT") {
        parser_advance($parser);
        return "lt";
    }
    if ($type_str eq "STR_GT") {
        parser_advance($parser);
        return "gt";
    }
    if ($type_str eq "STR_LE") {
        parser_advance($parser);
        return "le";
    }
    if ($type_str eq "STR_GE") {
        parser_advance($parser);
        return "ge";
    }
    if ($type_str eq "STR_CMP") {
        parser_advance($parser);
        return "cmp";
    }

    # Control flow keywords
    if ($type_str eq "IF") {
        parser_advance($parser);
        return "if";
    }
    if ($type_str eq "ELSE") {
        parser_advance($parser);
        return "else";
    }
    if ($type_str eq "ELSIF") {
        parser_advance($parser);
        return "elsif";
    }
    if ($type_str eq "WHILE") {
        parser_advance($parser);
        return "while";
    }
    if ($type_str eq "FOR") {
        parser_advance($parser);
        return "for";
    }
    if ($type_str eq "FOREACH") {
        parser_advance($parser);
        return "foreach";
    }
    if ($type_str eq "RETURN") {
        parser_advance($parser);
        return "return";
    }
    if ($type_str eq "TRY") {
        parser_advance($parser);
        return "try";
    }
    if ($type_str eq "CATCH") {
        parser_advance($parser);
        return "catch";
    }
    if ($type_str eq "THROW") {
        parser_advance($parser);
        return "throw";
    }
    if ($type_str eq "GOTO") {
        parser_advance($parser);
        return "goto";
    }
    if ($type_str eq "SWITCH") {
        parser_advance($parser);
        return "switch";
    }
    if ($type_str eq "CASE") {
        parser_advance($parser);
        return "case";
    }
    if ($type_str eq "DEFAULT") {
        parser_advance($parser);
        return "default";
    }

    # Declaration keywords
    if ($type_str eq "MY") {
        parser_advance($parser);
        return "my";
    }
    if ($type_str eq "FUNC") {
        parser_advance($parser);
        return "func";
    }
    if ($type_str eq "EXTERN") {
        parser_advance($parser);
        return "extern";
    }
    if ($type_str eq "STRUCT") {
        parser_advance($parser);
        return "struct";
    }
    if ($type_str eq "PACKAGE") {
        parser_advance($parser);
        return "package";
    }
    if ($type_str eq "USE") {
        parser_advance($parser);
        return "use";
    }
    if ($type_str eq "IMPORT_LIB") {
        parser_advance($parser);
        return "import_lib";
    }
    if ($type_str eq "IMPORT_OBJECT") {
        parser_advance($parser);
        return "import_object";
    }
    if ($type_str eq "INHERIT") {
        parser_advance($parser);
        return "inherit";
    }

    # Built-in functions that are keywords
    if ($type_str eq "UNDEF") {
        parser_advance($parser);
        return "undef";
    }
    if ($type_str eq "MAP") {
        parser_advance($parser);
        return "map";
    }
    if ($type_str eq "SORT") {
        parser_advance($parser);
        return "sort";
    }
    if ($type_str eq "GREP") {
        parser_advance($parser);
        return "grep";
    }
    if ($type_str eq "ASYNC") {
        parser_advance($parser);
        return "async";
    }
    if ($type_str eq "AWAIT") {
        parser_advance($parser);
        return "await";
    }

    parser_error($parser, "expected variable name, got " . $type_str);
}

# ============================================================
# Type Parsing
# ============================================================

func parse_type(scalar $parser) int {
    my scalar $tok = parser_current($parser);
    my str $type_str = $tok->{"type"};
    
    # Clear last type name
    $parser->{"last_type_name"} = "";
    
    if ($type_str eq "TYPE_INT") {
        parser_advance($parser);
        return TYPE_INT();
    }
    if ($type_str eq "TYPE_NUM") {
        parser_advance($parser);
        return TYPE_NUM();
    }
    if ($type_str eq "TYPE_STR") {
        parser_advance($parser);
        return TYPE_STR();
    }
    if ($type_str eq "TYPE_BOOL") {
        parser_advance($parser);
        return TYPE_BOOL();
    }
    if ($type_str eq "TYPE_ARRAY") {
        parser_advance($parser);
        return TYPE_ARRAY();
    }
    if ($type_str eq "TYPE_HASH") {
        parser_advance($parser);
        return TYPE_HASH();
    }
    if ($type_str eq "TYPE_SCALAR") {
        parser_advance($parser);
        return TYPE_SCALAR();
    }
    if ($type_str eq "TYPE_VOID") {
        parser_advance($parser);
        return TYPE_VOID();
    }
    # Explicit sized types for extern functions (C interop)
    if ($type_str eq "TYPE_INT32") {
        parser_advance($parser);
        return TYPE_INT32();
    }
    if ($type_str eq "TYPE_INT64") {
        parser_advance($parser);
        return TYPE_INT64();
    }
    if ($type_str eq "TYPE_FLOAT32") {
        parser_advance($parser);
        return TYPE_FLOAT32();
    }
    if ($type_str eq "TYPE_FLOAT64") {
        parser_advance($parser);
        return TYPE_FLOAT64();
    }
    if ($type_str eq "TYPE_INT8") {
        parser_advance($parser);
        return TYPE_INT8();
    }
    if ($type_str eq "TYPE_INT16") {
        parser_advance($parser);
        return TYPE_INT16();
    }
    if ($type_str eq "TYPE_UINT8") {
        parser_advance($parser);
        return TYPE_UINT8();
    }
    if ($type_str eq "TYPE_UINT16") {
        parser_advance($parser);
        return TYPE_UINT16();
    }
    if ($type_str eq "TYPE_UINT32") {
        parser_advance($parser);
        return TYPE_UINT32();
    }
    if ($type_str eq "TYPE_UINT64") {
        parser_advance($parser);
        return TYPE_UINT64();
    }
    if ($type_str eq "TYPE_SIZE_T") {
        parser_advance($parser);
        return TYPE_SIZE_T();
    }
    if ($type_str eq "TYPE_CHAR") {
        parser_advance($parser);
        return TYPE_CHAR();
    }
    if ($type_str eq "TYPE_LONG_DOUBLE") {
        parser_advance($parser);
        return TYPE_LONG_DOUBLE();
    }

    # Struct name (IDENT) - return TYPE_STRUCT and store name
    if ($type_str eq "IDENT") {
        $parser->{"last_type_name"} = $tok->{"value"};
        parser_advance($parser);
        return TYPE_STRUCT();
    }
    
    # Function pointer type: func(...) ReturnType
    if ($type_str eq "FUNC") {
        parser_advance($parser);
        parser_expect($parser, "LPAREN");
        # Skip parameter types
        while (!parser_check($parser, "RPAREN")) {
            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
            } else {
                parse_type($parser);  # Parse and discard param type
            }
        }
        parser_expect($parser, "RPAREN");
        my int $funcptr_ret = parse_type($parser);  # Parse return type
        $parser->{"last_funcptr_return"} = $funcptr_ret;
        return TYPE_FUNCPTR();
    }
    
    parser_error($parser, "expected type, got " . $type_str);
}

# ============================================================
# Expression Parsing (Precedence Climbing)
# ============================================================

# Parse anonymous function: func (params) return_type { body }
# Called after 'func' and seeing LPAREN
func parse_anon_func(scalar $parser, int $line) scalar {
    parser_expect($parser, "LPAREN");

    my scalar $anon = ast_new_anon_func(TYPE_SCALAR());

    # Parse parameters
    if (!parser_check($parser, "RPAREN")) {
        # Parse first parameter
        my int $ptype = parse_type($parser);
        my str $sigil = "$";
        my str $pname = "";

        # Check for sigil
        if (parser_check($parser, "DOLLAR")) {
            parser_advance($parser);
            $sigil = "$";
        } elsif (parser_check($parser, "AT")) {
            parser_advance($parser);
            $sigil = "@";
        } elsif (parser_check($parser, "PERCENT")) {
            parser_advance($parser);
            $sigil = "%";
        }

        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $pname = $name_tok->{"value"};

        my scalar $param = ast_new_param($pname, $ptype, $sigil);
        ast_add_param($anon, $param);

        # Parse remaining parameters
        while (parser_check($parser, "COMMA")) {
            parser_advance($parser);

            $ptype = parse_type($parser);
            $sigil = "$";

            if (parser_check($parser, "DOLLAR")) {
                parser_advance($parser);
                $sigil = "$";
            } elsif (parser_check($parser, "AT")) {
                parser_advance($parser);
                $sigil = "@";
            } elsif (parser_check($parser, "PERCENT")) {
                parser_advance($parser);
                $sigil = "%";
            }

            $name_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            $pname = $name_tok->{"value"};

            $param = ast_new_param($pname, $ptype, $sigil);
            ast_add_param($anon, $param);
        }
    }

    parser_expect($parser, "RPAREN");

    # Optional return type
    if (parser_check($parser, "TYPE_INT")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_INT();
    } elsif (parser_check($parser, "TYPE_NUM")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_NUM();
    } elsif (parser_check($parser, "TYPE_STR")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_STR();
    } elsif (parser_check($parser, "TYPE_BOOL")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_BOOL();
    } elsif (parser_check($parser, "TYPE_SCALAR")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_SCALAR();
    } elsif (parser_check($parser, "TYPE_VOID")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_VOID();
    } elsif (parser_check($parser, "TYPE_INT32")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_INT32();
    } elsif (parser_check($parser, "TYPE_INT64")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_INT64();
    } elsif (parser_check($parser, "TYPE_FLOAT32")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_FLOAT32();
    } elsif (parser_check($parser, "TYPE_FLOAT64")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_FLOAT64();
    } elsif (parser_check($parser, "TYPE_INT8")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_INT8();
    } elsif (parser_check($parser, "TYPE_INT16")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_INT16();
    } elsif (parser_check($parser, "TYPE_UINT8")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_UINT8();
    } elsif (parser_check($parser, "TYPE_UINT16")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_UINT16();
    } elsif (parser_check($parser, "TYPE_UINT32")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_UINT32();
    } elsif (parser_check($parser, "TYPE_UINT64")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_UINT64();
    } elsif (parser_check($parser, "TYPE_SIZE_T")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_SIZE_T();
    } elsif (parser_check($parser, "TYPE_CHAR")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_CHAR();
    } elsif (parser_check($parser, "TYPE_LONG_DOUBLE")) {
        parser_advance($parser);
        $anon->{"return_type"} = TYPE_LONG_DOUBLE();
    }

    # Parse body
    $anon->{"body"} = parse_block($parser);

    ast_set_line($anon, $line);
    return $anon;
}

# Primary expressions: literals, variables, parenthesized, etc.
func parse_primary(scalar $parser) scalar {
    my scalar $tok = parser_current($parser);
    my str $type = $tok->{"type"};
    
    # Integer literal
    if ($type eq "INT_LITERAL") {
        parser_advance($parser);
        return ast_new_int_literal($tok->{"value"});
    }
    
    # Number literal
    if ($type eq "NUM_LITERAL") {
        parser_advance($parser);
        return ast_new_num_literal($tok->{"value"});
    }
    
    # String literal
    if ($type eq "STR_LITERAL") {
        parser_advance($parser);
        return ast_new_str_literal($tok->{"value"});
    }

    # Interpolated string - build concatenation chain
    if ($type eq "INTERP_STRING") {
        parser_advance($parser);
        my scalar $parts = $tok->{"parts"};
        my scalar $vars = $tok->{"vars"};
        my int $num_vars = $tok->{"var_count"};

        # Start with the first part
        my scalar $result = ast_new_str_literal($parts->[0]);

        # Alternate: variable, then next part
        my int $i = 0;
        while ($i < $num_vars) {
            # Concatenate variable
            my str $vname = $vars->[$i];
            my scalar $var_node = ast_new_variable($vname, "$");
            $result = ast_new_binary_op(".", $result, $var_node);

            # Concatenate next string part
            my scalar $part_node = ast_new_str_literal($parts->[$i + 1]);
            $result = ast_new_binary_op(".", $result, $part_node);

            $i = $i + 1;
        }

        return $result;
    }

    # qw() - quote words, returns anonymous array of strings
    if ($type eq "QW_LITERAL") {
        parser_advance($parser);
        my scalar $words = $tok->{"words"};
        my int $len = $tok->{"word_count"};
        my scalar $arr_node = ast_new_anon_array();
        my int $i = 0;
        while ($i < $len) {
            ast_add_array_elem($arr_node, ast_new_str_literal($words->[$i]));
            $i = $i + 1;
        }
        return $arr_node;
    }

    # undef literal
    if ($type eq "UNDEF") {
        parser_advance($parser);
        return ast_new_undef();
    }

    # Diamond operator <$fh> - reads line from filehandle
    if ($type eq "DIAMOND") {
        parser_advance($parser);
        my str $varname = $tok->{"value"};
        return ast_new_readline($varname);
    }

    # __PACKAGE__ - returns current package name OR compile-time qualified call
    if ($type eq "DUNDER_PACKAGE") {
        my int $pkg_line = parser_current_line($parser);
        parser_advance($parser);

        # Check for __PACKAGE__::funcname - compile-time resolution
        if (parser_check($parser, "DOUBLE_COLON")) {
            parser_advance($parser);
            my scalar $func_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            my str $func_name = $func_tok->{"value"};

            # Build qualified name using compile-time package
            my str $pkg = $parser->{"current_package"};
            if (length($pkg) > 0) {
                # Convert Package::Sub to Package_Sub for C function name
                my str $sanitized = "";
                my int $i = 0;
                my int $plen = length($pkg);
                while ($i < $plen) {
                    my str $ch = substr($pkg, $i, 1);
                    if ($ch eq ":" && $i + 1 < $plen && substr($pkg, $i + 1, 1) eq ":") {
                        $sanitized = $sanitized . "_";
                        $i = $i + 2;
                    } else {
                        $sanitized = $sanitized . $ch;
                        $i = $i + 1;
                    }
                }
                $func_name = $sanitized . "_" . $func_name;
            }

            # Must be followed by function call
            if (!parser_check($parser, "LPAREN")) {
                parser_error($parser, "expected ( after __PACKAGE__::" . $func_tok->{"value"});
            }
            parser_advance($parser);
            my scalar $call = ast_new_call($func_name);
            ast_set_line($call, $pkg_line);

            # Parse arguments (with spread operator support)
            if (!parser_check($parser, "RPAREN")) {
                if (parser_check($parser, "ELLIPSIS")) {
                    parser_advance($parser);
                    my scalar $spread_target = parse_expression($parser);
                    my scalar $spread = ast_new_spread($spread_target);
                    ast_add_arg($call, $spread);
                } else {
                    my scalar $arg = parse_expression($parser);
                    ast_add_arg($call, $arg);
                }

                while (parser_check($parser, "COMMA")) {
                    parser_advance($parser);
                    if (parser_check($parser, "ELLIPSIS")) {
                        parser_advance($parser);
                        my scalar $spread_target = parse_expression($parser);
                        my scalar $spread = ast_new_spread($spread_target);
                        ast_add_arg($call, $spread);
                    } else {
                        my scalar $next_arg = parse_expression($parser);
                        ast_add_arg($call, $next_arg);
                    }
                }
            }

            parser_expect($parser, "RPAREN");
            return $call;
        }

        # Plain __PACKAGE__ - runtime value
        return ast_new_dunder_package();
    }

    # ::func() - shorthand for __PACKAGE__::func()
    if ($type eq "DOUBLE_COLON") {
        my int $pkg_line = parser_current_line($parser);
        parser_advance($parser);

        my scalar $func_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        my str $func_name = $func_tok->{"value"};

        # Build qualified name using compile-time package
        my str $pkg = $parser->{"current_package"};
        if (length($pkg) > 0) {
            # Convert Package::Sub to Package_Sub for C function name
            my str $sanitized = "";
            my int $i = 0;
            my int $plen = length($pkg);
            while ($i < $plen) {
                my str $ch = substr($pkg, $i, 1);
                if ($ch eq ":" && $i + 1 < $plen && substr($pkg, $i + 1, 1) eq ":") {
                    $sanitized = $sanitized . "_";
                    $i = $i + 2;
                } else {
                    $sanitized = $sanitized . $ch;
                    $i = $i + 1;
                }
            }
            $func_name = $sanitized . "_" . $func_name;
        }

        # Must be followed by function call
        if (!parser_check($parser, "LPAREN")) {
            parser_error($parser, "expected ( after ::" . $func_tok->{"value"});
        }
        parser_advance($parser);
        my scalar $call = ast_new_call($func_name);
        ast_set_line($call, $pkg_line);

        # Parse arguments (with spread operator support)
        if (!parser_check($parser, "RPAREN")) {
            if (parser_check($parser, "ELLIPSIS")) {
                parser_advance($parser);
                my scalar $spread_target = parse_expression($parser);
                my scalar $spread = ast_new_spread($spread_target);
                ast_add_arg($call, $spread);
            } else {
                my scalar $arg = parse_expression($parser);
                ast_add_arg($call, $arg);
            }

            while (parser_check($parser, "COMMA")) {
                parser_advance($parser);
                if (parser_check($parser, "ELLIPSIS")) {
                    parser_advance($parser);
                    my scalar $spread_target = parse_expression($parser);
                    my scalar $spread = ast_new_spread($spread_target);
                    ast_add_arg($call, $spread);
                } else {
                    my scalar $next_arg = parse_expression($parser);
                    ast_add_arg($call, $next_arg);
                }
            }
        }

        parser_expect($parser, "RPAREN");
        return $call;
    }

    # .::func() - alternate shorthand for __PACKAGE__::func()
    if ($type eq "DOT") {
        # Peek ahead to see if this is .:: pattern
        my scalar $peek_tok = parser_peek($parser);
        my str $peek_type = $peek_tok->{"type"};
        if ($peek_type eq "DOUBLE_COLON") {
            my int $pkg_line = parser_current_line($parser);
            parser_advance($parser);  # consume DOT
            parser_advance($parser);  # consume DOUBLE_COLON

            my scalar $func_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            my str $func_name = $func_tok->{"value"};

            # Build qualified name using compile-time package
            my str $pkg = $parser->{"current_package"};
            if (length($pkg) > 0) {
                # Convert Package::Sub to Package_Sub for C function name
                my str $sanitized = "";
                my int $i = 0;
                my int $plen = length($pkg);
                while ($i < $plen) {
                    my str $ch = substr($pkg, $i, 1);
                    if ($ch eq ":" && $i + 1 < $plen && substr($pkg, $i + 1, 1) eq ":") {
                        $sanitized = $sanitized . "_";
                        $i = $i + 2;
                    } else {
                        $sanitized = $sanitized . $ch;
                        $i = $i + 1;
                    }
                }
                $func_name = $sanitized . "_" . $func_name;
            }

            # Must be followed by function call
            if (!parser_check($parser, "LPAREN")) {
                parser_error($parser, "expected ( after .::" . $func_tok->{"value"});
            }
            parser_advance($parser);
            my scalar $call = ast_new_call($func_name);
            ast_set_line($call, $pkg_line);

            # Parse arguments (with spread operator support)
            if (!parser_check($parser, "RPAREN")) {
                if (parser_check($parser, "ELLIPSIS")) {
                    parser_advance($parser);
                    my scalar $spread_target = parse_expression($parser);
                    my scalar $spread = ast_new_spread($spread_target);
                    ast_add_arg($call, $spread);
                } else {
                    my scalar $arg = parse_expression($parser);
                    ast_add_arg($call, $arg);
                }

                while (parser_check($parser, "COMMA")) {
                    parser_advance($parser);
                    if (parser_check($parser, "ELLIPSIS")) {
                        parser_advance($parser);
                        my scalar $spread_target = parse_expression($parser);
                        my scalar $spread = ast_new_spread($spread_target);
                        ast_add_arg($call, $spread);
                    } else {
                        my scalar $next_arg = parse_expression($parser);
                        ast_add_arg($call, $next_arg);
                    }
                }
            }

            parser_expect($parser, "RPAREN");
            return $call;
        }
    }

    # __FILE__ - returns current file name
    if ($type eq "DUNDER_FILE") {
        parser_advance($parser);
        return ast_new_dunder_file();
    }

    # __LINE__ - returns current line number
    if ($type eq "DUNDER_LINE") {
        my int $line = parser_current_line($parser);
        parser_advance($parser);
        return ast_new_dunder_line($line);
    }

    # Variable or function call
    if ($type eq "DOLLAR") {
        my int $var_line = parser_current_line($parser);
        parser_advance($parser);

        # Check for $$var or $${expr} scalar dereference syntax
        if (parser_check($parser, "DOLLAR")) {
            parser_advance($parser);

            # Check for $${expr} syntax
            if (parser_check($parser, "LBRACE")) {
                parser_advance($parser);
                my scalar $ref_expr = parse_expression($parser);
                parser_expect($parser, "RBRACE");
                my scalar $deref = ast_new_deref_scalar($ref_expr, "$");
                ast_set_line($deref, $var_line);
                return $deref;
            }

            # Simple $$var syntax
            my str $ref_name = parse_var_name($parser);
            my scalar $ref_var = ast_new_variable($ref_name, "$");
            ast_set_line($ref_var, $var_line);
            my scalar $deref = ast_new_deref_scalar($ref_var, "$");
            ast_set_line($deref, $var_line);
            return $deref;
        }

        my str $var_name = parse_var_name($parser);

        # Check for arrow dereference
        if (parser_check($parser, "ARROW")) {
            my scalar $var = ast_new_variable($var_name, "$");
            ast_set_line($var, $var_line);
            return parse_postfix($parser, $var);
        }

        # Check for hash access $var{key} - Perl style: accesses %var
        if (parser_check($parser, "LBRACE")) {
            parser_advance($parser);
            my scalar $key = parse_expression($parser);
            parser_expect($parser, "RBRACE");
            my scalar $var = ast_new_variable($var_name, "%");
            ast_set_line($var, $var_line);
            my scalar $access = ast_new_hash_access($var, $key);
            ast_set_line($access, $var_line);
            return $access;
        }

        # Check for array access $var[idx] - Perl style: accesses @var
        if (parser_check($parser, "LBRACKET")) {
            parser_advance($parser);
            my scalar $idx = parse_expression($parser);
            parser_expect($parser, "RBRACKET");
            my scalar $var = ast_new_variable($var_name, "@");
            ast_set_line($var, $var_line);
            my scalar $sub = ast_new_subscript($var, $idx);
            ast_set_line($sub, $var_line);
            return $sub;
        }

        my scalar $var = ast_new_variable($var_name, "$");
        ast_set_line($var, $var_line);
        return $var;
    }

    # Array variable or @{expr} dereference
    if ($type eq "AT") {
        my int $var_line = parser_current_line($parser);
        parser_advance($parser);

        # Check for @{expr} dereference syntax
        if (parser_check($parser, "LBRACE")) {
            parser_advance($parser);
            my scalar $ref_expr = parse_expression($parser);
            parser_expect($parser, "RBRACE");
            my scalar $deref = ast_new_deref_scalar($ref_expr, "@");
            ast_set_line($deref, $var_line);
            return $deref;
        }

        my str $arr_name = parse_var_name($parser);
        my scalar $var = ast_new_variable($arr_name, "@");
        ast_set_line($var, $var_line);
        return $var;
    }

    # Hash variable or %{expr} dereference
    if ($type eq "PERCENT") {
        my int $var_line = parser_current_line($parser);
        parser_advance($parser);

        # Check for %{expr} dereference syntax
        if (parser_check($parser, "LBRACE")) {
            parser_advance($parser);
            my scalar $ref_expr = parse_expression($parser);
            parser_expect($parser, "RBRACE");
            my scalar $deref = ast_new_deref_scalar($ref_expr, "%");
            ast_set_line($deref, $var_line);
            return $deref;
        }

        my str $hash_name = parse_var_name($parser);
        my scalar $var = ast_new_variable($hash_name, "%");
        ast_set_line($var, $var_line);
        return $var;
    }
    
    # Reference operator
    if ($type eq "BACKSLASH") {
        parser_advance($parser);
        my scalar $target = parse_primary($parser);

        # Determine reference type from target
        my str $ref_type = "$";
        if ($target->{"type"} == NODE_VARIABLE()) {
            $ref_type = $target->{"sigil"};
        } elsif ($target->{"type"} == NODE_FUNC_REF()) {
            $ref_type = "&";
        }

        return ast_new_ref($target, $ref_type);
    }
    
    # Anonymous hash { }
    if ($type eq "LBRACE") {
        parser_advance($parser);
        my scalar $anon = ast_new_anon_hash();
        
        # Empty hash check
        if (parser_check($parser, "RBRACE")) {
            parser_advance($parser);
            return $anon;
        }
        
        # Parse key => value pairs
        while (1) {
            # Key (string, bareword, or variable)
            my scalar $key_tok = parser_current($parser);
            my str $key = "";
            my scalar $key_expr = 0;

            if ($key_tok->{"type"} eq "STR_LITERAL" || $key_tok->{"type"} eq "IDENT") {
                $key = $key_tok->{"value"};
                parser_advance($parser);
            } elsif ($key_tok->{"type"} eq "DOLLAR") {
                # Variable key like $_ => 1 or $var => value
                $key_expr = parse_primary($parser);
            } else {
                parser_error($parser, "expected hash key");
            }

            parser_expect($parser, "FAT_ARROW");

            my scalar $value = parse_expression($parser);
            if ($key_expr) {
                ast_add_hash_pair_expr($anon, $key_expr, $value);
            } else {
                ast_add_hash_pair($anon, $key, $value);
            }
            
            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
                if (parser_check($parser, "RBRACE")) {
                    parser_advance($parser);
                    return $anon;
                }
            } else {
                parser_expect($parser, "RBRACE");
                return $anon;
            }
        }
    }
    
    # Anonymous array [ ]
    if ($type eq "LBRACKET") {
        parser_advance($parser);
        my scalar $anon = ast_new_anon_array();
        
        # Empty array check
        if (parser_check($parser, "RBRACKET")) {
            parser_advance($parser);
            return $anon;
        }
        
        # Parse elements
        while (1) {
            my scalar $elem = parse_expression($parser);
            ast_add_array_elem($anon, $elem);
            
            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
                if (parser_check($parser, "RBRACKET")) {
                    parser_advance($parser);
                    return $anon;
                }
            } else {
                parser_expect($parser, "RBRACKET");
                return $anon;
            }
        }
    }
    
    # Parenthesized expression, array literal (1, 2, 3), or empty ()
    if ($type eq "LPAREN") {
        parser_advance($parser);
        
        # Empty () - returns empty hash/array depending on context
        if (parser_check($parser, "RPAREN")) {
            parser_advance($parser);
            return ast_new_anon_hash();
        }
        
        my scalar $first = parse_expression($parser);
        
        # Check if this is an array literal (has comma)
        if (parser_check($parser, "COMMA")) {
            my scalar $arr = ast_new_anon_array();
            ast_add_array_elem($arr, $first);
            
            while (parser_check($parser, "COMMA")) {
                parser_advance($parser);
                if (parser_check($parser, "RPAREN")) {
                    # Trailing comma allowed
                    last;
                }
                my scalar $elem = parse_expression($parser);
                ast_add_array_elem($arr, $elem);
            }
            parser_expect($parser, "RPAREN");
            return $arr;
        }
        
        # Single expression in parens
        parser_expect($parser, "RPAREN");
        return $first;
    }
    
    # Handle async:: namespace (async is a keyword, but async::func is a namespace call)
    if ($type eq "ASYNC") {
        # Check if next token is DOUBLE_COLON - if so, this is a namespace call
        my scalar $next_tok = parser_peek($parser);
        if ($next_tok->{"type"} eq "DOUBLE_COLON") {
            my str $name = "async";
            my int $call_line = $tok->{"line"};
            parser_advance($parser);  # consume ASYNC

            # Now handle like an IDENT with DOUBLE_COLON
            while (parser_check($parser, "DOUBLE_COLON")) {
                parser_advance($parser);
                my scalar $part_tok = parser_current($parser);
                parser_expect($parser, "IDENT");
                $name = $name . "::" . $part_tok->{"value"};
            }

            # Should be followed by function call
            if (parser_check($parser, "LPAREN")) {
                parser_advance($parser);
                my scalar $call = ast_new_call($name);
                ast_set_line($call, $call_line);

                if (!parser_check($parser, "RPAREN")) {
                    if (parser_check($parser, "ELLIPSIS")) {
                        parser_advance($parser);
                        my scalar $spread_target = parse_expression($parser);
                        my scalar $spread = ast_new_spread($spread_target);
                        ast_add_arg($call, $spread);
                    } else {
                        my scalar $arg = parse_expression($parser);
                        ast_add_arg($call, $arg);
                    }

                    while (parser_check($parser, "COMMA")) {
                        parser_advance($parser);
                        if (parser_check($parser, "ELLIPSIS")) {
                            parser_advance($parser);
                            my scalar $spread_target = parse_expression($parser);
                            my scalar $spread = ast_new_spread($spread_target);
                            ast_add_arg($call, $spread);
                        } else {
                            my scalar $next_arg = parse_expression($parser);
                            ast_add_arg($call, $next_arg);
                        }
                    }
                }

                parser_expect($parser, "RPAREN");
                return $call;
            }

            # async::something without () - treat as variable (shouldn't happen normally)
            return ast_new_variable($name, "$");
        }
        # Fall through - ASYNC not followed by :: is handled elsewhere (in parse_unary for await, parse_program for async func)
    }

    # Function call (bareword)
    if ($type eq "IDENT") {
        my str $name = $tok->{"value"};
        my int $call_line = $tok->{"line"};
        parser_advance($parser);

        # Check for function call
        if (parser_check($parser, "LPAREN")) {
            parser_advance($parser);
            my scalar $call = ast_new_call($name);
            ast_set_line($call, $call_line);

            # Parse arguments (with spread operator support)
            if (!parser_check($parser, "RPAREN")) {
                # Check for spread operator
                if (parser_check($parser, "ELLIPSIS")) {
                    parser_advance($parser);
                    my scalar $spread_target = parse_expression($parser);
                    my scalar $spread = ast_new_spread($spread_target);
                    ast_add_arg($call, $spread);
                } else {
                    my scalar $arg = parse_expression($parser);
                    ast_add_arg($call, $arg);
                }

                while (parser_check($parser, "COMMA")) {
                    parser_advance($parser);
                    # Check for spread operator
                    if (parser_check($parser, "ELLIPSIS")) {
                        parser_advance($parser);
                        my scalar $spread_target = parse_expression($parser);
                        my scalar $spread = ast_new_spread($spread_target);
                        ast_add_arg($call, $spread);
                    } else {
                        my scalar $next_arg = parse_expression($parser);
                        ast_add_arg($call, $next_arg);
                    }
                }
            }

            parser_expect($parser, "RPAREN");
            return $call;
        }

        # Check for SUPER::method() call
        if ($name eq "SUPER" && parser_check($parser, "DOUBLE_COLON")) {
            parser_advance($parser);
            my scalar $method_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            my str $method_name = $method_tok->{"value"};

            # SUPER::method must be followed by ()
            if (!parser_check($parser, "LPAREN")) {
                parser_error($parser, "expected ( after SUPER::" . $method_name);
            }
            parser_advance($parser);
            my scalar $super_call = ast_new_super_call($method_name);
            ast_set_line($super_call, $call_line);

            # Parse arguments (with spread operator support)
            if (!parser_check($parser, "RPAREN")) {
                # Check for spread operator
                if (parser_check($parser, "ELLIPSIS")) {
                    parser_advance($parser);
                    my scalar $spread_target = parse_expression($parser);
                    my scalar $spread = ast_new_spread($spread_target);
                    ast_add_arg($super_call, $spread);
                } else {
                    my scalar $arg = parse_expression($parser);
                    ast_add_arg($super_call, $arg);
                }

                while (parser_check($parser, "COMMA")) {
                    parser_advance($parser);
                    # Check for spread operator
                    if (parser_check($parser, "ELLIPSIS")) {
                        parser_advance($parser);
                        my scalar $spread_target = parse_expression($parser);
                        my scalar $spread = ast_new_spread($spread_target);
                        ast_add_arg($super_call, $spread);
                    } else {
                        my scalar $next_arg = parse_expression($parser);
                        ast_add_arg($super_call, $next_arg);
                    }
                }
            }

            parser_expect($parser, "RPAREN");
            return $super_call;
        }

        # Check for qualified name (Package::func)
        if (parser_check($parser, "DOUBLE_COLON")) {
            while (parser_check($parser, "DOUBLE_COLON")) {
                parser_advance($parser);
                my scalar $next_tok = parser_current($parser);
                parser_expect($parser, "IDENT");
                $name = $name . "::" . $next_tok->{"value"};
            }

            # Check for function call
            if (parser_check($parser, "LPAREN")) {
                parser_advance($parser);
                my scalar $call = ast_new_call($name);
                ast_set_line($call, $call_line);

                # Parse arguments (with spread operator support)
                if (!parser_check($parser, "RPAREN")) {
                    # Check for spread operator
                    if (parser_check($parser, "ELLIPSIS")) {
                        parser_advance($parser);
                        my scalar $spread_target = parse_expression($parser);
                        my scalar $spread = ast_new_spread($spread_target);
                        ast_add_arg($call, $spread);
                    } else {
                        my scalar $arg = parse_expression($parser);
                        ast_add_arg($call, $arg);
                    }

                    while (parser_check($parser, "COMMA")) {
                        parser_advance($parser);
                        # Check for spread operator
                        if (parser_check($parser, "ELLIPSIS")) {
                            parser_advance($parser);
                            my scalar $spread_target = parse_expression($parser);
                            my scalar $spread = ast_new_spread($spread_target);
                            ast_add_arg($call, $spread);
                        } else {
                            my scalar $next_arg = parse_expression($parser);
                            ast_add_arg($call, $next_arg);
                        }
                    }
                }

                parser_expect($parser, "RPAREN");
                return $call;
            }

            # Qualified name without parens - treat as constant (e.g., enum value)
            # Create a 0-arg call node, codegen will handle it as a constant
            my scalar $const_ref = ast_new_call($name);
            $const_ref->{"is_constant"} = 1;
            ast_set_line($const_ref, $call_line);
            return $const_ref;
        }

        # Just an identifier (bareword string in some contexts)
        return ast_new_str_literal($name);
    }

    # inherit() function call when used inside a function body
    if ($type eq "INHERIT") {
        my int $call_line = parser_current_line($parser);
        parser_advance($parser);
        if (parser_check($parser, "LPAREN")) {
            parser_advance($parser);
            my scalar $call = ast_new_call("inherit");
            ast_set_line($call, $call_line);
            if (!parser_check($parser, "RPAREN")) {
                my scalar $arg = parse_expression($parser);
                ast_add_arg($call, $arg);
                while (parser_check($parser, "COMMA")) {
                    parser_advance($parser);
                    my scalar $next_arg = parse_expression($parser);
                    ast_add_arg($call, $next_arg);
                }
            }
            parser_expect($parser, "RPAREN");
            return $call;
        }
        parser_error($parser, "expected ( after inherit");
    }

    # scalar() function - TYPE_SCALAR followed by (
    if ($type eq "TYPE_SCALAR") {
        my int $call_line = parser_current_line($parser);
        parser_advance($parser);
        if (parser_check($parser, "LPAREN")) {
            parser_advance($parser);
            my scalar $call = ast_new_call("scalar");
            ast_set_line($call, $call_line);
            if (!parser_check($parser, "RPAREN")) {
                my scalar $arg = parse_expression($parser);
                ast_add_arg($call, $arg);
            }
            parser_expect($parser, "RPAREN");
            return $call;
        }
        parser_error($parser, "unexpected TYPE_SCALAR in expression");
    }
    
    # Unary minus
    if ($type eq "MINUS") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_unary_op("-", $operand);
    }
    
    # Logical not
    if ($type eq "NOT") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_unary_op("!", $operand);
    }
    
    # Function reference (&func_name)
    if ($type eq "AMPERSAND") {
        parser_advance($parser);
        my scalar $func_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        return ast_new_func_ref($func_tok->{"value"});
    }

    # map { block } @array - transforms each element using $_
    if ($type eq "MAP") {
        my int $map_line = parser_current_line($parser);
        parser_advance($parser);
        parser_expect($parser, "LBRACE");
        my scalar $block = ast_new_block();

        # Parse block body - can be statements with ; or bare expression
        while (!parser_check($parser, "RBRACE") && !parser_check($parser, "EOF")) {
            # Parse expression first
            my scalar $expr = parse_expression($parser);
            # Check if this is a full statement (with ;) or bare expression
            if (parser_check($parser, "SEMI")) {
                parser_advance($parser);
                ast_add_statement($block, ast_new_expr_stmt($expr));
            } elsif (parser_check($parser, "RBRACE")) {
                # Bare expression at end of block (e.g., map { $_ => 1 })
                ast_add_statement($block, ast_new_expr_stmt($expr));
            } else {
                parser_error($parser, "expected ; or } in map block");
            }
        }
        parser_expect($parser, "RBRACE");

        # Parse the array expression
        my scalar $array_expr = parse_unary($parser);
        my scalar $map_node = ast_new_map($block, $array_expr);
        ast_set_line($map_node, $map_line);
        return $map_node;
    }

    # sort { $a <=> $b } @array - sorts array using comparator block
    if ($type eq "SORT") {
        my int $sort_line = parser_current_line($parser);
        parser_advance($parser);

        # Check if there's a block or just an array (default sort)
        if (parser_check($parser, "LBRACE")) {
            parser_advance($parser);
            my scalar $block = ast_new_block();

            # Parse block body
            while (!parser_check($parser, "RBRACE") && !parser_check($parser, "EOF")) {
                my scalar $stmt = parse_statement($parser);
                ast_add_statement($block, $stmt);
            }
            parser_expect($parser, "RBRACE");

            # Parse the array expression
            my scalar $array_expr = parse_unary($parser);
            my scalar $sort_node = ast_new_sort($block, $array_expr);
            ast_set_line($sort_node, $sort_line);
            return $sort_node;
        } else {
            # Default sort (no block) - use empty block
            my scalar $array_expr = parse_unary($parser);
            my scalar $sort_node = ast_new_sort(0, $array_expr);
            ast_set_line($sort_node, $sort_line);
            return $sort_node;
        }
    }

    # grep { block } @array - filters array elements using $_
    if ($type eq "GREP") {
        my int $grep_line = parser_current_line($parser);
        parser_advance($parser);
        parser_expect($parser, "LBRACE");
        my scalar $block = ast_new_block();

        # Parse block body - can be statements with ; or bare expression
        while (!parser_check($parser, "RBRACE") && !parser_check($parser, "EOF")) {
            my scalar $expr = parse_expression($parser);
            if (parser_check($parser, "SEMI")) {
                parser_advance($parser);
                ast_add_statement($block, ast_new_expr_stmt($expr));
            } elsif (parser_check($parser, "RBRACE")) {
                ast_add_statement($block, ast_new_expr_stmt($expr));
            } else {
                parser_error($parser, "expected ; or } in grep block");
            }
        }
        parser_expect($parser, "RBRACE");

        # Parse the array expression
        my scalar $array_expr = parse_unary($parser);
        my scalar $grep_node = ast_new_grep($block, $array_expr);
        ast_set_line($grep_node, $grep_line);
        return $grep_node;
    }

    # Anonymous function: func (params) { body }
    if ($type eq "FUNC") {
        my int $anon_line = parser_current_line($parser);
        parser_advance($parser);  # Skip 'func'

        # Check for LPAREN - if present, this is an anonymous function
        if (parser_check($parser, "LPAREN")) {
            return parse_anon_func($parser, $anon_line);
        }
        # Otherwise it's a parse error (named func should be at statement level)
        parser_error($parser, "unexpected 'func' in expression context");
    }

    parser_error($parser, "unexpected token in expression: " . $type);
}

# Parse postfix operations (-> derefs, function calls, subscripts)
func parse_postfix(scalar $parser, scalar $left) scalar {
    while (1) {
        if (parser_check($parser, "ARROW")) {
            parser_advance($parser);

            # Closure call ->(args)
            if (parser_check($parser, "LPAREN")) {
                parser_advance($parser);
                my array @args = ();
                my int $arg_count = 0;

                # Parse arguments
                if (!parser_check($parser, "RPAREN")) {
                    push(@args, parse_expression($parser));
                    $arg_count = $arg_count + 1;

                    while (parser_check($parser, "COMMA")) {
                        parser_advance($parser);
                        push(@args, parse_expression($parser));
                        $arg_count = $arg_count + 1;
                    }
                }
                parser_expect($parser, "RPAREN");
                $left = ast_new_closure_call($left, \@args, $arg_count);
            }
            # Hash dereference ->{key}
            elsif (parser_check($parser, "LBRACE")) {
                parser_advance($parser);
                my scalar $key = parse_expression($parser);
                parser_expect($parser, "RBRACE");
                $left = ast_new_deref_hash($left, $key);
            }
            # Array dereference ->[idx]
            elsif (parser_check($parser, "LBRACKET")) {
                parser_advance($parser);
                my scalar $idx = parse_expression($parser);
                parser_expect($parser, "RBRACKET");
                $left = ast_new_deref_array($left, $idx);
            }
            # Struct field access ->field or method call ->method()
            elsif (parser_check($parser, "IDENT")) {
                my scalar $field_tok = parser_current($parser);
                parser_advance($parser);
                my scalar $field = ast_new_field_access($left, $field_tok->{"value"});

                # Check for method call
                if (parser_check($parser, "LPAREN")) {
                    parser_advance($parser);
                    # For method calls, store both:
                    # - field: the FIELD_ACCESS node (needed for struct funcptr detection)
                    # - base_object: the original object (needed for OOP method calls)
                    my scalar $call = ast_new_method_call($field, $field_tok->{"value"});
                    $call->{"base_object"} = $left;

                    # Parse arguments (with spread operator support)
                    if (!parser_check($parser, "RPAREN")) {
                        # Check for spread operator
                        if (parser_check($parser, "ELLIPSIS")) {
                            parser_advance($parser);
                            my scalar $spread_target = parse_expression($parser);
                            my scalar $spread = ast_new_spread($spread_target);
                            ast_add_arg($call, $spread);
                        } else {
                            my scalar $arg = parse_expression($parser);
                            ast_add_arg($call, $arg);
                        }

                        while (parser_check($parser, "COMMA")) {
                            parser_advance($parser);
                            # Check for spread operator
                            if (parser_check($parser, "ELLIPSIS")) {
                                parser_advance($parser);
                                my scalar $spread_target = parse_expression($parser);
                                my scalar $spread = ast_new_spread($spread_target);
                                ast_add_arg($call, $spread);
                            } else {
                                my scalar $next_arg = parse_expression($parser);
                                ast_add_arg($call, $next_arg);
                            }
                        }
                    }
                    parser_expect($parser, "RPAREN");
                    $left = $call;
                } else {
                    $left = $field;
                }
            }
            else {
                parser_error($parser, "expected {, [, or field name after ->");
            }
        }
        elsif (parser_check($parser, "LBRACE")) {
            # Check for invalid %hash{key} syntax - should use $hash{key}
            if ($left->{"type"} == NODE_VARIABLE()) {
                my str $sigil = $left->{"sigil"};
                if ($sigil eq "%") {
                    parser_error($parser, "use $hash{key} for hash element access (hash sigil not allowed here)");
                }
                if ($sigil eq "@") {
                    parser_error($parser, "cannot use hash subscript {key} on array variable");
                }
            }
            parser_advance($parser);
            my scalar $key = parse_expression($parser);
            parser_expect($parser, "RBRACE");
            $left = ast_new_hash_access($left, $key);
        }
        elsif (parser_check($parser, "LBRACKET")) {
            # Check for invalid %hash[idx] syntax (but allow @arr[idx] for compatibility)
            if ($left->{"type"} == NODE_VARIABLE()) {
                my str $sigil = $left->{"sigil"};
                if ($sigil eq "%") {
                    parser_error($parser, "cannot use array subscript [idx] on hash variable");
                }
            }
            parser_advance($parser);
            my scalar $idx = parse_expression($parser);
            parser_expect($parser, "RBRACKET");
            $left = ast_new_subscript($left, $idx);
        }
        elsif (parser_check($parser, "PLUSPLUS")) {
            parser_advance($parser);
            $left = ast_new_increment("++", $left, 0);
        }
        elsif (parser_check($parser, "MINUSMINUS")) {
            parser_advance($parser);
            $left = ast_new_increment("--", $left, 0);
        }
        else {
            return $left;
        }
    }
}

# Unary expressions
func parse_unary(scalar $parser) scalar {
    my scalar $tok = parser_current($parser);
    
    if ($tok->{"type"} eq "MINUS") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_unary_op("-", $operand);
    }
    
    if ($tok->{"type"} eq "NOT") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_unary_op("!", $operand);
    }

    if ($tok->{"type"} eq "TILDE") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_unary_op("~", $operand);
    }

    # Prefix increment/decrement
    if ($tok->{"type"} eq "PLUSPLUS") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_increment("++", $operand, 1);
    }

    if ($tok->{"type"} eq "MINUSMINUS") {
        parser_advance($parser);
        my scalar $operand = parse_unary($parser);
        return ast_new_increment("--", $operand, 1);
    }

    # await expression
    if ($tok->{"type"} eq "AWAIT") {
        my int $line = parser_current_line($parser);
        parser_advance($parser);
        my scalar $expr = parse_unary($parser);
        my scalar $await = ast_new_await($expr);
        ast_set_line($await, $line);
        return $await;
    }

    my scalar $primary = parse_primary($parser);
    return parse_postfix($parser, $primary);
}

# Power: ** (right-associative, higher precedence than multiplicative)
func parse_power(scalar $parser) scalar {
    my scalar $left = parse_unary($parser);

    my scalar $tok = parser_current($parser);
    if ($tok->{"type"} eq "POWER") {
        my str $op = $tok->{"value"};
        parser_advance($parser);
        # Right-associative: recurse on right side
        my scalar $right = parse_power($parser);
        return ast_new_binary_op($op, $left, $right);
    }

    return $left;
}

# Multiplicative: * / %
func parse_multiplicative(scalar $parser) scalar {
    my scalar $left = parse_power($parser);

    while (1) {
        my scalar $tok = parser_current($parser);
        my str $type = $tok->{"type"};

        if ($type eq "MULT" || $type eq "DIV" || $type eq "MOD") {
            my str $op = $tok->{"value"};
            parser_advance($parser);
            my scalar $right = parse_power($parser);
            $left = ast_new_binary_op($op, $left, $right);
        } else {
            return $left;
        }
    }
}

# Additive: + - .
func parse_additive(scalar $parser) scalar {
    my scalar $left = parse_multiplicative($parser);
    
    while (1) {
        my scalar $tok = parser_current($parser);
        my str $type = $tok->{"type"};
        
        if ($type eq "PLUS" || $type eq "MINUS" || $type eq "DOT") {
            my str $op = $tok->{"value"};
            parser_advance($parser);
            my scalar $right = parse_multiplicative($parser);
            $left = ast_new_binary_op($op, $left, $right);
        } else {
            return $left;
        }
    }
}

# Shift: << >>
func parse_shift(scalar $parser) scalar {
    my scalar $left = parse_additive($parser);

    while (1) {
        my scalar $tok = parser_current($parser);
        my str $type = $tok->{"type"};

        if ($type eq "LSHIFT" || $type eq "RSHIFT") {
            my str $op = $tok->{"value"};
            parser_advance($parser);
            my scalar $right = parse_additive($parser);
            $left = ast_new_binary_op($op, $left, $right);
        } else {
            return $left;
        }
    }
}

# Range: ..
func parse_range(scalar $parser) scalar {
    my scalar $left = parse_shift($parser);

    if (parser_check($parser, "RANGE")) {
        parser_advance($parser);
        my scalar $right = parse_shift($parser);
        return ast_new_range($left, $right);
    }

    return $left;
}

# Relational: < > <= >= lt gt le ge
func parse_relational(scalar $parser) scalar {
    my scalar $left = parse_range($parser);

    while (1) {
        my scalar $tok = parser_current($parser);
        my str $type = $tok->{"type"};

        if ($type eq "LT" || $type eq "GT" || $type eq "LE" || $type eq "GE") {
            my str $op = $tok->{"value"};
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op($op, $left, $right);
        } elsif ($type eq "STR_LT") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("lt", $left, $right);
        } elsif ($type eq "STR_GT") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("gt", $left, $right);
        } elsif ($type eq "STR_LE") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("le", $left, $right);
        } elsif ($type eq "STR_GE") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("ge", $left, $right);
        } elsif ($type eq "SPACESHIP") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("<=>", $left, $right);
        } elsif ($type eq "STR_CMP") {
            parser_advance($parser);
            my scalar $right = parse_shift($parser);
            $left = ast_new_binary_op("cmp", $left, $right);
        } else {
            return $left;
        }
    }
}

# Regex match: =~ !~
func parse_regex_match(scalar $parser) scalar {
    my scalar $left = parse_relational($parser);

    my scalar $tok = parser_current($parser);
    my str $type = $tok->{"type"};

    if ($type eq "MATCH_OP" || $type eq "NOT_MATCH_OP") {
        my str $op = $tok->{"value"};
        parser_advance($parser);

        my scalar $right_tok = parser_current($parser);
        my str $right_type = $right_tok->{"type"};

        if ($right_type eq "REGEX_LITERAL") {
            parser_advance($parser);
            return ast_new_regex_match($op, $left, $right_tok->{"pattern"}, $right_tok->{"flags"});
        } elsif ($right_type eq "SUBST_LITERAL") {
            parser_advance($parser);
            if ($op eq "!~") {
                parser_error($parser, "cannot use !~ with substitution s///");
            }
            return ast_new_regex_subst($left, $right_tok->{"pattern"}, $right_tok->{"replacement"}, $right_tok->{"flags"});
        } else {
            # String expression as pattern: $foo =~ $pattern
            my scalar $right = parse_relational($parser);
            return ast_new_binary_op($op, $left, $right);
        }
    }

    return $left;
}

# Equality: == != eq ne
func parse_equality(scalar $parser) scalar {
    my scalar $left = parse_regex_match($parser);
    
    while (1) {
        my scalar $tok = parser_current($parser);
        my str $type = $tok->{"type"};
        
        if ($type eq "EQ" || $type eq "NE") {
            my str $op = $tok->{"value"};
            parser_advance($parser);
            my scalar $right = parse_relational($parser);
            $left = ast_new_binary_op($op, $left, $right);
        } elsif ($type eq "STR_EQ") {
            parser_advance($parser);
            my scalar $right = parse_relational($parser);
            $left = ast_new_binary_op("eq", $left, $right);
        } elsif ($type eq "STR_NE") {
            parser_advance($parser);
            my scalar $right = parse_relational($parser);
            $left = ast_new_binary_op("ne", $left, $right);
        } else {
            return $left;
        }
    }
}

# Bitwise AND: &
func parse_bitwise_and(scalar $parser) scalar {
    my scalar $left = parse_equality($parser);

    while (parser_check($parser, "AMPERSAND")) {
        parser_advance($parser);
        my scalar $right = parse_equality($parser);
        $left = ast_new_binary_op("&", $left, $right);
    }

    return $left;
}

# Bitwise XOR: ^
func parse_bitwise_xor(scalar $parser) scalar {
    my scalar $left = parse_bitwise_and($parser);

    while (parser_check($parser, "CARET")) {
        parser_advance($parser);
        my scalar $right = parse_bitwise_and($parser);
        $left = ast_new_binary_op("^", $left, $right);
    }

    return $left;
}

# Bitwise OR: |
func parse_bitwise_or(scalar $parser) scalar {
    my scalar $left = parse_bitwise_xor($parser);

    while (parser_check($parser, "PIPE")) {
        parser_advance($parser);
        my scalar $right = parse_bitwise_xor($parser);
        $left = ast_new_binary_op("|", $left, $right);
    }

    return $left;
}

# Logical AND: &&
func parse_logical_and(scalar $parser) scalar {
    my scalar $left = parse_bitwise_or($parser);

    while (parser_check($parser, "AND")) {
        parser_advance($parser);
        my scalar $right = parse_bitwise_or($parser);
        $left = ast_new_binary_op("&&", $left, $right);
    }

    return $left;
}

# Logical OR: || and defined-or: //
func parse_logical_or(scalar $parser) scalar {
    my scalar $left = parse_logical_and($parser);

    while (parser_check($parser, "OR") || parser_check($parser, "DEFINED_OR")) {
        my scalar $tok = parser_current($parser);
        my str $op = $tok->{"value"};
        parser_advance($parser);
        my scalar $right = parse_logical_and($parser);
        $left = ast_new_binary_op($op, $left, $right);
    }

    return $left;
}

# Ternary expression: cond ? true_expr : false_expr
func parse_ternary(scalar $parser) scalar {
    my scalar $cond = parse_logical_or($parser);

    if (parser_check($parser, "QUESTION")) {
        parser_advance($parser);
        my scalar $true_expr = parse_expression($parser);
        parser_expect($parser, "COLON");
        my scalar $false_expr = parse_ternary($parser);
        return ast_new_ternary($cond, $true_expr, $false_expr);
    }

    # Fat arrow creates a pair (2-element array) for map { $_ => 1 } idiom
    if (parser_check($parser, "FAT_ARROW")) {
        parser_advance($parser);
        my scalar $value = parse_logical_or($parser);
        # Create a 2-element anonymous array [key, value]
        my scalar $pair = ast_new_anon_array();
        ast_add_array_elem($pair, $cond);
        ast_add_array_elem($pair, $value);
        return $pair;
    }

    return $cond;
}

# Assignment expression
func parse_assignment(scalar $parser) scalar {
    my scalar $left = parse_ternary($parser);
    
    my scalar $tok = parser_current($parser);
    my str $type = $tok->{"type"};
    
    if ($type eq "ASSIGN" || $type eq "PLUS_ASSIGN" || 
        $type eq "MINUS_ASSIGN" || $type eq "DOT_ASSIGN") {
        my str $op = $tok->{"value"};
        parser_advance($parser);
        my scalar $right = parse_assignment($parser);
        return ast_new_assign($op, $left, $right);
    }
    
    return $left;
}

# Top-level expression
func parse_expression(scalar $parser) scalar {
    return parse_assignment($parser);
}

# ============================================================
# Statement Parsing
# ============================================================

# Parse case value - handles literals and simple variables without hash access interpretation
func parse_case_value(scalar $parser) scalar {
    my scalar $tok = parser_current($parser);
    my str $type = $tok->{"type"};

    # Integer literal
    if ($type eq "INT_LITERAL") {
        parser_advance($parser);
        return ast_new_int_literal($tok->{"value"});
    }

    # Number literal
    if ($type eq "NUM_LITERAL") {
        parser_advance($parser);
        return ast_new_num_literal($tok->{"value"});
    }

    # String literal
    if ($type eq "STR_LITERAL") {
        parser_advance($parser);
        return ast_new_str_literal($tok->{"value"});
    }

    # Variable (without hash access interpretation)
    if ($type eq "DOLLAR") {
        my int $var_line = parser_current_line($parser);
        parser_advance($parser);
        my str $var_name = parse_var_name($parser);
        my scalar $var = ast_new_variable($var_name, "$");
        ast_set_line($var, $var_line);
        return $var;
    }

    # Bareword/identifier or qualified name (e.g., enum value like Status::PENDING)
    if ($type eq "IDENT") {
        my str $name = $tok->{"value"};
        my int $const_line = parser_current_line($parser);
        parser_advance($parser);

        # Check for qualified name (Enum::VALUE)
        if (parser_check($parser, "DOUBLE_COLON")) {
            while (parser_check($parser, "DOUBLE_COLON")) {
                parser_advance($parser);
                my scalar $next_tok = parser_current($parser);
                parser_expect($parser, "IDENT");
                $name = $name . "::" . $next_tok->{"value"};
            }
            # Return as a constant reference (will be handled by codegen)
            my scalar $const_ref = ast_new_call($name);
            $const_ref->{"is_constant"} = 1;
            ast_set_line($const_ref, $const_line);
            return $const_ref;
        }

        return ast_new_str_literal($name);
    }

    parser_error($parser, "expected case value");
}

func parse_block(scalar $parser) scalar {
    parser_expect($parser, "LBRACE");
    my scalar $block = ast_new_block();
    
    while (!parser_check($parser, "RBRACE") && !parser_check($parser, "EOF")) {
        my scalar $stmt = parse_statement($parser);
        ast_add_statement($block, $stmt);
    }
    
    parser_expect($parser, "RBRACE");
    return $block;
}

# Parse destructuring declaration: my ($a, $b) = expr; or my (int $a, str $b) = expr;
func parse_destructure_decl(scalar $parser, int $decl_line) scalar {
    parser_expect($parser, "LPAREN");

    my array @vars = ();
    my int $var_count = 0;

    while (!parser_check($parser, "RPAREN")) {
        # Check if next token is a sigil (no explicit type)
        my scalar $peek = parser_current($parser);
        my str $peek_type = $peek->{"type"};

        my int $var_type = TYPE_SCALAR();
        my str $type_name = "";

        # If not a sigil, parse type first
        if ($peek_type ne "DOLLAR" && $peek_type ne "AT" && $peek_type ne "PERCENT") {
            $var_type = parse_type($parser);
            $type_name = $parser->{"last_type_name"};
        }

        # Get sigil
        my scalar $sigil_tok = parser_current($parser);
        my str $sigil = "$";

        if ($sigil_tok->{"type"} eq "DOLLAR") {
            $sigil = "$";
            parser_advance($parser);
        } elsif ($sigil_tok->{"type"} eq "AT") {
            $sigil = "@";
            parser_advance($parser);
        } elsif ($sigil_tok->{"type"} eq "PERCENT") {
            $sigil = "%";
            parser_advance($parser);
        } else {
            parser_error($parser, "expected variable sigil ($, @, or %) in destructuring");
        }

        # Get variable name
        my str $name = parse_var_name($parser);

        # Store variable info
        my hash %var_info = ();
        $var_info{"name"} = $name;
        $var_info{"sigil"} = $sigil;
        $var_info{"var_type"} = $var_type;
        $var_info{"type_name"} = $type_name;
        push(@vars, \%var_info);
        $var_count = $var_count + 1;

        # Check for comma or end of list
        if (parser_check($parser, "COMMA")) {
            parser_advance($parser);
        } elsif (!parser_check($parser, "RPAREN")) {
            parser_error($parser, "expected ',' or ')' in destructuring");
        }
    }

    parser_expect($parser, "RPAREN");
    parser_expect($parser, "ASSIGN");

    my scalar $init = parse_expression($parser);
    parser_expect($parser, "SEMI");

    my scalar $node = ast_new_destructure(\@vars, $var_count, $init, 1);
    ast_set_line($node, $decl_line);
    return $node;
}

func parse_var_decl(scalar $parser) scalar {
    my int $decl_line = parser_current_line($parser);
    parser_expect($parser, "MY");

    # Check for destructuring: my ($a, $b, $c) = expr;
    if (parser_check($parser, "LPAREN")) {
        return parse_destructure_decl($parser, $decl_line);
    }

    my int $var_type = parse_type($parser);
    my str $type_name = $parser->{"last_type_name"};

    # Get sigil and name
    my scalar $sigil_tok = parser_current($parser);
    my str $sigil = "$";

    if ($sigil_tok->{"type"} eq "DOLLAR") {
        $sigil = "$";
        parser_advance($parser);
    } elsif ($sigil_tok->{"type"} eq "AT") {
        $sigil = "@";
        parser_advance($parser);
    } elsif ($sigil_tok->{"type"} eq "PERCENT") {
        $sigil = "%";
        parser_advance($parser);
    }

    my str $name = parse_var_name($parser);

    my scalar $decl = ast_new_var_decl($name, $var_type, $sigil);
    ast_set_line($decl, $decl_line);

    # Store struct type name if applicable
    if ($var_type == TYPE_STRUCT()) {
        $decl->{"type_name"} = $type_name;
    }

    # Optional initial capacity for arrays: my array @name[size];
    if ($sigil eq "@") {
        if (parser_check($parser, "LBRACKET")) {
            parser_advance($parser);
            $decl->{"initial_capacity"} = parse_expression($parser);
            parser_expect($parser, "RBRACKET");
        }
    }

    # Optional initial capacity for hashes: my hash %name[size];
    if ($sigil eq "%") {
        if (parser_check($parser, "LBRACKET")) {
            parser_advance($parser);
            $decl->{"initial_capacity"} = parse_expression($parser);
            parser_expect($parser, "RBRACKET");
        }
    }

    # Optional initialization
    if (parser_check($parser, "ASSIGN")) {
        parser_advance($parser);
        $decl->{"init"} = parse_expression($parser);
    }

    parser_expect($parser, "SEMI");
    return $decl;
}

func parse_if_stmt(scalar $parser) scalar {
    parser_expect($parser, "IF");
    parser_expect($parser, "LPAREN");
    my scalar $condition = parse_expression($parser);
    parser_expect($parser, "RPAREN");
    
    my scalar $then_block = parse_block($parser);
    my scalar $if_stmt = ast_new_if_stmt($condition, $then_block);
    
    # Handle elsif clauses
    while (parser_check($parser, "ELSIF")) {
        parser_advance($parser);
        parser_expect($parser, "LPAREN");
        my scalar $elsif_cond = parse_expression($parser);
        parser_expect($parser, "RPAREN");
        my scalar $elsif_block = parse_block($parser);
        ast_add_elsif($if_stmt, $elsif_cond, $elsif_block);
    }
    
    # Handle else clause
    if (parser_check($parser, "ELSE")) {
        parser_advance($parser);
        $if_stmt->{"else_block"} = parse_block($parser);
    }
    
    return $if_stmt;
}

func parse_while_stmt(scalar $parser, str $label) scalar {
    parser_expect($parser, "WHILE");
    parser_expect($parser, "LPAREN");
    my scalar $condition = parse_expression($parser);
    parser_expect($parser, "RPAREN");

    my scalar $body = parse_block($parser);
    return ast_new_while_stmt($condition, $body, $label);
}

# Parse do-while loop: do { body } while (condition);
func parse_do_while_stmt(scalar $parser, str $label) scalar {
    parser_expect($parser, "DO");
    my scalar $body = parse_block($parser);
    parser_expect($parser, "WHILE");
    parser_expect($parser, "LPAREN");
    my scalar $condition = parse_expression($parser);
    parser_expect($parser, "RPAREN");
    parser_expect($parser, "SEMI");
    return ast_new_do_while_stmt($body, $condition, $label);
}

# Parse array-style for loop: for my type $var (@array) or for $var (@array)
# This is syntactic sugar for foreach
func parse_for_array_style(scalar $parser, str $label) scalar {
    my scalar $var_decl = 0;
    my str $var_name = "";

    # Check if we have a variable declaration or existing variable
    if (parser_check($parser, "MY")) {
        # for my type $var (@array)
        parser_advance($parser);
        my int $var_type = parse_type($parser);

        my scalar $sigil_tok = parser_current($parser);
        my str $sigil = "$";
        if ($sigil_tok->{"type"} eq "DOLLAR") {
            $sigil = "$";
            parser_advance($parser);
        }

        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $var_name = $name_tok->{"value"};

        $var_decl = ast_new_var_decl($var_name, $var_type, $sigil);
    } else {
        # for $var (@array) - must be existing variable with $ sigil
        parser_expect($parser, "DOLLAR");
        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $var_name = $name_tok->{"value"};
    }

    parser_expect($parser, "LPAREN");
    my scalar $array_expr = parse_expression($parser);
    parser_expect($parser, "RPAREN");

    my scalar $body = parse_block($parser);
    return ast_new_foreach_stmt($var_decl, $var_name, $array_expr, $body, $label);
}

func parse_for_stmt(scalar $parser, str $label) scalar {
    parser_expect($parser, "FOR");

    # Check if this is array-style for (like foreach) or C-style for
    # for my type $var (@array) - array style
    # for $var (@array) - array style
    # for (init; cond; update) - C style
    if (parser_check($parser, "MY") || parser_check($parser, "DOLLAR")) {
        # Array-style for loop - delegate to foreach parsing logic
        return parse_for_array_style($parser, $label);
    }

    parser_expect($parser, "LPAREN");

    # Init (may be var decl or expression)
    my scalar $init = 0;
    if (parser_check($parser, "MY")) {
        # Variable declaration (without semicolon)
        parser_advance($parser);
        my int $var_type = parse_type($parser);

        my scalar $sigil_tok = parser_current($parser);
        my str $sigil = "$";
        if ($sigil_tok->{"type"} eq "DOLLAR") {
            $sigil = "$";
            parser_advance($parser);
        }

        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");

        $init = ast_new_var_decl($name_tok->{"value"}, $var_type, $sigil);

        if (parser_check($parser, "ASSIGN")) {
            parser_advance($parser);
            $init->{"init"} = parse_expression($parser);
        }
    } elsif (!parser_check($parser, "SEMI")) {
        $init = parse_expression($parser);
    }
    parser_expect($parser, "SEMI");

    # Condition
    my scalar $cond = 0;
    if (!parser_check($parser, "SEMI")) {
        $cond = parse_expression($parser);
    }
    parser_expect($parser, "SEMI");

    # Update
    my scalar $update = 0;
    if (!parser_check($parser, "RPAREN")) {
        $update = parse_expression($parser);
    }
    parser_expect($parser, "RPAREN");

    my scalar $body = parse_block($parser);
    return ast_new_for_stmt($init, $cond, $update, $body, $label);
}

func parse_foreach_stmt(scalar $parser, str $label) scalar {
    parser_expect($parser, "FOREACH");

    my scalar $var_decl = 0;
    my str $var_name = "";

    # Check if we have a variable declaration or existing variable
    if (parser_check($parser, "MY")) {
        # foreach my type $var (@array)
        parser_advance($parser);
        my int $var_type = parse_type($parser);

        my scalar $sigil_tok = parser_current($parser);
        my str $sigil = "$";
        if ($sigil_tok->{"type"} eq "DOLLAR") {
            $sigil = "$";
            parser_advance($parser);
        }

        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $var_name = $name_tok->{"value"};

        $var_decl = ast_new_var_decl($var_name, $var_type, $sigil);
    } else {
        # foreach $var (@array) - must be existing variable with $ sigil
        parser_expect($parser, "DOLLAR");
        my scalar $name_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $var_name = $name_tok->{"value"};
    }

    parser_expect($parser, "LPAREN");
    my scalar $array_expr = parse_expression($parser);
    parser_expect($parser, "RPAREN");

    my scalar $body = parse_block($parser);
    return ast_new_foreach_stmt($var_decl, $var_name, $array_expr, $body, $label);
}

func parse_return_stmt(scalar $parser) scalar {
    parser_expect($parser, "RETURN");
    
    my scalar $value = 0;
    if (!parser_check($parser, "SEMI")) {
        $value = parse_expression($parser);
    }
    
    parser_expect($parser, "SEMI");
    return ast_new_return_stmt($value);
}

func parse_statement(scalar $parser) scalar {
    my scalar $tok = parser_current($parser);
    my str $type = $tok->{"type"};

    if ($type eq "MY") {
        return parse_var_decl($parser);
    }

    if ($type eq "IF") {
        return parse_if_stmt($parser);
    }

    # Check for labeled statement: LABEL: while/for
    if ($type eq "IDENT") {
        my scalar $peek_tok = parser_peek($parser);
        if ($peek_tok->{"type"} eq "COLON") {
            my str $label = $tok->{"value"};
            parser_advance($parser);
            parser_advance($parser);

            my scalar $loop_tok = parser_current($parser);
            my str $loop_type = $loop_tok->{"type"};

            if ($loop_type eq "WHILE") {
                return parse_while_stmt($parser, $label);
            } elsif ($loop_type eq "DO") {
                return parse_do_while_stmt($parser, $label);
            } elsif ($loop_type eq "FOR") {
                return parse_for_stmt($parser, $label);
            } elsif ($loop_type eq "FOREACH") {
                return parse_foreach_stmt($parser, $label);
            } else {
                # Standalone label for goto
                return ast_new_label($label);
            }
        }
    }

    if ($type eq "WHILE") {
        return parse_while_stmt($parser, "");
    }

    if ($type eq "DO") {
        return parse_do_while_stmt($parser, "");
    }

    if ($type eq "FOR") {
        return parse_for_stmt($parser, "");
    }

    if ($type eq "FOREACH") {
        return parse_foreach_stmt($parser, "");
    }

    if ($type eq "RETURN") {
        return parse_return_stmt($parser);
    }

    if ($type eq "LAST") {
        parser_advance($parser);
        my str $label = "";
        my scalar $label_tok = parser_current($parser);
        if ($label_tok->{"type"} eq "IDENT") {
            $label = $label_tok->{"value"};
            parser_advance($parser);
        }
        parser_expect($parser, "SEMI");
        return ast_new_last($label);
    }

    if ($type eq "NEXT") {
        parser_advance($parser);
        my str $label = "";
        my scalar $label_tok = parser_current($parser);
        if ($label_tok->{"type"} eq "IDENT") {
            $label = $label_tok->{"value"};
            parser_advance($parser);
        }
        parser_expect($parser, "SEMI");
        return ast_new_next($label);
    }

    # try { ... } catch ($e) { ... }
    # try { ... } catch (TypeName $e) { ... } catch ($e) { ... }
    if ($type eq "TRY") {
        parser_advance($parser);
        my scalar $try_block = parse_block($parser);

        # Parse one or more catch clauses
        my array @catch_clauses = ();
        my int $has_catchall = 0;

        while (parser_check($parser, "CATCH")) {
            parser_advance($parser);
            parser_expect($parser, "LPAREN");

            my str $catch_type = "";

            # Check for typed catch: catch (TypeName $var)
            # Look ahead: if we see IDENT followed by DOLLAR, it's a type name
            if (parser_check($parser, "IDENT")) {
                my scalar $peek = parser_peek($parser);
                if ($peek->{"type"} eq "DOLLAR") {
                    # It's a type name
                    my scalar $type_tok = parser_current($parser);
                    parser_advance($parser);
                    $catch_type = $type_tok->{"value"};
                }
            }

            # Now parse the variable: $var
            parser_expect($parser, "DOLLAR");
            my scalar $name_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            my str $catch_var = $name_tok->{"value"};
            parser_expect($parser, "RPAREN");

            my scalar $catch_block = parse_block($parser);

            # Validate: catch-all must be last
            if ($has_catchall == 1) {
                parser_error($parser, "catch-all clause must be last; additional catch clauses are unreachable");
            }

            if (length($catch_type) == 0) {
                $has_catchall = 1;
            }

            my scalar $clause = ast_new_catch_clause($catch_type, $catch_var, $catch_block);
            push(@catch_clauses, $clause);
        }

        if (size(@catch_clauses) == 0) {
            parser_error($parser, "try block requires at least one catch clause");
        }

        return ast_new_try_catch($try_block, \@catch_clauses);
    }

    # throw $expr;
    if ($type eq "THROW") {
        parser_advance($parser);
        my scalar $expr = parse_expression($parser);
        parser_expect($parser, "SEMI");
        return ast_new_throw($expr);
    }

    # goto LABEL;
    if ($type eq "GOTO") {
        parser_advance($parser);
        my scalar $tok = parser_current($parser);
        my str $target = $tok->{"value"};
        parser_advance($parser);
        parser_expect($parser, "SEMI");
        return ast_new_goto($target);
    }

    # Bare block { ... }
    if ($type eq "LBRACE") {
        return parse_block($parser);
    }

    # switch ($expr) { case val { ... } default { ... } }
    if ($type eq "SWITCH") {
        parser_advance($parser);
        parser_expect($parser, "LPAREN");
        my scalar $switch_expr = parse_expression($parser);
        parser_expect($parser, "RPAREN");
        parser_expect($parser, "LBRACE");

        my scalar $switch_node = ast_new_switch($switch_expr);

        while (!parser_check($parser, "RBRACE") && !parser_check($parser, "EOF")) {
            my scalar $case_tok = parser_current($parser);
            my str $case_type = $case_tok->{"type"};

            if ($case_type eq "CASE") {
                parser_advance($parser);
                my scalar $case_expr = parse_case_value($parser);
                my scalar $case_block = parse_block($parser);
                ast_add_case($switch_node, $case_expr, $case_block);
            } elsif ($case_type eq "DEFAULT") {
                parser_advance($parser);
                my scalar $default_block = parse_block($parser);
                $switch_node->{"default_block"} = $default_block;
                $switch_node->{"has_default"} = 1;
            } else {
                parser_error($parser, "expected 'case' or 'default' in switch statement");
            }
        }

        parser_expect($parser, "RBRACE");
        return $switch_node;
    }

    # __C__ { ... } - raw C code block
    if ($type eq "C_BLOCK") {
        my str $c_code = $tok->{"value"};
        parser_advance($parser);
        return ast_new_c_block($c_code);
    }

    # Expression statement
    my scalar $expr = parse_expression($parser);
    parser_expect($parser, "SEMI");
    return ast_new_expr_stmt($expr);
}

# ============================================================
# Function and Program Parsing
# ============================================================

func is_c_keyword(str $name) int {
    if ($name eq "for") { return 1; }
    if ($name eq "while") { return 1; }
    if ($name eq "if") { return 1; }
    if ($name eq "else") { return 1; }
    if ($name eq "switch") { return 1; }
    if ($name eq "case") { return 1; }
    if ($name eq "default") { return 1; }
    if ($name eq "break") { return 1; }
    if ($name eq "continue") { return 1; }
    if ($name eq "return") { return 1; }
    if ($name eq "goto") { return 1; }
    if ($name eq "next") { return 1; }
    if ($name eq "last") { return 1; }
    if ($name eq "foreach") { return 1; }
    if ($name eq "try") { return 1; }
    if ($name eq "catch") { return 1; }
    if ($name eq "throw") { return 1; }
    if ($name eq "elsif") { return 1; }
    if ($name eq "my") { return 1; }
    if ($name eq "use") { return 1; }
    if ($name eq "package") { return 1; }
    if ($name eq "version") { return 1; }
    if ($name eq "do") { return 1; }
    if ($name eq "int") { return 1; }
    if ($name eq "char") { return 1; }
    if ($name eq "float") { return 1; }
    if ($name eq "double") { return 1; }
    if ($name eq "void") { return 1; }
    if ($name eq "long") { return 1; }
    if ($name eq "short") { return 1; }
    if ($name eq "unsigned") { return 1; }
    if ($name eq "signed") { return 1; }
    if ($name eq "const") { return 1; }
    if ($name eq "static") { return 1; }
    if ($name eq "extern") { return 1; }
    if ($name eq "register") { return 1; }
    if ($name eq "volatile") { return 1; }
    if ($name eq "auto") { return 1; }
    if ($name eq "struct") { return 1; }
    if ($name eq "union") { return 1; }
    if ($name eq "enum") { return 1; }
    if ($name eq "typedef") { return 1; }
    if ($name eq "sizeof") { return 1; }
    if ($name eq "inline") { return 1; }
    if ($name eq "restrict") { return 1; }
    return 0;
}

func parse_function(scalar $parser) scalar {
    my int $func_line = parser_current_line($parser);
    parser_expect($parser, "FUNC");

    my scalar $name_tok = parser_current($parser);
    my str $func_name = "";
    # Accept keyword tokens that users might try to use as function names
    if (parser_check($parser, "NEXT")) {
        $func_name = "next";
        parser_advance($parser);
    } elsif (parser_check($parser, "LAST")) {
        $func_name = "last";
        parser_advance($parser);
    } elsif (parser_check($parser, "GOTO")) {
        $func_name = "goto";
        parser_advance($parser);
    } elsif (parser_check($parser, "FOREACH")) {
        $func_name = "foreach";
        parser_advance($parser);
    } elsif (parser_check($parser, "TRY")) {
        $func_name = "try";
        parser_advance($parser);
    } elsif (parser_check($parser, "CATCH")) {
        $func_name = "catch";
        parser_advance($parser);
    } elsif (parser_check($parser, "THROW")) {
        $func_name = "throw";
        parser_advance($parser);
    } elsif (parser_check($parser, "ELSIF")) {
        $func_name = "elsif";
        parser_advance($parser);
    } elsif (parser_check($parser, "MY")) {
        $func_name = "my";
        parser_advance($parser);
    } elsif (parser_check($parser, "USE")) {
        $func_name = "use";
        parser_advance($parser);
    } elsif (parser_check($parser, "PACKAGE")) {
        $func_name = "package";
        parser_advance($parser);
    } elsif (parser_check($parser, "VERSION")) {
        $func_name = "version";
        parser_advance($parser);
    } else {
        parser_expect($parser, "IDENT");
        $func_name = $name_tok->{"value"};
    }

    # Check for C keywords - they can't be used as function names
    if (is_c_keyword($func_name) == 1) {
        parser_error($parser, "'" . $func_name . "' is a keyword and cannot be used as a function name");
    }

    parser_expect($parser, "LPAREN");

    # Create function node with dummy return type for now
    my scalar $fn = ast_new_function($func_name, TYPE_VOID());
    ast_set_line($fn, $func_line);
    
    # Parse parameters
    if (!parser_check($parser, "RPAREN")) {
        while (1) {
            # Parse the type first
            my int $param_type = parse_type($parser);
            my str $param_type_name = $parser->{"last_type_name"};

            # Check for variadic parameter (...) after the type
            my int $is_variadic = 0;
            if (parser_check($parser, "ELLIPSIS")) {
                parser_advance($parser);
                $is_variadic = 1;
                $fn->{"is_variadic"} = 1;
            }

            # Get sigil
            my scalar $sigil_tok = parser_current($parser);
            my str $sigil = "$";
            if ($sigil_tok->{"type"} eq "DOLLAR") {
                $sigil = "$";
                parser_advance($parser);
            } elsif ($sigil_tok->{"type"} eq "AT") {
                $sigil = "@";
                parser_advance($parser);
            } elsif ($sigil_tok->{"type"} eq "PERCENT") {
                $sigil = "%";
                parser_advance($parser);
            }

            # Variadic parameter must use array sigil (@)
            if ($is_variadic == 1 && $sigil ne "@") {
                parser_error($parser, "variadic parameter must use array sigil (@), e.g., int ...@nums");
            }

            my scalar $pname_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            
            my scalar $param = ast_new_param($pname_tok->{"value"}, $param_type, $sigil);
            $param->{"is_variadic"} = $is_variadic;
            
            # Store struct type name if applicable
            if ($param_type == TYPE_STRUCT()) {
                $param->{"type_name"} = $param_type_name;
            }
            
            # Check for default value
            if (parser_check($parser, "ASSIGN")) {
                parser_advance($parser);
                my scalar $default_val = parse_expression($parser);
                $param->{"default"} = $default_val;
                $param->{"has_default"} = 1;
            } else {
                $param->{"has_default"} = 0;
            }
            
            ast_add_param($fn, $param);

            # Variadic parameter must be the last parameter
            if ($is_variadic == 1 && parser_check($parser, "COMMA")) {
                parser_error($parser, "variadic parameter must be the last parameter");
            }

            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
            } else {
                parser_expect($parser, "RPAREN");
                last;
            }
        }
    } else {
        parser_advance($parser);  # Skip )
    }
    
    # Parse return type
    my int $ret_type = parse_type($parser);
    $fn->{"return_type"} = $ret_type;
    
    # Parse body
    $fn->{"body"} = parse_block($parser);
    
    return $fn;
}

# Parse extern function declaration or definition
func parse_extern_function(scalar $parser) scalar {
    parser_expect($parser, "EXTERN");
    parser_expect($parser, "FUNC");
    
    my scalar $name_tok = parser_current($parser);
    parser_expect($parser, "IDENT");
    
    my scalar $fn = ast_new_extern_func($name_tok->{"value"});
    
    parser_expect($parser, "LPAREN");
    
    # Parse parameters
    if (!parser_check($parser, "RPAREN")) {
        while (1) {
            my int $param_type = parse_type($parser);
            
            # Get sigil
            my str $sigil = "$";
            if (parser_check($parser, "DOLLAR")) {
                parser_advance($parser);
            } elsif (parser_check($parser, "AT")) {
                $sigil = "@";
                parser_advance($parser);
            } elsif (parser_check($parser, "PERCENT")) {
                $sigil = "%";
                parser_advance($parser);
            }
            
            my str $pname = parse_var_name($parser);

            my scalar $param = ast_new_param($pname, $param_type, $sigil);
            ast_add_param($fn, $param);

            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
            } else {
                parser_expect($parser, "RPAREN");
                last;
            }
        }
    } else {
        parser_advance($parser);
    }

    # Parse return type
    my int $ret_type = parse_type($parser);
    $fn->{"return_type"} = $ret_type;

    # Check if this is a declaration (;) or definition ({...})
    if (parser_check($parser, "SEMI")) {
        parser_advance($parser);
        $fn->{"has_body"} = 0;
    } else {
        # Has a body - parse it
        $fn->{"body"} = parse_block($parser);
        $fn->{"has_body"} = 1;
    }
    
    return $fn;
}

# Parse a single C-style extern function declaration (inside extern "C" block)
# These use raw C types and generate direct C calls
func parse_c_extern_func(scalar $parser) scalar {
    parser_expect($parser, "FUNC");

    my scalar $name_tok = parser_current($parser);
    parser_expect($parser, "IDENT");

    my scalar $fn = ast_new_extern_func($name_tok->{"value"});
    $fn->{"is_c_extern"} = 1;  # Mark as raw C extern

    parser_expect($parser, "LPAREN");

    # Parse parameters
    if (!parser_check($parser, "RPAREN")) {
        while (1) {
            my int $param_type = parse_type($parser);

            # Get sigil
            my str $sigil = "$";
            if (parser_check($parser, "DOLLAR")) {
                parser_advance($parser);
            } elsif (parser_check($parser, "AT")) {
                $sigil = "@";
                parser_advance($parser);
            } elsif (parser_check($parser, "PERCENT")) {
                $sigil = "%";
                parser_advance($parser);
            }

            my str $pname = parse_var_name($parser);

            my scalar $param = ast_new_param($pname, $param_type, $sigil);
            ast_add_param($fn, $param);

            if (parser_check($parser, "COMMA")) {
                parser_advance($parser);
            } else {
                parser_expect($parser, "RPAREN");
                last;
            }
        }
    } else {
        parser_advance($parser);
    }

    # Parse return type
    my int $ret_type = parse_type($parser);
    $fn->{"return_type"} = $ret_type;

    # C extern declarations must end with semicolon
    parser_expect($parser, "SEMI");
    $fn->{"has_body"} = 0;

    return $fn;
}

# Parse extern "C" block: extern "C" { func declarations... }
# Returns an array of extern function nodes
func parse_extern_c_block(scalar $parser, scalar $program) void {
    parser_expect($parser, "EXTERN");

    # Expect string "C"
    my scalar $str_tok = parser_current($parser);
    if ($str_tok->{"type"} ne "STR_LITERAL") {
        parser_error($parser, "expected \"C\" after extern");
    }
    if ($str_tok->{"value"} ne "C") {
        parser_error($parser, "expected \"C\" after extern, got \"" . $str_tok->{"value"} . "\"");
    }
    parser_advance($parser);

    parser_expect($parser, "LBRACE");

    # Parse function declarations until we see }
    while (!parser_check($parser, "RBRACE")) {
        if (parser_check($parser, "FUNC")) {
            my scalar $fn = parse_c_extern_func($parser);
            ast_add_function($program, $fn);
        } else {
            parser_error($parser, "expected func declaration inside extern \"C\" block");
        }
    }

    parser_expect($parser, "RBRACE");
}

# Parse struct definition
func parse_struct(scalar $parser) scalar {
    my int $struct_line = parser_current_line($parser);
    parser_expect($parser, "STRUCT");

    my scalar $name_tok = parser_current($parser);
    parser_expect($parser, "IDENT");

    my scalar $st = ast_new_struct($name_tok->{"value"});
    ast_set_line($st, $struct_line);

    parser_expect($parser, "LBRACE");
    
    while (!parser_check($parser, "RBRACE")) {
        # Fields in structs don't have sigils: "int x;" not "int $x;"
        my int $field_type = parse_type($parser);

        # Get funcptr_return if this is a function pointer field
        my int $funcptr_return = -1;
        if ($field_type == TYPE_FUNCPTR()) {
            $funcptr_return = $parser->{"last_funcptr_return"};
        }

        my scalar $field_tok = parser_current($parser);
        parser_expect($parser, "IDENT");

        ast_add_field($st, $field_tok->{"value"}, $field_type, "$", $funcptr_return);

        parser_expect($parser, "SEMI");
    }
    
    parser_expect($parser, "RBRACE");

    return $st;
}

# Parse enum declaration
# enum Name { MEMBER1, MEMBER2 = 10, MEMBER3 }
func parse_enum(scalar $parser) scalar {
    my int $enum_line = parser_current_line($parser);
    parser_expect($parser, "ENUM");

    my scalar $name_tok = parser_current($parser);
    parser_expect($parser, "IDENT");

    my scalar $en = ast_new_enum($name_tok->{"value"});
    ast_set_line($en, $enum_line);

    parser_expect($parser, "LBRACE");

    my int $next_value = 0;

    while (!parser_check($parser, "RBRACE")) {
        # Get member name
        my scalar $member_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        my str $member_name = $member_tok->{"value"};

        # Check for explicit value assignment
        my int $value = $next_value;
        if (parser_check($parser, "ASSIGN")) {
            parser_advance($parser);
            my int $is_negative = 0;
            if (parser_check($parser, "MINUS")) {
                parser_advance($parser);
                $is_negative = 1;
            }
            my scalar $val_tok = parser_current($parser);
            if (parser_check($parser, "INT_LITERAL")) {
                parser_advance($parser);
                $value = str_to_int($val_tok->{"value"});
                if ($is_negative == 1) {
                    $value = 0 - $value;
                }
            } else {
                parser_error($parser, "expected integer value for enum member");
            }
        }

        ast_add_enum_member($en, $member_name, $value);
        $next_value = $value + 1;

        # Optional comma between members
        if (parser_check($parser, "COMMA")) {
            parser_advance($parser);
        }
    }

    parser_expect($parser, "RBRACE");

    return $en;
}

# Parse package declaration
func parse_package(scalar $parser, scalar $program) void {
    parser_expect($parser, "PACKAGE");
    
    my str $pkg_name = "";
    my scalar $tok = parser_current($parser);
    parser_expect($parser, "IDENT");
    $pkg_name = $tok->{"value"};
    
    # Handle Package::Name syntax
    while (parser_check($parser, "DOUBLE_COLON")) {
        parser_advance($parser);
        my scalar $next_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $pkg_name = $pkg_name . "::" . $next_tok->{"value"};
    }
    
    parser_expect($parser, "SEMI");

    $program->{"package"} = $pkg_name;
    $parser->{"current_package"} = $pkg_name;
}

# Parse version declaration: version "x.y.z";
func parse_version(scalar $parser, scalar $program) void {
    parser_expect($parser, "VERSION");

    my scalar $tok = parser_current($parser);
    parser_expect($parser, "STR_LITERAL");
    my str $ver = $tok->{"value"};

    parser_expect($parser, "SEMI");

    $program->{"version"} = $ver;
}

# Parse inherit statement (top-level inheritance declaration)
# Supports: inherit Parent; or inherit Parent1, Parent2, Parent3;
func parse_inherit(scalar $parser, scalar $program) void {
    parser_expect($parser, "INHERIT");

    # Get current package as child
    my str $child_pkg = $parser->{"current_package"};
    if (length($child_pkg) == 0) {
        parser_error($parser, "inherit statement must be inside a package");
    }

    # Parse first parent
    my str $parent_name = "";
    my scalar $tok = parser_current($parser);
    parser_expect($parser, "IDENT");
    $parent_name = $tok->{"value"};

    # Handle Parent::Name syntax
    while (parser_check($parser, "DOUBLE_COLON")) {
        parser_advance($parser);
        my scalar $next_tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $parent_name = $parent_name . "::" . $next_tok->{"value"};
    }

    ast_add_inherit($program, $child_pkg, $parent_name);

    # Parse additional parents (comma-separated)
    while (parser_check($parser, "COMMA")) {
        parser_advance($parser);

        $parent_name = "";
        $tok = parser_current($parser);
        parser_expect($parser, "IDENT");
        $parent_name = $tok->{"value"};

        # Handle Parent::Name syntax
        while (parser_check($parser, "DOUBLE_COLON")) {
            parser_advance($parser);
            my scalar $next_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            $parent_name = $parent_name . "::" . $next_tok->{"value"};
        }

        ast_add_inherit($program, $child_pkg, $parent_name);
    }

    parser_expect($parser, "SEMI");
}

# Convert module name to file path (POSIX -> POSIX.strada, File::IO -> File/IO.strada)
func module_to_path(str $mod_name) str {
    my str $path = "";
    my int $i = 0;
    my int $len = length($mod_name);
    while ($i < $len) {
        my str $ch = substr($mod_name, $i, 1);
        if ($ch eq ":") {
            # Skip the second colon
            $i = $i + 1;
            $path = $path . "/";
        } else {
            $path = $path . $ch;
        }
        $i = $i + 1;
    }
    return $path . ".strada";
}

# Find module file in lib paths
func find_module_file(scalar $program, str $mod_name) str {
    my str $rel_path = module_to_path($mod_name);
    my scalar $lib_paths = $program->{"lib_paths"};
    my int $i = 0;
    my int $count = $program->{"lib_path_count"};

    while ($i < $count) {
        my str $lib_path = $lib_paths->[$i];
        my str $full_path = $lib_path . "/" . $rel_path;
        # Try to read the file - if it works, file exists
        my str $content = slurp($full_path);
        if (length($content) > 0) {
            return $full_path;
        }
        $i = $i + 1;
    }

    return "";
}

# Load and parse a module, merging its functions into the program
func load_module(scalar $program, str $mod_name, str $file_path) void {
    # Read the module source
    my str $source = slurp($file_path);
    if (length($source) == 0) {
        return;
    }

    # Lex the module
    my scalar $tokens = lex_tokenize($source);

    # Parse the module
    my scalar $mod_parser = parser_new($tokens);
    my scalar $mod_program = ast_new_program();

    # Parse the module's contents
    while (!parser_check($mod_parser, "EOF")) {
        if (parser_check($mod_parser, "FUNC")) {
            my scalar $fn = parse_function($mod_parser);
            ast_add_function($mod_program, $fn);
        } elsif (parser_check($mod_parser, "PACKAGE")) {
            parse_package($mod_parser, $mod_program);
        } elsif (parser_check($mod_parser, "VERSION")) {
            parse_version($mod_parser, $mod_program);
        } elsif (parser_check($mod_parser, "STRUCT")) {
            my scalar $st = parse_struct($mod_parser);
            ast_add_struct($mod_program, $st);
        } elsif (parser_check($mod_parser, "ENUM")) {
            my scalar $en = parse_enum($mod_parser);
            ast_add_enum($mod_program, $en);
        } elsif (parser_check($mod_parser, "MY")) {
            # Parse module-level variable declarations
            my scalar $var = parse_var_decl($mod_parser);
            ast_add_global($mod_program, $var);
        } elsif (parser_check($mod_parser, "EXTERN")) {
            # Check if this is extern "C" { } or extern func
            my scalar $next_tok = parser_peek($mod_parser);
            if ($next_tok->{"type"} eq "STR_LITERAL") {
                # extern "C" { ... } block
                parse_extern_c_block($mod_parser, $mod_program);
            } else {
                # Traditional extern func declaration
                my scalar $fn = parse_extern_function($mod_parser);
                ast_add_function($mod_program, $fn);
            }
        } elsif (parser_check($mod_parser, "C_BLOCK")) {
            # Top-level __C__ { ... } block - collect for transfer to main program
            my scalar $tok = parser_current($mod_parser);
            my str $c_code = $tok->{"value"};
            parser_advance($mod_parser);
            ast_add_c_block($mod_program, $c_code);
        } elsif (parser_check($mod_parser, "HASH")) {
            # Skip comments that look like hash
            parser_advance($mod_parser);
        } else {
            # Skip other tokens (comments, etc)
            parser_advance($mod_parser);
        }
    }

    # Transfer C blocks from module to main program
    my int $mod_c_block_count = $mod_program->{"c_block_count"};
    if ($mod_c_block_count > 0) {
        my scalar $mod_c_blocks = $mod_program->{"c_blocks"};
        my int $cb = 0;
        while ($cb < $mod_c_block_count) {
            ast_add_c_block($program, $mod_c_blocks->[$cb]);
            $cb = $cb + 1;
        }
    }

    # Get the package name from the module (defaults to module name)
    my str $pkg_name = $mod_program->{"package"};
    if (length($pkg_name) == 0) {
        $pkg_name = $mod_name;
    }

    # Merge functions into main program with package prefix
    my scalar $mod_funcs = $mod_program->{"functions"};
    my int $i = 0;
    my int $count = $mod_program->{"function_count"};

    while ($i < $count) {
        my scalar $fn = $mod_funcs->[$i];
        my str $fn_name = $fn->{"name"};

        # Store original name and package
        $fn->{"original_name"} = $fn_name;
        $fn->{"package"} = $pkg_name;

        # extern "C" functions keep their exact C symbol name (no package prefix)
        if ($fn->{"is_c_extern"} == 1) {
            # Keep original name for C linkage
            $fn->{"name"} = $fn_name;
        } else {
            # Create qualified name version for Strada functions
            $fn->{"name"} = $pkg_name . "::" . $fn_name;
        }

        # Add to main program
        ast_add_function($program, $fn);

        $i = $i + 1;
    }

    # Merge structs
    my scalar $mod_structs = $mod_program->{"structs"};
    $i = 0;
    $count = $mod_program->{"struct_count"};
    while ($i < $count) {
        my scalar $st = $mod_structs->[$i];
        ast_add_struct($program, $st);
        $i = $i + 1;
    }

    # Merge enums
    my scalar $mod_enums = $mod_program->{"enums"};
    $i = 0;
    $count = $mod_program->{"enum_count"};
    while ($i < $count) {
        my scalar $en = $mod_enums->[$i];
        ast_add_enum($program, $en);
        $i = $i + 1;
    }

    # Merge global variables from module
    my scalar $mod_globals = $mod_program->{"globals"};
    $i = 0;
    $count = $mod_program->{"global_count"};
    while ($i < $count) {
        my scalar $gvar = $mod_globals->[$i];
        ast_add_global($program, $gvar);
        $i = $i + 1;
    }
}

# Parse use statement
func parse_use(scalar $parser, scalar $program) void {
    parser_expect($parser, "USE");

    my str $mod_name = "";
    my scalar $tok = parser_current($parser);

    # Check if it's a string path or identifier
    if ($tok->{"type"} eq "STR_LITERAL") {
        $mod_name = $tok->{"value"};
        parser_advance($parser);
    } else {
        parser_expect($parser, "IDENT");
        $mod_name = $tok->{"value"};

        # Check for "use lib" pattern followed by string
        if ($mod_name eq "lib") {
            if (parser_check($parser, "STR_LITERAL")) {
                my scalar $path_tok = parser_current($parser);
                my str $lib_path = $path_tok->{"value"};
                parser_advance($parser);
                # Store the lib path
                ast_add_lib_path($program, $lib_path);
            }
            parser_expect($parser, "SEMI");
            ast_add_use($program, "lib");
            return;
        }

        # Handle Module::Name syntax
        while (parser_check($parser, "DOUBLE_COLON")) {
            parser_advance($parser);
            my scalar $next_tok = parser_current($parser);
            parser_expect($parser, "IDENT");
            $mod_name = $mod_name . "::" . $next_tok->{"value"};
        }

        # Check for qw() import list
        if (parser_check($parser, "IDENT")) {
            my scalar $qw_tok = parser_current($parser);
            if ($qw_tok->{"value"} eq "qw") {
                parser_advance($parser);
                parser_expect($parser, "LPAREN");
                # Collect the import list
                while (!parser_check($parser, "RPAREN")) {
                    if (parser_check($parser, "IDENT")) {
                        my scalar $import_tok = parser_current($parser);
                        ast_add_import($program, $import_tok->{"value"});
                    }
                    parser_advance($parser);
                }
                parser_expect($parser, "RPAREN");
            }
        }
    }

    parser_expect($parser, "SEMI");

    # Check if module already loaded
    if (ast_is_module_loaded($program, $mod_name)) {
        ast_add_use($program, $mod_name);
        return;
    }

    # Try to find and load the module
    my str $file_path = find_module_file($program, $mod_name);
    if (length($file_path) > 0) {
        ast_mark_module_loaded($program, $mod_name);
        load_module($program, $mod_name, $file_path);
    }

    ast_add_use($program, $mod_name);
}

# Parse import_lib statement - import shared library as module
# import_lib "libname.so";  -> loads libname.so and reads metadata from __strada_export_info()
func parse_import_lib(scalar $parser, scalar $program) void {
    parser_expect($parser, "IMPORT_LIB");

    # Get the library filename (must be a string, e.g., "MyLib.so")
    my scalar $tok = parser_current($parser);
    if ($tok->{"type"} ne "STR_LITERAL") {
        parser_error($parser, "import_lib requires a string library filename (e.g., \"MyLib.so\")");
    }
    my str $lib_file = $tok->{"value"};
    parser_advance($parser);

    parser_expect($parser, "SEMI");

    # Find the .so file in lib paths
    my str $so_path = find_so_file($program, $lib_file);
    if (length($so_path) == 0) {
        parser_error($parser, "cannot find shared library: " . $lib_file);
    }

    # Extract package name by stripping .so extension
    my str $lib_name = $lib_file;
    if (length($lib_file) > 3 && substr($lib_file, length($lib_file) - 3, 3) eq ".so") {
        $lib_name = substr($lib_file, 0, length($lib_file) - 3);
    }

    # Load the .so file and get metadata using runtime functions
    my scalar $lib_handle = strada_dl_open_raw($so_path);
    my int $lib_handle_int = $lib_handle;
    if ($lib_handle_int == 0) {
        parser_error($parser, "failed to load shared library: " . $so_path);
    }

    # Get the __strada_export_info function
    my scalar $export_fn = strada_dl_sym_raw($lib_handle, "__strada_export_info");
    my int $export_fn_int = $export_fn;
    if ($export_fn_int == 0) {
        strada_dl_close_raw($lib_handle);
        parser_error($parser, "library missing __strada_export_info: " . $so_path . " (was it compiled with a recent strada compiler?)");
    }

    # Call __strada_export_info to get metadata string
    my str $metadata = strada_dl_call_export_info($export_fn);
    strada_dl_close_raw($lib_handle);

    if (length($metadata) == 0) {
        parser_error($parser, "empty metadata from library: " . $so_path);
    }

    # Parse the metadata string to extract function signatures
    my scalar $lib_info = parse_export_metadata($lib_name, $so_path, $metadata);

    # Add to program
    ast_add_import_lib($program, $lib_info);
}

# Find .so file in lib paths (lib_file is the full filename, e.g., "MyLib.so")
func find_so_file(scalar $program, str $lib_file) str {
    my scalar $lib_paths = $program->{"lib_paths"};
    my int $i = 0;
    my int $count = $program->{"lib_path_count"};

    while ($i < $count) {
        my str $lib_path = $lib_paths->[$i];
        my str $full_path = $lib_path . "/" . $lib_file;
        # Try to open the file to check if it exists
        my int $fd = sys::open_fd($full_path, "r");
        if ($fd > 0) {
            close_fd($fd);
            return $full_path;
        }
        $i = $i + 1;
    }

    return "";
}

# Parse export metadata string into lib_info structure
# Format: "func:name:return_type:param_count:param_types\n" for each function
# Note: Bootstrap compiler doesn't support scalar(@array), so we parse manually
func parse_export_metadata(str $lib_name, str $so_path, str $metadata) scalar {
    my hash %lib_info = ();
    $lib_info{"lib_name"} = $lib_name;
    $lib_info{"pkg_name"} = $lib_name;
    $lib_info{"so_path"} = $so_path;

    my array @functions = ();
    my int $fn_count = 0;

    # Parse metadata line by line manually (bootstrap doesn't support split well)
    my int $meta_len = length($metadata);
    my int $pos = 0;

    while ($pos < $meta_len) {
        # Extract one line
        my str $line = "";
        while ($pos < $meta_len) {
            my str $ch = substr($metadata, $pos, 1);
            $pos = $pos + 1;
            if ($ch eq "\n") {
                last;
            }
            $line = $line . $ch;
        }

        if (length($line) > 0) {
            # Parse: func:name:return_type:param_count:param_types
            my scalar $fn_info = parse_export_line($line);
            if ($fn_info != 0) {
                push(@functions, $fn_info);
                $fn_count = $fn_count + 1;
            }
        }
    }

    $lib_info{"functions"} = \@functions;
    $lib_info{"function_count"} = $fn_count;

    return \%lib_info;
}

# Parse a single export metadata line
# Format: func:name:return_type:param_count:param_types:variadic_idx
func parse_export_line(str $line) scalar {
    # Extract fields by finding colons
    my int $len = length($line);
    my int $pos = 0;
    my int $field_num = 0;
    my str $kind = "";
    my str $fn_name = "";
    my str $ret_str = "";
    my str $param_count_str = "";
    my str $param_types_str = "";
    my str $variadic_idx_str = "";

    my str $current = "";
    while ($pos <= $len) {
        my str $ch = "";
        if ($pos < $len) {
            $ch = substr($line, $pos, 1);
        }
        if ($ch eq ":" || $pos == $len) {
            if ($field_num == 0) {
                $kind = $current;
            } elsif ($field_num == 1) {
                $fn_name = $current;
            } elsif ($field_num == 2) {
                $ret_str = $current;
            } elsif ($field_num == 3) {
                $param_count_str = $current;
            } elsif ($field_num == 4) {
                $param_types_str = $current;
            } elsif ($field_num == 5) {
                $variadic_idx_str = $current;
            }
            $current = "";
            $field_num = $field_num + 1;
        } else {
            $current = $current . $ch;
        }
        $pos = $pos + 1;
    }

    # Only process "func" entries
    if ($kind ne "func") {
        return 0;
    }

    my int $param_count = 0;
    if (length($param_count_str) > 0) {
        $param_count = str_to_int($param_count_str);
    }

    # Parse variadic index
    my int $variadic_idx = -1;
    if (length($variadic_idx_str) > 0) {
        # Handle negative index (str_to_int_signed needed)
        if (substr($variadic_idx_str, 0, 1) eq "-") {
            $variadic_idx = -1;
        } else {
            $variadic_idx = str_to_int($variadic_idx_str);
        }
    }

    my hash %fn_info = ();
    $fn_info{"name"} = $fn_name;
    $fn_info{"original_name"} = $fn_name;
    my int $ret_type = export_str_to_type($ret_str);
    $fn_info{"return_type"} = $ret_type;
    $fn_info{"param_count"} = $param_count;
    $fn_info{"variadic_param_idx"} = $variadic_idx;
    $fn_info{"is_variadic"} = 0;
    if ($variadic_idx >= 0) {
        $fn_info{"is_variadic"} = 1;
    }

    # Parse parameter types
    my array @params = ();
    if ($param_count > 0 && length($param_types_str) > 0) {
        my int $ppos = 0;
        my int $plen = length($param_types_str);
        my int $pnum = 0;
        my str $ptype = "";

        while ($ppos <= $plen && $pnum < $param_count) {
            my str $pch = "";
            if ($ppos < $plen) {
                $pch = substr($param_types_str, $ppos, 1);
            }
            if ($pch eq "," || $ppos == $plen) {
                my hash %param = ();
                $param{"name"} = "arg" . $pnum;
                $param{"param_type"} = export_str_to_type($ptype);
                $param{"sigil"} = "$";
                # Mark variadic parameter
                if ($pnum == $variadic_idx) {
                    $param{"is_variadic"} = 1;
                    $param{"sigil"} = "@";
                } else {
                    $param{"is_variadic"} = 0;
                }
                push(@params, \%param);
                $ptype = "";
                $pnum = $pnum + 1;
            } else {
                $ptype = $ptype . $pch;
            }
            $ppos = $ppos + 1;
        }
    }
    $fn_info{"params"} = \@params;

    return \%fn_info;
}

# Convert string to integer (bootstrap-compatible)
func str_to_int(str $s) int {
    my int $result = 0;
    my int $i = 0;
    my int $len = length($s);
    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        if ($ch ge "0" && $ch le "9") {
            $result = $result * 10 + (ord($ch) - ord("0"));
        }
        $i = $i + 1;
    }
    return $result;
}

# Convert export string to type constant
func export_str_to_type(str $type_str) int {
    if ($type_str eq "int") { return TYPE_INT(); }
    if ($type_str eq "num") { return TYPE_NUM(); }
    if ($type_str eq "str") { return TYPE_STR(); }
    if ($type_str eq "bool") { return TYPE_BOOL(); }
    if ($type_str eq "array") { return TYPE_ARRAY(); }
    if ($type_str eq "hash") { return TYPE_HASH(); }
    if ($type_str eq "scalar") { return TYPE_SCALAR(); }
    if ($type_str eq "void") { return TYPE_VOID(); }
    # Explicit sized types for extern functions (C interop)
    if ($type_str eq "int32") { return TYPE_INT32(); }
    if ($type_str eq "int64") { return TYPE_INT64(); }
    if ($type_str eq "float32") { return TYPE_FLOAT32(); }
    if ($type_str eq "float64") { return TYPE_FLOAT64(); }
    if ($type_str eq "int8") { return TYPE_INT8(); }
    if ($type_str eq "int16") { return TYPE_INT16(); }
    if ($type_str eq "uint8") { return TYPE_UINT8(); }
    if ($type_str eq "byte") { return TYPE_UINT8(); }
    if ($type_str eq "uint16") { return TYPE_UINT16(); }
    if ($type_str eq "uint32") { return TYPE_UINT32(); }
    if ($type_str eq "uint64") { return TYPE_UINT64(); }
    if ($type_str eq "size_t") { return TYPE_SIZE_T(); }
    if ($type_str eq "char") { return TYPE_CHAR(); }
    if ($type_str eq "float") { return TYPE_FLOAT32(); }
    if ($type_str eq "double") { return TYPE_FLOAT64(); }
    if ($type_str eq "long_double") { return TYPE_LONG_DOUBLE(); }
    return TYPE_SCALAR();
}

# ============================================================
# import_object support
# ============================================================

# Find .o file in lib paths (obj_file is the full filename, e.g., "MyLib.o")
func find_o_file(scalar $program, str $obj_file) str {
    my scalar $lib_paths = $program->{"lib_paths"};
    my int $i = 0;
    my int $count = $program->{"lib_path_count"};

    while ($i < $count) {
        my str $lib_path = $lib_paths->[$i];
        my str $full_path = $lib_path . "/" . $obj_file;
        # Try to open the file to check if it exists
        my int $fd = sys::open_fd($full_path, "r");
        if ($fd > 0) {
            close_fd($fd);
            return $full_path;
        }
        $i = $i + 1;
    }

    return "";
}

# Extract export metadata from object file by compiling and running a temp program
# This allows import_object to work like import_lib - metadata comes from the .o file
func extract_object_export_info(scalar $parser, str $obj_name, str $o_path) str {
    # Get the compiler directory from STRADA_DIR environment variable
    # (set by the 'strada' wrapper script) or fall back to current directory
    my str $compiler_dir = sys::qx("echo -n \"$STRADA_DIR\"");
    if (length($compiler_dir) == 0) {
        # Fallback to current directory (works when running from repo root)
        $compiler_dir = ".";
    }
    my str $runtime_path = $compiler_dir . "/runtime/strada_runtime.c";
    my str $runtime_dir = $compiler_dir . "/runtime";

    # Create temp C file that calls __strada_export_info from the object
    my str $temp_c = "/tmp/strada_import_object_" . $obj_name . ".c";
    my str $temp_exe = "/tmp/strada_import_object_" . $obj_name;

    my str $c_code = "#include <stdio.h>\n";
    $c_code = $c_code . "extern const char* __strada_export_info(void);\n";
    $c_code = $c_code . "int main(void) {\n";
    $c_code = $c_code . "    const char* info = __strada_export_info();\n";
    $c_code = $c_code . "    if (info) printf(\"%s\", info);\n";
    $c_code = $c_code . "    return 0;\n";
    $c_code = $c_code . "}\n";

    spew($temp_c, $c_code);

    # Compile the temp program with the object file
    # We need to link with the runtime for strada_* functions used in the object
    my str $compile_cmd = "gcc -o " . $temp_exe . " " . $temp_c . " " . $o_path;
    $compile_cmd = $compile_cmd . " " . $runtime_path . " -I" . $runtime_dir;
    $compile_cmd = $compile_cmd . " -ldl -lm -lpthread";

    # Run gcc and capture any error output, append exit code
    my str $compile_output = sys::qx($compile_cmd . " 2>&1; echo __EXIT_CODE__$?");

    # Check if compilation succeeded by looking for exit code 0
    my int $success = index($compile_output, "__EXIT_CODE__0");
    if ($success < 0) {
        # Clean up
        sys::unlink($temp_c);
        parser_error($parser, "import_object: failed to extract metadata from " . $o_path . " (missing __strada_export_info?)");
    }

    # Run the temp program to get export info
    my str $metadata = sys::qx($temp_exe);

    # Clean up temp files
    sys::unlink($temp_c);
    sys::unlink($temp_exe);

    if (length($metadata) == 0) {
        parser_error($parser, "import_object: " . $o_path . " has no export metadata (was it compiled with a recent strada compiler?)");
    }

    return $metadata;
}

# Parse import_object statement - import object file for static linking
# import_object "objname.o";  -> links objname.o and reads metadata from __strada_export_info()
func parse_import_object(scalar $parser, scalar $program) void {
    parser_expect($parser, "IMPORT_OBJECT");

    # Get the object filename (must be a string, e.g., "MyLib.o")
    my scalar $tok = parser_current($parser);
    if ($tok->{"type"} ne "STR_LITERAL") {
        parser_error($parser, "import_object requires a string object filename (e.g., \"MyLib.o\")");
    }
    my str $obj_file = $tok->{"value"};
    parser_advance($parser);

    parser_expect($parser, "SEMI");

    # Find the .o file in lib paths
    my str $o_path = find_o_file($program, $obj_file);
    if (length($o_path) == 0) {
        parser_error($parser, "cannot find object file: " . $obj_file);
    }

    # Extract package name by stripping .o extension
    my str $obj_name = $obj_file;
    if (length($obj_file) > 2 && substr($obj_file, length($obj_file) - 2, 2) eq ".o") {
        $obj_name = substr($obj_file, 0, length($obj_file) - 2);
    }

    # Extract export metadata from the object file (like import_lib does with .so)
    my str $metadata = extract_object_export_info($parser, $obj_name, $o_path);

    # Parse the metadata using the same function as import_lib
    # Note: parse_export_metadata expects so_path, but we pass o_path - works the same
    my scalar $obj_info = parse_export_metadata($obj_name, $o_path, $metadata);

    # Add o_path to the result (parse_export_metadata sets so_path, but we need o_path)
    $obj_info->{"o_path"} = $o_path;

    # Add to program
    ast_add_import_object($program, $obj_info);
}

# ============================================================
# import_archive support
# ============================================================

# Find .a file in lib paths (arch_file is the full filename, e.g., "MyLib.a")
func find_a_file(scalar $program, str $arch_file) str {
    my scalar $lib_paths = $program->{"lib_paths"};
    my int $i = 0;
    my int $count = $program->{"lib_path_count"};

    while ($i < $count) {
        my str $lib_path = $lib_paths->[$i];
        my str $full_path = $lib_path . "/" . $arch_file;
        # Try to open the file to check if it exists
        my int $fd = sys::open_fd($full_path, "r");
        if ($fd > 0) {
            close_fd($fd);
            return $full_path;
        }
        $i = $i + 1;
    }

    return "";
}

# Extract export metadata from archive file by compiling and running a temp program
func extract_archive_export_info(scalar $parser, str $arch_name, str $a_path) str {
    # Create temp C file that calls __strada_export_info from the archive
    my str $temp_c = "/tmp/strada_import_archive_" . $arch_name . ".c";
    my str $temp_exe = "/tmp/strada_import_archive_" . $arch_name;

    my str $c_code = "#include <stdio.h>\n";
    $c_code = $c_code . "extern const char* __strada_export_info(void);\n";
    $c_code = $c_code . "int main(void) {\n";
    $c_code = $c_code . "    const char* info = __strada_export_info();\n";
    $c_code = $c_code . "    if (info) printf(\"%s\", info);\n";
    $c_code = $c_code . "    return 0;\n";
    $c_code = $c_code . "}\n";

    spew($temp_c, $c_code);

    # Compile the temp program with the archive file
    # Note: The archive already includes the runtime (from --static-lib), so don't link it again
    my str $compile_cmd = "gcc -o " . $temp_exe . " " . $temp_c . " " . $a_path;
    $compile_cmd = $compile_cmd . " -ldl -lm -lpthread";

    my str $compile_output = sys::qx($compile_cmd . " 2>&1; echo __EXIT_CODE__$?");

    my int $success = index($compile_output, "__EXIT_CODE__0");
    if ($success < 0) {
        sys::unlink($temp_c);
        parser_error($parser, "import_archive: failed to extract metadata from " . $a_path . " (missing __strada_export_info?)");
    }

    # Run the temp program to get export info
    my str $metadata = sys::qx($temp_exe);

    # Clean up temp files
    sys::unlink($temp_c);
    sys::unlink($temp_exe);

    if (length($metadata) == 0) {
        parser_error($parser, "import_archive: " . $a_path . " has no export metadata (was it compiled with a recent strada compiler?)");
    }

    return $metadata;
}

# Parse import_archive statement - import archive file for static linking
# import_archive "archname.a";  -> links archname.a and reads metadata from __strada_export_info()
func parse_import_archive(scalar $parser, scalar $program) void {
    parser_expect($parser, "IMPORT_ARCHIVE");

    # Get the archive filename (must be a string, e.g., "MyLib.a")
    my scalar $tok = parser_current($parser);
    if ($tok->{"type"} ne "STR_LITERAL") {
        parser_error($parser, "import_archive requires a string archive filename (e.g., \"MyLib.a\")");
    }
    my str $arch_file = $tok->{"value"};
    parser_advance($parser);

    parser_expect($parser, "SEMI");

    # Find the .a file in lib paths
    my str $a_path = find_a_file($program, $arch_file);
    if (length($a_path) == 0) {
        parser_error($parser, "cannot find archive file: " . $arch_file);
    }

    # Extract package name by stripping .a extension
    my str $arch_name = $arch_file;
    if (length($arch_file) > 2 && substr($arch_file, length($arch_file) - 2, 2) eq ".a") {
        $arch_name = substr($arch_file, 0, length($arch_file) - 2);
    }

    # Extract export metadata from the archive file
    my str $metadata = extract_archive_export_info($parser, $arch_name, $a_path);

    # Parse the metadata using the same function as import_lib/import_object
    my scalar $arch_info = parse_export_metadata($arch_name, $a_path, $metadata);

    # Add a_path to the result
    $arch_info->{"a_path"} = $a_path;

    # Add to program
    ast_add_import_archive($program, $arch_info);
}

func parse_program(scalar $parser, scalar $lib_paths, scalar $lib_paths_low) scalar {
    my scalar $program = ast_new_program();

    # Add command-line library paths first (high priority - before any use statements)
    my int $path_count = size($lib_paths);
    my int $path_i = 0;
    while ($path_i < $path_count) {
        my str $path = $lib_paths->[$path_i];
        ast_add_lib_path($program, $path);
        $path_i = $path_i + 1;
    }

    # Store low-priority paths to add after parsing
    my int $low_path_count = size($lib_paths_low);

    while (!parser_check($parser, "EOF")) {
        # Check for private or async func
        my int $is_private = 0;
        my int $is_async = 0;
        if (parser_check($parser, "PRIVATE")) {
            parser_advance($parser);
            $is_private = 1;
            if (!parser_check($parser, "FUNC") && !parser_check($parser, "ASYNC")) {
                parser_error($parser, "expected 'func' or 'async func' after 'private'");
            }
        }
        if (parser_check($parser, "ASYNC")) {
            parser_advance($parser);
            $is_async = 1;
            if (!parser_check($parser, "FUNC")) {
                parser_error($parser, "expected 'func' after 'async'");
            }
        }

        if (parser_check($parser, "FUNC")) {
            my scalar $fn = parse_function($parser);
            $fn->{"is_private"} = $is_private;
            if ($is_async == 1) {
                $fn->{"type"} = NODE_ASYNC_FUNC();
            }
            # Auto-prefix function names with package name
            my str $pkg = $program->{"package"};
            my str $fn_name = $fn->{"name"};
            # Store the package in the function node for OOP registration
            $fn->{"package"} = $pkg;
            # Auto-prefix for all packages (not main)
            # For packages with :: (e.g., Nesso::Record), convert to _ for C identifier
            if (length($pkg) > 0 && $pkg ne "main" && $fn_name ne "main") {
                # Convert :: to _ for C-compatible prefix
                my str $c_pkg = $pkg;
                my int $colon_idx = index($c_pkg, "::");
                while ($colon_idx >= 0) {
                    $c_pkg = substr($c_pkg, 0, $colon_idx) . "_" . substr($c_pkg, $colon_idx + 2, length($c_pkg) - $colon_idx - 2);
                    $colon_idx = index($c_pkg, "::");
                }
                # Check if function already has the package prefix
                my str $prefix = $c_pkg . "_";
                my int $prefix_len = length($prefix);
                if (length($fn_name) < $prefix_len || substr($fn_name, 0, $prefix_len) ne $prefix) {
                    # Always prefix functions in a package
                    $fn->{"name"} = $c_pkg . "_" . $fn_name;
                }
            }
            ast_add_function($program, $fn);
        } elsif (parser_check($parser, "EXTERN")) {
            # Check if this is extern "C" { } or extern func
            # Peek ahead to see if next token is a string
            my scalar $next_tok = parser_peek($parser);
            if ($next_tok->{"type"} eq "STR_LITERAL") {
                # extern "C" { ... } block
                parse_extern_c_block($parser, $program);
            } else {
                # Traditional extern func declaration
                my scalar $fn = parse_extern_function($parser);
                # Do NOT auto-prefix extern function names - they link to external C functions
                # with specific names that must not be modified
                my str $pkg = $program->{"package"};
                $fn->{"package"} = $pkg;
                ast_add_function($program, $fn);
            }
        } elsif (parser_check($parser, "STRUCT")) {
            my scalar $st = parse_struct($parser);
            ast_add_struct($program, $st);
        } elsif (parser_check($parser, "ENUM")) {
            my scalar $en = parse_enum($parser);
            ast_add_enum($program, $en);
        } elsif (parser_check($parser, "PACKAGE")) {
            parse_package($parser, $program);
        } elsif (parser_check($parser, "VERSION")) {
            parse_version($parser, $program);
        } elsif (parser_check($parser, "INHERIT")) {
            parse_inherit($parser, $program);
        } elsif (parser_check($parser, "USE")) {
            parse_use($parser, $program);
        } elsif (parser_check($parser, "IMPORT_LIB")) {
            parse_import_lib($parser, $program);
        } elsif (parser_check($parser, "IMPORT_OBJECT")) {
            parse_import_object($parser, $program);
        } elsif (parser_check($parser, "IMPORT_ARCHIVE")) {
            parse_import_archive($parser, $program);
        } elsif (parser_check($parser, "MY")) {
            my scalar $var = parse_var_decl($parser);
            ast_add_global($program, $var);
        } elsif (parser_check($parser, "C_BLOCK")) {
            # Top-level __C__ { ... } block
            my scalar $tok = parser_current($parser);
            my str $c_code = $tok->{"value"};
            parser_advance($parser);
            ast_add_c_block($program, $c_code);
        } else {
            parser_error($parser, "expected function, extern, struct, enum, package, inherit, use, import_lib, import_object, import_archive, __C__, or variable declaration");
        }
    }

    # Add low-priority library paths last (after all use lib statements)
    $path_i = 0;
    while ($path_i < $low_path_count) {
        my str $path = $lib_paths_low->[$path_i];
        ast_add_lib_path($program, $path);
        $path_i = $path_i + 1;
    }

    return $program;
}

# ============================================================
# Main Entry Point
# ============================================================

func parse(scalar $tokens, str $filename) scalar {
    my scalar $parser = parser_new($tokens);
    parser_set_filename($parser, $filename);
    my array @empty_paths = ();
    my array @empty_paths_low = ();
    return parse_program($parser, \@empty_paths, \@empty_paths_low);
}

# Parse with pre-configured library paths (from -L and -LL command line options)
func parse_with_lib_paths(scalar $tokens, str $filename, scalar $lib_paths, scalar $lib_paths_low) scalar {
    my scalar $parser = parser_new($tokens);
    parser_set_filename($parser, $filename);
    return parse_program($parser, $lib_paths, $lib_paths_low);
}
