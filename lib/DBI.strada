# DBI - Database Interface for Strada
#
# A Perl DBI-like interface for database operations.
# Supports SQLite, MySQL/MariaDB, and PostgreSQL.
#
# Usage:
#   use lib "lib";
#   use DBI;
#
#   # Connect to SQLite
#   my scalar $dbh = DBI::connect("dbi:SQLite:test.db", "", "");
#
#   # Create table
#   DBI::do($dbh, "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)");
#
#   # Insert with placeholders
#   DBI::do($dbh, "INSERT INTO users (name) VALUES (?)", ["Alice"]);
#
#   # Query
#   my scalar $sth = DBI::prepare($dbh, "SELECT * FROM users");
#   DBI::execute($sth, []);
#   while (my scalar $row = DBI::fetchrow_hashref($sth)) {
#       say($row->{"name"});
#   }
#
#   DBI::disconnect($dbh);
#
# DSN Formats:
#   dbi:SQLite:database.db
#   dbi:SQLite:dbname=/path/to/db.sqlite
#   dbi:mysql:database=test;host=localhost;port=3306
#   dbi:Pg:dbname=test;host=localhost;port=5432
#
# Requires: lib/dbi/libstrada_dbi.so (build with: cd lib/dbi && make)

package DBI;

# Load the library - tries multiple paths
func _get_lib() int {
    my int $lib = sys::dl_open("lib/dbi/libstrada_dbi.so");
    if ($lib == 0) {
        $lib = sys::dl_open("./lib/dbi/libstrada_dbi.so");
    }
    if ($lib == 0) {
        $lib = sys::dl_open("libstrada_dbi.so");
    }
    return $lib;
}

# Connect to a database
# Returns a database handle (hash reference) or undef on failure
#
# DSN examples:
#   "dbi:SQLite:test.db" - SQLite file database
#   "dbi:SQLite::memory:" - SQLite in-memory database
#   "dbi:mysql:database=test;host=localhost" - MySQL connection
#   "dbi:Pg:dbname=test" - PostgreSQL connection
#
# Attributes hash (optional):
#   { AutoCommit => 1, RaiseError => 0, PrintError => 1 }
func connect(str $dsn, str $username, str $password) scalar {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return undef;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_connect");
    my scalar $attrs = { "AutoCommit" => 1, "RaiseError" => 0, "PrintError" => 1 };
    return sys::dl_call_sv($fn, [$dsn, $username, $password, $attrs]);
}

# Connect with attributes
func connect_attrs(str $dsn, str $username, str $password, scalar $attrs) scalar {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return undef;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_connect");
    return sys::dl_call_sv($fn, [$dsn, $username, $password, $attrs]);
}

# Disconnect from database
func disconnect(scalar $dbh) void {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_disconnect");
    sys::dl_call_void_sv($fn, [$dbh]);
}

# Prepare a SQL statement
# Returns a statement handle (hash reference)
func prepare(scalar $dbh, str $sql) scalar {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return undef;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_prepare");
    return sys::dl_call_sv($fn, [$dbh, $sql]);
}

# Execute a prepared statement
# params should be an array reference with bind values
# Returns number of affected rows, or -1 on error
func execute(scalar $sth, scalar $params) int {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return -1;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_execute");
    my scalar $result = sys::dl_call_sv($fn, [$sth, $params]);
    return $result + 0;
}

# Execute SQL directly (prepare + execute)
# Useful for INSERT, UPDATE, DELETE, CREATE, etc.
# Returns number of affected rows, or -1 on error
func do(scalar $dbh, str $sql, scalar $params) int {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return -1;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_do");
    my scalar $result = sys::dl_call_sv($fn, [$dbh, $sql, $params]);
    return $result + 0;
}

# Convenience: execute without params
func do_sql(scalar $dbh, str $sql) int {
    return DBI::do($dbh, $sql, []);
}

# Fetch next row as array reference
# Returns undef when no more rows
func fetchrow_array(scalar $sth) scalar {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return undef;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_fetchrow_array");
    return sys::dl_call_sv($fn, [$sth]);
}

# Fetch next row as hash reference
# Keys are column names
# Returns undef when no more rows
func fetchrow_hashref(scalar $sth) scalar {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return undef;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_fetchrow_hashref");
    return sys::dl_call_sv($fn, [$sth]);
}

# Fetch all rows as array of array refs
func fetchall_arrayref(scalar $sth) scalar {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return [];
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_fetchall_arrayref");
    return sys::dl_call_sv($fn, [$sth]);
}

# Begin a transaction
func begin_work(scalar $dbh) int {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return -1;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_begin_work");
    my scalar $result = sys::dl_call_sv($fn, [$dbh]);
    return $result + 0;
}

# Commit transaction
func commit(scalar $dbh) int {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return -1;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_commit");
    my scalar $result = sys::dl_call_sv($fn, [$dbh]);
    return $result + 0;
}

# Rollback transaction
func rollback(scalar $dbh) int {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return -1;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_rollback");
    my scalar $result = sys::dl_call_sv($fn, [$dbh]);
    return $result + 0;
}

# Quote a string value for safe use in SQL
func quote(scalar $dbh, str $value) str {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return "''";
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_quote");
    my scalar $result = sys::dl_call_sv($fn, [$dbh, $value]);
    return "" . $result;
}

# Get last insert ID (auto-increment value)
func last_insert_id(scalar $dbh) int {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return -1;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_last_insert_id");
    my scalar $result = sys::dl_call_sv($fn, [$dbh]);
    return $result + 0;
}

# Get last error message
func errstr(scalar $dbh) str {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return "Library not loaded";
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_errstr");
    my scalar $result = sys::dl_call_sv($fn, [$dbh]);
    return "" . $result;
}

# Get last error code
func err(scalar $dbh) int {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return -1;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_err");
    my scalar $result = sys::dl_call_sv($fn, [$dbh]);
    return $result + 0;
}

# Finish statement (mark as done, release resources)
func finish(scalar $sth) void {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_finish");
    sys::dl_call_void_sv($fn, [$sth]);
}

# Get number of rows affected by last statement
func rows(scalar $sth) int {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return -1;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_rows");
    my scalar $result = sys::dl_call_sv($fn, [$sth]);
    return $result + 0;
}

# Get column names from statement
func column_names(scalar $sth) scalar {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return [];
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_column_names");
    return sys::dl_call_sv($fn, [$sth]);
}

# Check if connection is still alive
func ping(scalar $dbh) int {
    my int $lib = DBI::_get_lib();
    if ($lib == 0) {
        return 0;
    }

    my int $fn = sys::dl_sym($lib, "strada_dbi_ping");
    my scalar $result = sys::dl_call_sv($fn, [$dbh]);
    return $result + 0;
}

# ============================================================
# Convenience Functions
# ============================================================

# Select all rows into an array of hash refs
# Combines prepare, execute, fetchall as hashref
func selectall_hashref(scalar $dbh, str $sql, scalar $params) scalar {
    my scalar $sth = DBI::prepare($dbh, $sql);
    if (!defined($sth)) {
        return [];
    }

    DBI::execute($sth, $params);

    my scalar $results = [];
    my scalar $row = DBI::fetchrow_hashref($sth);
    while (defined($row)) {
        push($results, $row);
        $row = DBI::fetchrow_hashref($sth);
    }

    DBI::finish($sth);
    return $results;
}

# Select a single row as hash ref
func selectrow_hashref(scalar $dbh, str $sql, scalar $params) scalar {
    my scalar $sth = DBI::prepare($dbh, $sql);
    if (!defined($sth)) {
        return undef;
    }

    DBI::execute($sth, $params);
    my scalar $row = DBI::fetchrow_hashref($sth);
    DBI::finish($sth);
    return $row;
}

# Select a single column value
func selectcol(scalar $dbh, str $sql, scalar $params) scalar {
    my scalar $sth = DBI::prepare($dbh, $sql);
    if (!defined($sth)) {
        return undef;
    }

    DBI::execute($sth, $params);
    my scalar $row = DBI::fetchrow_array($sth);
    DBI::finish($sth);

    if (defined($row) && size($row) > 0) {
        return $row->[0];
    }
    return undef;
}

# Insert and return the new ID
func insert_get_id(scalar $dbh, str $sql, scalar $params) int {
    my int $result = DBI::do($dbh, $sql, $params);
    if ($result < 0) {
        return -1;
    }
    return DBI::last_insert_id($dbh);
}
