/*
 * This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 * Copyright (c) 2026 Michael J. Flickinger
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

# Time::HiRes - High-resolution time functions for Strada
#
# Usage:
#   use lib "lib";
#   use Time::HiRes;
#
# Provides high-resolution time constants and utility functions.
# The core functions (gettimeofday, hires_time, etc.) are builtins.

package Time::HiRes;

# ============================================================
# Clock ID Constants (for clock_gettime/clock_getres)
# ============================================================

func CLOCK_REALTIME() int { return 0; }
func CLOCK_MONOTONIC() int { return 1; }
func CLOCK_PROCESS_CPUTIME_ID() int { return 2; }
func CLOCK_THREAD_CPUTIME_ID() int { return 3; }
func CLOCK_MONOTONIC_RAW() int { return 4; }
func CLOCK_REALTIME_COARSE() int { return 5; }
func CLOCK_MONOTONIC_COARSE() int { return 6; }
func CLOCK_BOOTTIME() int { return 7; }

# ============================================================
# Nanosecond/Microsecond Constants
# ============================================================

func ONE_SECOND_NS() int { return 1000000000; }
func ONE_SECOND_US() int { return 1000000; }
func ONE_MILLISECOND_NS() int { return 1000000; }
func ONE_MILLISECOND_US() int { return 1000; }
func ONE_MICROSECOND_NS() int { return 1000; }

# ============================================================
# Utility Functions
# ============================================================

# clock_monotonic() - Get monotonic clock time as floating-point seconds
# Uses CLOCK_MONOTONIC for consistent timing unaffected by system clock changes
func clock_monotonic() num {
    my scalar $ts = clock_gettime(Time::HiRes::CLOCK_MONOTONIC());
    if (!defined($ts)) {
        return 0.0;
    }
    my int $sec = $ts->{"sec"};
    my int $nsec = $ts->{"nsec"};
    return $sec + $nsec / 1000000000.0;
}

# clock_realtime() - Get realtime clock as floating-point seconds
func clock_realtime() num {
    my scalar $ts = clock_gettime(Time::HiRes::CLOCK_REALTIME());
    if (!defined($ts)) {
        return 0.0;
    }
    my int $sec = $ts->{"sec"};
    my int $nsec = $ts->{"nsec"};
    return $sec + $nsec / 1000000000.0;
}

# sleep_ms($milliseconds) - Sleep for specified milliseconds
func sleep_ms(int $ms) int {
    my int $usecs = $ms * 1000;
    return usleep($usecs);
}

# sleep_us($microseconds) - Sleep for specified microseconds (alias)
func sleep_us(int $us) int {
    return usleep($us);
}

# sleep_ns($nanoseconds) - Sleep for specified nanoseconds
func sleep_ns(int $ns) int {
    return nanosleep($ns);
}

# elapsed($start_tv) - Get elapsed time since start (from gettimeofday)
# Returns floating-point seconds
func elapsed(scalar $start_tv) num {
    return tv_interval($start_tv);
}

# resolution($clock_id) - Get clock resolution in nanoseconds
func resolution(int $clock_id) int {
    my scalar $res = clock_getres($clock_id);
    if (!defined($res)) {
        return -1;
    }
    my int $sec = $res->{"sec"};
    my int $nsec = $res->{"nsec"};
    return $sec * 1000000000 + $nsec;
}

# timer_start() - Start a timer, returns gettimeofday hash
func timer_start() scalar {
    return gettimeofday();
}

# timer_elapsed($start) - Get elapsed time from timer_start
func timer_elapsed(scalar $start) num {
    return tv_interval($start);
}

# format_duration($seconds) - Format duration as human-readable string
func format_duration(num $seconds) str {
    if ($seconds < 0.000001) {
        my int $ns = $seconds * 1000000000;
        return $ns . "ns";
    }
    if ($seconds < 0.001) {
        my int $us = $seconds * 1000000;
        return $us . "us";
    }
    if ($seconds < 1.0) {
        my int $ms = $seconds * 1000;
        return $ms . "ms";
    }
    if ($seconds < 60.0) {
        return $seconds . "s";
    }
    my int $total_secs = $seconds;
    my int $mins = $total_secs / 60;
    my int $secs = $total_secs - ($mins * 60);
    return $mins . "m " . $secs . "s";
}

