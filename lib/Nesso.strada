/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# Nesso - Database Model Library for Strada (v2 - OOP)
#
# A thin, practical model layer over DBI. Records are NessoRecord objects
# with methods like save(), delete(), update(), reload(), related().
# Schema is defined as hashes describing columns, types, and primary key.
# Supports CRUD, simple queries, transactions, and relationships.
#
# Usage:
#   use lib "lib";
#   use DBI;
#   use Nesso;
#   use Nesso::Record;    # For ActiveRecord-style methods on records
#
#   my scalar $db = DBI::connect("dbi:SQLite:app.db", "", "");
#   my scalar $n = Nesso::new($db);
#
#   $n->define("users", {
#       "table"   => "users",
#       "columns" => ["id", "username", "email"],
#       "primary" => "id",
#       "class"   => "User"   # Optional: custom class (inherits Nesso::Record)
#   });
#
#   # Data Mapper style (works without Nesso::Record):
#   my scalar $user = $n->create("users", { "username" => "alice" });
#   $n->save($user);
#   $n->delete($user);
#
#   # ActiveRecord style (requires Nesso::Record):
#   my scalar $user = $n->create("users", { "username" => "alice" });
#   $user->save();
#   $user->update({ "email" => "a@b.com" });
#   $user->delete();
#
#   # Custom model classes:
#   # You can subclass Nesso::Record for specific models to add custom methods.
#   # Specify the class name in the schema definition:
#   #
#   #   $n->define("users", {
#   #       "table"   => "users",
#   #       "columns" => ["id", "username", "password_hash"],
#   #       "primary" => "id",
#   #       "class"   => "User"
#   #   });
#   #
#   # Then create your custom class inheriting from Nesso::Record:
#   #
#   #   package User;
#   #   inherit Nesso::Record;
#   #
#   #   func set_password(scalar $self, str $password) void {
#   #       $self->{"password_hash"} = crypt::hash_password($password);
#   #       $self->save();
#   #   }
#   #
#   #   func authenticate(scalar $self, str $password) int {
#   #       return crypt::check_password($password, $self->{"password_hash"});
#   #   }
#   #
#   # Now all records from the "users" model are blessed as User objects:
#   #   my scalar $user = $n->find("users", 1);  # Returns a User, not Nesso::Record
#   #   $user->set_password("secret");           # Custom method
#   #   $user->save();                           # Inherited from Nesso::Record
#   #   if (isa($user, "Nesso::Record")) { }     # True - User inherits from Nesso::Record

package Nesso;

# --- Internal helpers ---

# Log SQL when debug mode is enabled
func log_sql(scalar $self, str $sql, scalar $params) void {
    if ($self->{"_debug"}) {
        say("[Nesso] SQL: " . $sql);
        my str $param_str = "";
        my int $n = size($params);
        my int $i = 0;
        while ($i < $n) {
            if ($i > 0) {
                $param_str = $param_str . ", ";
            }
            my scalar $p = $params->[$i];
            if (defined($p)) {
                $param_str = $param_str . "\"" . $p . "\"";
            } else {
                $param_str = $param_str . "NULL";
            }
            $i++;
        }
        say("[Nesso] PARAMS: [" . $param_str . "]");
    }
}

# Get schema for a model, throwing if unknown
func get_schema(scalar $self, str $model) scalar {
    my scalar $schema = $self->{"_models"}->{$model};
    if (!defined($schema)) {
        throw "Nesso: unknown model '" . $model . "'";
    }
    return $schema;
}

# Build WHERE clause from conditions hash
func build_where_clause(scalar $self, scalar $conds, scalar $params) str {
    my array @cond_keys = keys($conds);
    my str $where = "";
    my int $first = 1;
    my int $i = 0;
    my int $nkeys = scalar(@cond_keys);
    while ($i < $nkeys) {
        my str $key = @cond_keys[$i];
        # Skip directives (keys starting with _)
        if (substr($key, 0, 1) ne "_") {
            if ($first == 0) {
                $where = $where . " AND ";
            }
            $where = $where . $key . " = ?";
            push(@{$params}, $conds->{$key});
            $first = 0;
        }
        $i++;
    }
    return $where;
}

# Wrap a raw hash as a NessoRecord object
func wrap_record(scalar $self, str $model, scalar $row) scalar {
    if (!defined($row)) {
        return undef;
    }
    $row->{"_model"} = $model;
    $row->{"_nesso"} = $self;

    # Check if model has a custom class defined
    my scalar $schema = $self->{"_models"}->{$model};
    my str $class = "Nesso::Record";
    if (defined($schema) && defined($schema->{"class"})) {
        $class = $schema->{"class"};
    }

    return bless($row, $class);
}

# Wrap all rows in a result set as NessoRecord objects
func tag_rows(scalar $self, str $model, scalar $rows) scalar {
    if (!defined($rows)) {
        return [];
    }
    my int $nrows = size($rows);
    my int $i = 0;
    while ($i < $nrows) {
        $rows->[$i] = $self->wrap_record($model, $rows->[$i]);
        $i++;
    }
    return $rows;
}

# --- Constructor ---

# Create a new Nesso instance with the given DBI handle
func new(scalar $dbh) scalar {
    my hash %self = ();
    $self{"_dbh"} = $dbh;
    $self{"_models"} = {};
    $self{"_relations"} = {};
    $self{"_debug"} = 0;
    return bless(\%self, "Nesso");
}

# --- DB handle management ---

func set_db(scalar $self, scalar $db) void {
    $self->{"_dbh"} = $db;
}

func get_db(scalar $self) scalar {
    return $self->{"_dbh"};
}

# --- Debug mode ---

func set_debug(scalar $self, int $on) void {
    $self->{"_debug"} = $on;
}

func get_debug(scalar $self) int {
    return $self->{"_debug"};
}

# --- Schema definition ---

func define(scalar $self, str $name, scalar $schema) void {
    $self->{"_models"}->{$name} = $schema;
}

func columns(scalar $self, str $model) scalar {
    my scalar $schema = $self->get_schema($model);
    return $schema->{"columns"};
}

# --- CRUD ---

# Create a new record (not saved yet)
func create(scalar $self, str $model, scalar $attrs) scalar {
    my scalar $schema = $self->get_schema($model);

    my hash %record = ();

    # Copy attributes
    my scalar $cols = $schema->{"columns"};
    my int $ncols = size($cols);
    my int $i = 0;
    while ($i < $ncols) {
        my str $col = $cols->[$i];
        my scalar $val = $attrs->{$col};
        if (defined($val)) {
            $record{$col} = $val;
        }
        $i++;
    }

    return $self->wrap_record($model, \%record);
}

# Save a record (INSERT or UPDATE). Returns the id.
func save(scalar $self, scalar $record) int {
    my str $model_name = $record->{"_model"};
    my scalar $schema = $self->get_schema($model_name);
    my scalar $db = $self->{"_dbh"};

    my str $table = $schema->{"table"};
    my str $pk = $schema->{"primary"};
    my scalar $cols = $schema->{"columns"};
    my int $ncols = size($cols);

    # Check if this is an update (has primary key value > 0)
    my scalar $pk_val = $record->{$pk};
    if (defined($pk_val) && $pk_val + 0 > 0) {
        # UPDATE
        my str $sql = "UPDATE " . $table . " SET ";
        my array @params = ();
        my int $first = 1;
        my int $i = 0;
        while ($i < $ncols) {
            my str $col = $cols->[$i];
            if ($col ne $pk) {
                my scalar $val = $record->{$col};
                if (defined($val)) {
                    if ($first == 0) {
                        $sql = $sql . ", ";
                    }
                    $sql = $sql . $col . " = ?";
                    push(@params, $val);
                    $first = 0;
                }
            }
            $i++;
        }
        $sql = $sql . " WHERE " . $pk . " = ?";
        push(@params, $pk_val);
        $self->log_sql($sql, \@params);
        DBI::exec($db, $sql, \@params);
        return $pk_val + 0;
    } else {
        # INSERT
        my str $col_list = "";
        my str $placeholders = "";
        my array @params = ();
        my int $first = 1;
        my int $i = 0;
        while ($i < $ncols) {
            my str $col = $cols->[$i];
            if ($col ne $pk) {
                my scalar $val = $record->{$col};
                if (defined($val)) {
                    if ($first == 0) {
                        $col_list = $col_list . ", ";
                        $placeholders = $placeholders . ", ";
                    }
                    $col_list = $col_list . $col;
                    $placeholders = $placeholders . "?";
                    push(@params, $val);
                    $first = 0;
                }
            }
            $i++;
        }
        my str $sql = "INSERT INTO " . $table . " (" . $col_list . ") VALUES (" . $placeholders . ")";
        $self->log_sql($sql, \@params);
        my int $id = DBI::insert_get_id($db, $sql, \@params);
        $record->{$pk} = $id;
        return $id;
    }
}

# Find a record by primary key
func find(scalar $self, str $model, int $id) scalar {
    my scalar $schema = $self->get_schema($model);
    my scalar $db = $self->{"_dbh"};

    my str $table = $schema->{"table"};
    my str $pk = $schema->{"primary"};
    my str $sql = "SELECT * FROM " . $table . " WHERE " . $pk . " = ?";
    $self->log_sql($sql, [$id]);
    my scalar $row = DBI::selectrow_hashref($db, $sql, [$id]);
    return $self->wrap_record($model, $row);
}

# Find first record matching conditions
func find_by(scalar $self, str $model, scalar $conds) scalar {
    my scalar $schema = $self->get_schema($model);
    my scalar $db = $self->{"_dbh"};

    my str $table = $schema->{"table"};
    my str $sql = "SELECT * FROM " . $table;
    my array @params = ();

    my str $wc = $self->build_where_clause($conds, \@params);
    if ($wc ne "") {
        $sql = $sql . " WHERE " . $wc;
    }

    # Check for directives
    if (defined($conds->{"_order"})) {
        $sql = $sql . " ORDER BY " . $conds->{"_order"};
    }

    $sql = $sql . " LIMIT 1";

    $self->log_sql($sql, \@params);
    my scalar $row = DBI::selectrow_hashref($db, $sql, \@params);
    return $self->wrap_record($model, $row);
}

# Find all records matching conditions
func where(scalar $self, str $model, scalar $conds) scalar {
    my scalar $schema = $self->get_schema($model);
    my scalar $db = $self->{"_dbh"};

    my str $table = $schema->{"table"};
    my str $sql = "SELECT * FROM " . $table;
    my array @params = ();

    my str $wc = $self->build_where_clause($conds, \@params);
    if ($wc ne "") {
        $sql = $sql . " WHERE " . $wc;
    }

    # Check for directives
    if (defined($conds->{"_order"})) {
        $sql = $sql . " ORDER BY " . $conds->{"_order"};
    }
    if (defined($conds->{"_limit"})) {
        $sql = $sql . " LIMIT " . $conds->{"_limit"};
    }
    if (defined($conds->{"_offset"})) {
        $sql = $sql . " OFFSET " . $conds->{"_offset"};
    }

    $self->log_sql($sql, \@params);
    my scalar $rows = DBI::selectall_hashref($db, $sql, \@params);
    return $self->tag_rows($model, $rows);
}

# Get all records for a model
func all(scalar $self, str $model) scalar {
    my scalar $schema = $self->get_schema($model);
    my scalar $db = $self->{"_dbh"};

    my str $table = $schema->{"table"};
    my str $sql = "SELECT * FROM " . $table;
    $self->log_sql($sql, []);
    my scalar $rows = DBI::selectall_hashref($db, $sql, []);
    return $self->tag_rows($model, $rows);
}

# Count records matching conditions
func count(scalar $self, str $model, scalar $conds) int {
    my scalar $schema = $self->get_schema($model);
    my scalar $db = $self->{"_dbh"};

    my str $table = $schema->{"table"};
    my str $sql = "SELECT COUNT(*) FROM " . $table;
    my array @params = ();

    my str $wc = $self->build_where_clause($conds, \@params);
    if ($wc ne "") {
        $sql = $sql . " WHERE " . $wc;
    }

    $self->log_sql($sql, \@params);
    my scalar $result = DBI::selectcol($db, $sql, \@params);
    if (defined($result)) {
        return $result + 0;
    }
    return 0;
}

# Delete a record by primary key
func delete(scalar $self, scalar $record) int {
    my str $model_name = $record->{"_model"};
    my scalar $schema = $self->get_schema($model_name);
    my scalar $db = $self->{"_dbh"};

    my str $table = $schema->{"table"};
    my str $pk = $schema->{"primary"};
    my scalar $pk_val = $record->{$pk};

    my str $sql = "DELETE FROM " . $table . " WHERE " . $pk . " = ?";
    $self->log_sql($sql, [$pk_val]);
    return DBI::exec($db, $sql, [$pk_val]);
}

# Raw SQL query - returns array of hash refs
func query(scalar $self, str $sql, scalar $params) scalar {
    my scalar $db = $self->{"_dbh"};
    $self->log_sql($sql, $params);
    return DBI::selectall_hashref($db, $sql, $params);
}

# Transaction wrapper - auto-commits on success, rolls back on throw
func transaction(scalar $self, scalar $cb) void {
    my scalar $db = $self->{"_dbh"};
    DBI::begin_work($db);
    try {
        $cb->();
        DBI::commit($db);
    } catch ($e) {
        DBI::rollback($db);
        throw $e;
    }
}

# --- Relationships ---

# Declare a has_many relationship: owner has many name (via fk on target table)
func has_many(scalar $self, str $owner, str $name, str $fk) void {
    my str $key = $owner . ":" . $name;
    my hash %rel = ();
    $rel{"type"} = "has_many";
    $rel{"model"} = $name;
    $rel{"key"} = $fk;
    $self->{"_relations"}->{$key} = \%rel;
}

# Declare a belongs_to relationship: owner belongs_to name (which is target model, via fk)
func belongs_to(scalar $self, str $owner, str $name, str $target, str $fk) void {
    my str $key = $owner . ":" . $name;
    my hash %rel = ();
    $rel{"type"} = "belongs_to";
    $rel{"model"} = $target;
    $rel{"key"} = $fk;
    $self->{"_relations"}->{$key} = \%rel;
}

# Declare a has_one relationship: owner has_one name (which is target model, via fk)
func has_one(scalar $self, str $owner, str $name, str $target, str $fk) void {
    my str $key = $owner . ":" . $name;
    my hash %rel = ();
    $rel{"type"} = "has_one";
    $rel{"model"} = $target;
    $rel{"key"} = $fk;
    $self->{"_relations"}->{$key} = \%rel;
}

# Fetch related records for a given record and relation name
func related(scalar $self, scalar $record, str $name) scalar {
    my str $model_name = $record->{"_model"};
    my str $rel_key = $model_name . ":" . $name;
    my scalar $rel = $self->{"_relations"}->{$rel_key};
    if (!defined($rel)) {
        throw "Nesso: unknown relation '" . $name . "' on model '" . $model_name . "'";
    }

    my str $type = $rel->{"type"};
    my str $rel_model = $rel->{"model"};
    my str $fk = $rel->{"key"};

    if ($type eq "has_many") {
        my scalar $schema = $self->get_schema($model_name);
        my str $pk = $schema->{"primary"};
        my scalar $pk_val = $record->{$pk};
        my hash %conds = ();
        $conds{$fk} = $pk_val;
        return $self->where($rel_model, \%conds);
    }

    if ($type eq "belongs_to") {
        my scalar $fk_val = $record->{$fk};
        if (!defined($fk_val)) {
            return undef;
        }
        return $self->find($rel_model, $fk_val + 0);
    }

    if ($type eq "has_one") {
        my scalar $schema = $self->get_schema($model_name);
        my str $pk = $schema->{"primary"};
        my scalar $pk_val = $record->{$pk};
        my hash %conds = ();
        $conds{$fk} = $pk_val;
        return $self->find_by($rel_model, \%conds);
    }

    throw "Nesso: unknown relation type '" . $type . "'";
}

# --- Cloning ---

# Clone this Nesso instance with a different db handle but same schemas and relations
func clone(scalar $self, scalar $new_dbh) scalar {
    my hash %new_self = ();
    $new_self{"_dbh"} = $new_dbh;
    $new_self{"_models"} = $self->{"_models"};
    $new_self{"_relations"} = $self->{"_relations"};
    $new_self{"_debug"} = $self->{"_debug"};
    return bless(\%new_self, "Nesso");
}
