/*
 * This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 * Copyright (c) 2026 Michael J. Flickinger
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

# LWP - Library for WWW access in Strada
# Inspired by Perl's LWP::UserAgent
#
# Usage:
#   use lib "lib";
#   use LWP;
#
#   my hash %response = LWP::get("http://example.com");
#   say($response{"content"});
#
#   my hash %response = LWP::post("http://example.com/api", "data=value");

package LWP;

# Parse a URL into components
# Returns hash with: scheme, host, port, path, query
func parse_url(str $url) hash {
    my hash %result = ();

    # Default values
    $result{"scheme"} = "http";
    $result{"host"} = "";
    $result{"port"} = 80;
    $result{"path"} = "/";
    $result{"query"} = "";

    my str $remaining = $url;

    # Extract scheme
    my int $scheme_end = index($remaining, "://");
    if ($scheme_end > 0) {
        $result{"scheme"} = substr($remaining, 0, $scheme_end);
        $remaining = substr($remaining, $scheme_end + 3, length($remaining) - $scheme_end - 3);

        if ($result{"scheme"} eq "https") {
            $result{"port"} = 443;
        }
    }

    # Extract host and port
    my int $path_start = index($remaining, "/");
    my str $host_part = "";
    if ($path_start < 0) {
        $host_part = $remaining;
        $remaining = "/";
    } else {
        $host_part = substr($remaining, 0, $path_start);
        $remaining = substr($remaining, $path_start, length($remaining) - $path_start);
    }

    # Check for port in host
    my int $port_sep = index($host_part, ":");
    if ($port_sep > 0) {
        $result{"host"} = substr($host_part, 0, $port_sep);
        my str $port_str = substr($host_part, $port_sep + 1, length($host_part) - $port_sep - 1);
        $result{"port"} = cast_int($port_str);
    } else {
        $result{"host"} = $host_part;
    }

    # Extract path and query
    my int $query_start = index($remaining, "?");
    if ($query_start >= 0) {
        $result{"path"} = substr($remaining, 0, $query_start);
        $result{"query"} = substr($remaining, $query_start + 1, length($remaining) - $query_start - 1);
    } else {
        $result{"path"} = $remaining;
    }

    if (length($result{"path"}) == 0) {
        $result{"path"} = "/";
    }

    return %result;
}

# URL encode a string
func url_encode(str $s) str {
    my str $result = "";
    my int $i = 0;
    while ($i < length($s)) {
        my str $c = substr($s, $i, 1);
        my int $code = ord($c);

        # Unreserved characters (RFC 3986)
        if (($code >= 65 && $code <= 90) ||   # A-Z
            ($code >= 97 && $code <= 122) ||  # a-z
            ($code >= 48 && $code <= 57) ||   # 0-9
            $c eq "-" || $c eq "_" || $c eq "." || $c eq "~") {
            $result = $result . $c;
        } else {
            # Percent encode
            my int $hi = cast_int($code / 16);
            my int $lo = $code % 16;
            my str $hex = "%";
            if ($hi < 10) { $hex = $hex . chr(48 + $hi); }
            else { $hex = $hex . chr(55 + $hi); }
            if ($lo < 10) { $hex = $hex . chr(48 + $lo); }
            else { $hex = $hex . chr(55 + $lo); }
            $result = $result . $hex;
        }
        $i = $i + 1;
    }
    return $result;
}

# URL decode a string
func url_decode(str $s) str {
    my str $result = "";
    my int $i = 0;
    while ($i < length($s)) {
        my str $c = substr($s, $i, 1);
        if ($c eq "%" && $i + 2 < length($s)) {
            my str $hex = substr($s, $i + 1, 2);
            my int $val = 0;
            my int $j = 0;
            while ($j < 2) {
                my str $h = substr($hex, $j, 1);
                my int $hc = ord($h);
                $val = $val * 16;
                if ($hc >= 48 && $hc <= 57) { $val = $val + ($hc - 48); }
                elsif ($hc >= 65 && $hc <= 70) { $val = $val + ($hc - 55); }
                elsif ($hc >= 97 && $hc <= 102) { $val = $val + ($hc - 87); }
                $j = $j + 1;
            }
            $result = $result . chr($val);
            $i = $i + 3;
        } elsif ($c eq "+") {
            $result = $result . " ";
            $i = $i + 1;
        } else {
            $result = $result . $c;
            $i = $i + 1;
        }
    }
    return $result;
}

# Build query string from hash
func build_query(hash %params) str {
    my str $result = "";
    my array @keys = keys(%params);
    my int $i = 0;
    while ($i < scalar(@keys)) {
        my str $key = @keys[$i];
        if ($i > 0) {
            $result = $result . "&";
        }
        $result = $result . LWP::url_encode($key) . "=" . LWP::url_encode($params{$key});
        $i = $i + 1;
    }
    return $result;
}

# Parse response headers
func parse_headers(str $header_block) hash {
    my hash %headers = ();
    my array @lines = split("\r\n", $header_block);

    my int $i = 0;
    while ($i < scalar(@lines)) {
        my str $line = @lines[$i];
        my int $colon = index($line, ":");
        if ($colon > 0) {
            my str $name = substr($line, 0, $colon);
            my str $value = substr($line, $colon + 1, length($line) - $colon - 1);
            # Trim leading space from value
            while (length($value) > 0 && substr($value, 0, 1) eq " ") {
                $value = substr($value, 1, length($value) - 1);
            }
            # Store lowercase header name for easy lookup
            $headers{lc($name)} = $value;
        }
        $i = $i + 1;
    }

    return %headers;
}

# Parse HTTP response
func parse_response(str $raw) hash {
    my hash %response = ();
    $response{"success"} = 0;
    $response{"status"} = 0;
    $response{"reason"} = "";
    $response{"content"} = "";

    # Find header/body separator
    my int $sep = index($raw, "\r\n\r\n");
    if ($sep < 0) {
        $response{"error"} = "Invalid HTTP response: no header separator";
        return %response;
    }

    my str $header_section = substr($raw, 0, $sep);
    my str $body = substr($raw, $sep + 4, length($raw) - $sep - 4);

    # Parse status line
    my int $first_line_end = index($header_section, "\r\n");
    my str $status_line = "";
    my str $headers_text = "";
    if ($first_line_end > 0) {
        $status_line = substr($header_section, 0, $first_line_end);
        $headers_text = substr($header_section, $first_line_end + 2, length($header_section) - $first_line_end - 2);
    } else {
        $status_line = $header_section;
    }

    # Parse "HTTP/1.1 200 OK"
    my array @status_parts = split(" ", $status_line);
    if (scalar(@status_parts) >= 2) {
        $response{"protocol"} = @status_parts[0];
        $response{"status"} = cast_int(@status_parts[1]);
        if (scalar(@status_parts) >= 3) {
            # Join remaining parts for reason phrase
            my str $reason = "";
            my int $i = 2;
            while ($i < scalar(@status_parts)) {
                if ($i > 2) { $reason = $reason . " "; }
                $reason = $reason . @status_parts[$i];
                $i = $i + 1;
            }
            $response{"reason"} = $reason;
        }
    }

    # Parse headers
    my hash %hdrs = LWP::parse_headers($headers_text);
    $response{"headers"} = \%hdrs;

    # Set content
    $response{"content"} = $body;

    # Determine success (2xx status codes)
    my int $status = $response{"status"};
    if ($status >= 200 && $status < 300) {
        $response{"success"} = 1;
    }

    return %response;
}

# Internal: read HTTP response from socket
func read_response(scalar $sock) str {
    my str $response = "";
    my int $max_reads = 1000;
    my int $reads = 0;

    while ($reads < $max_reads) {
        my str $chunk = sys::socket_recv($sock, 8192);
        if (!defined($chunk) || length($chunk) == 0) {
            break;
        }
        $response = $response . $chunk;
        $reads = $reads + 1;

        # Check if we have complete response
        # For now, simple heuristic - if we got headers and some content
        my int $header_end = index($response, "\r\n\r\n");
        if ($header_end > 0) {
            # Check Content-Length if present
            my str $headers_part = substr($response, 0, $header_end);
            my str $headers_lower = lc($headers_part);
            my int $cl_pos = index($headers_lower, "content-length:");
            if ($cl_pos >= 0) {
                my int $cl_end = index($headers_part, "\r\n", $cl_pos);
                if ($cl_end < 0) { $cl_end = length($headers_part); }
                my str $cl_line = substr($headers_part, $cl_pos + 15, $cl_end - $cl_pos - 15);
                # Trim spaces
                while (length($cl_line) > 0 && substr($cl_line, 0, 1) eq " ") {
                    $cl_line = substr($cl_line, 1, length($cl_line) - 1);
                }
                my int $content_length = cast_int($cl_line);
                my int $body_start = $header_end + 4;
                my int $body_len = length($response) - $body_start;
                if ($body_len >= $content_length) {
                    break;
                }
            }
        }
    }

    return $response;
}

# Internal: Make HTTP request
func do_request(str $method, str $url, str $body, hash %options) hash {
    my hash %url_parts = LWP::parse_url($url);

    my str $host = $url_parts{"host"};
    my int $port = $url_parts{"port"};
    my str $path = $url_parts{"path"};
    my str $query = $url_parts{"query"};
    my str $scheme = $url_parts{"scheme"};

    if (length($query) > 0) {
        $path = $path . "?" . $query;
    }

    # Build request
    my str $request = $method . " " . $path . " HTTP/1.1\r\n";
    $request = $request . "Host: " . $host . "\r\n";

    # User-Agent
    my str $ua = "Strada-LWP/1.0";
    if (defined($options{"user_agent"})) {
        $ua = $options{"user_agent"};
    }
    $request = $request . "User-Agent: " . $ua . "\r\n";

    # Connection
    $request = $request . "Connection: close\r\n";

    # Custom headers
    if (defined($options{"headers"})) {
        my scalar $custom_headers = $options{"headers"};
        my array @hkeys = keys($custom_headers);
        my int $i = 0;
        while ($i < scalar(@hkeys)) {
            my str $hname = @hkeys[$i];
            $request = $request . $hname . ": " . $custom_headers->{$hname} . "\r\n";
            $i = $i + 1;
        }
    }

    # Body for POST/PUT
    if (length($body) > 0) {
        if (!defined($options{"headers"}) || !defined($options{"headers"}->{"Content-Type"})) {
            $request = $request . "Content-Type: application/x-www-form-urlencoded\r\n";
        }
        $request = $request . "Content-Length: " . length($body) . "\r\n";
    }

    $request = $request . "\r\n";

    if (length($body) > 0) {
        $request = $request . $body;
    }

    # Connect and send
    my hash %response = ();
    $response{"success"} = 0;

    if ($scheme eq "https") {
        # HTTPS requires the SSL library to be linked
        # Use: use lib "lib/ssl"; use SSL; and compile with -lssl -lcrypto
        $response{"error"} = "HTTPS not supported - use HTTP or link SSL library";
        return %response;
    }

    # Plain HTTP
    my scalar $sock = sys::socket_client($host, $port);
    if (!defined($sock)) {
        $response{"error"} = "Connection failed to " . $host . ":" . $port;
        return %response;
    }

    sys::socket_send($sock, $request);

    my str $raw_response = LWP::read_response($sock);
    sys::socket_close($sock);

    return LWP::parse_response($raw_response);
}

# GET request
func get(str $url) hash {
    my hash %empty = ();
    return LWP::do_request("GET", $url, "", %empty);
}

# GET request with options
func get_with_options(str $url, hash %options) hash {
    return LWP::do_request("GET", $url, "", %options);
}

# POST request
func post(str $url, str $data) hash {
    my hash %empty = ();
    return LWP::do_request("POST", $url, $data, %empty);
}

# POST request with options
func post_with_options(str $url, str $data, hash %options) hash {
    return LWP::do_request("POST", $url, $data, %options);
}

# POST form data (from hash)
func post_form(str $url, hash %form_data) hash {
    my str $body = LWP::build_query(%form_data);
    my hash %empty = ();
    return LWP::do_request("POST", $url, $body, %empty);
}

# PUT request
func put(str $url, str $data) hash {
    my hash %empty = ();
    return LWP::do_request("PUT", $url, $data, %empty);
}

# DELETE request
func delete_req(str $url) hash {
    my hash %empty = ();
    return LWP::do_request("DELETE", $url, "", %empty);
}

# HEAD request (get headers only)
func head(str $url) hash {
    my hash %empty = ();
    return LWP::do_request("HEAD", $url, "", %empty);
}

# Simple content fetch (returns just the content string or empty on error)
func get_content(str $url) str {
    my hash %resp = LWP::get($url);
    if ($resp{"success"}) {
        return $resp{"content"};
    }
    return "";
}

# Check if URL is reachable
func is_reachable(str $url) int {
    my hash %resp = LWP::head($url);
    return $resp{"success"};
}

# Get response header value
func get_header(hash %response, str $name) str {
    if (!defined($response{"headers"})) {
        return "";
    }
    my scalar $headers = $response{"headers"};
    my str $lc_name = lc($name);
    if (defined($headers->{$lc_name})) {
        return $headers->{$lc_name};
    }
    return "";
}

# UserAgent class for more complex usage
func UserAgent_new() hash {
    my hash %ua = ();
    $ua{"user_agent"} = "Strada-LWP/1.0";
    $ua{"timeout"} = 30;
    $ua{"default_headers"} = {};
    return %ua;
}

func UserAgent_set_agent(hash %ua, str $agent) void {
    $ua{"user_agent"} = $agent;
}

func UserAgent_set_timeout(hash %ua, int $timeout) void {
    $ua{"timeout"} = $timeout;
}

func UserAgent_set_header(hash %ua, str $name, str $value) void {
    my scalar $headers = $ua{"default_headers"};
    $headers->{$name} = $value;
}

func UserAgent_get(hash %ua, str $url) hash {
    my hash %options = ();
    $options{"user_agent"} = $ua{"user_agent"};
    $options{"headers"} = $ua{"default_headers"};
    return LWP::do_request("GET", $url, "", %options);
}

func UserAgent_post(hash %ua, str $url, str $data) hash {
    my hash %options = ();
    $options{"user_agent"} = $ua{"user_agent"};
    $options{"headers"} = $ua{"default_headers"};
    return LWP::do_request("POST", $url, $data, %options);
}
