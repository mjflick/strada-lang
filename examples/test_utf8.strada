# test_utf8.strada - Test UTF-8 string support
#
# Tests that string functions correctly handle multi-byte UTF-8 characters

func main(int $argc, array @argv) int {
    say("=== UTF-8 Support Test ===");
    say("");

    my int $passed = 0;
    my int $total = 0;

    # Test 1: length() with ASCII
    $total = $total + 1;
    my str $ascii = "hello";
    if (length($ascii) == 5) {
        say("OK: length('hello') = 5");
        $passed = $passed + 1;
    } else {
        say("FAIL: length('hello') = " . length($ascii) . " (expected 5)");
    }

    # Test 2: bytes() vs length() with ASCII (should be same)
    $total = $total + 1;
    if (bytes($ascii) == 5 && length($ascii) == 5) {
        say("OK: ASCII: bytes=5, length=5");
        $passed = $passed + 1;
    } else {
        say("FAIL: ASCII: bytes=" . bytes($ascii) . ", length=" . length($ascii));
    }

    # Test 3: chr() with Unicode - Euro sign (U+20AC = 8364)
    $total = $total + 1;
    my str $euro = chr(8364);
    if (length($euro) == 1 && bytes($euro) == 3) {
        say("OK: Euro sign chr(8364): length=1, bytes=3");
        $passed = $passed + 1;
    } else {
        say("FAIL: Euro sign: length=" . length($euro) . ", bytes=" . bytes($euro));
    }

    # Test 4: ord() with Unicode - should recover codepoint
    $total = $total + 1;
    my int $code = ord($euro);
    if ($code == 8364) {
        say("OK: ord(Euro) = 8364");
        $passed = $passed + 1;
    } else {
        say("FAIL: ord(Euro) = " . $code . " (expected 8364)");
    }

    # Test 5: chr() and ord() roundtrip with various codepoints
    $total = $total + 1;
    my int $heart_code = 10084;  # Red heart U+2764
    my str $heart = chr($heart_code);
    my int $recovered = ord($heart);
    if ($recovered == $heart_code) {
        say("OK: chr/ord roundtrip for heart (U+2764)");
        $passed = $passed + 1;
    } else {
        say("FAIL: roundtrip got " . $recovered . " (expected " . $heart_code . ")");
    }

    # Test 6: Build multi-character UTF-8 string and check length
    $total = $total + 1;
    # Build "AeB" where e is e-acute (U+00E9)
    my str $mixed = "A" . chr(233) . "B";  # 233 = 0xE9 = e-acute
    if (length($mixed) == 3) {
        say("OK: 'A[e-acute]B' has 3 characters");
        $passed = $passed + 1;
    } else {
        say("FAIL: 'A[e-acute]B' has " . length($mixed) . " characters (expected 3)");
    }

    # Test 7: substr() with UTF-8 - extract the middle character
    $total = $total + 1;
    my str $mid = substr($mixed, 1, 1);
    if (bytes($mid) == 2 && length($mid) == 1) {
        say("OK: substr() extracted 2-byte character correctly");
        $passed = $passed + 1;
    } else {
        say("FAIL: substr() got bytes=" . bytes($mid) . ", length=" . length($mid));
    }

    # Test 8: reverse() with UTF-8
    $total = $total + 1;
    my str $rev = reverse($mixed);
    # Expected: "B[e-acute]A"
    my str $first_char = substr($rev, 0, 1);
    my str $last_char = substr($rev, 2, 1);
    if ($first_char eq "B" && $last_char eq "A") {
        say("OK: reverse() correctly reversed UTF-8 string");
        $passed = $passed + 1;
    } else {
        say("FAIL: reverse() first='" . $first_char . "', last='" . $last_char . "'");
    }

    # Test 9: index() with UTF-8 - returns character position
    $total = $total + 1;
    # "hello[e-acute]world" - find "world" should be at char pos 6
    my str $search = "hello" . chr(233) . "world";
    my int $pos = index($search, "world");
    if ($pos == 6) {
        say("OK: index() returned character position 6");
        $passed = $passed + 1;
    } else {
        say("FAIL: index() returned " . $pos . " (expected 6)");
    }

    # Test 10: Emoji test - Grinning face (U+1F600 = 128512)
    $total = $total + 1;
    my str $emoji = chr(128512);
    if (length($emoji) == 1 && bytes($emoji) == 4) {
        say("OK: Emoji chr(128512): length=1, bytes=4");
        $passed = $passed + 1;
    } else {
        say("FAIL: Emoji: length=" . length($emoji) . ", bytes=" . bytes($emoji));
    }

    # Test 11: Emoji ord roundtrip
    $total = $total + 1;
    my int $emoji_code = ord($emoji);
    if ($emoji_code == 128512) {
        say("OK: ord(emoji) = 128512");
        $passed = $passed + 1;
    } else {
        say("FAIL: ord(emoji) = " . $emoji_code . " (expected 128512)");
    }

    # Test 12: Mixed ASCII and multi-byte in substr
    $total = $total + 1;
    my str $multi = "Hi" . chr(128075) . "!";  # "Hi[wave]!"
    if (length($multi) == 4) {
        say("OK: 'Hi[wave]!' has 4 characters");
        $passed = $passed + 1;
    } else {
        say("FAIL: 'Hi[wave]!' has " . length($multi) . " characters");
    }

    say("");
    say("=== Results ===");
    say("Passed: " . $passed . "/" . $total);

    if ($passed == $total) {
        say("All UTF-8 tests passed!");
        return 0;
    } else {
        say("Some tests failed.");
        return 1;
    }
}
